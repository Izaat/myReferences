///////////////////////////////////////////////////////////////////////
Dynamic Programming (Memoization and Tabulation in Javascript)

///////////////////////////////////////////////////////////////////////
CONTENTS

Memoization
01. Fibonacci
02. gridTraveler
03. memoization recipe
04. canSum
05. howSum
06. bestSum
07. canConstruct
08. countConstruct
09. allConstruct

Tabulation
10. Fibonacci
11. gridTraveler
12. tabulation recipe
13. canSum
14. howSum
15. bestSum
16. canConstruct
17. countConstruct
18. allConstruct


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Time Complexity
    Time taken to run the program
    https://www.youtube.com/watch?v=QnRx6V8YQy0
    
Space Complexity
    Memory usage to run a program
    https://www.youtube.com/watch?v=SHIg5UIfBnI


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
01. Fibonacci (Memoization)
    
    Question:
        Write a function 'fib(n)' that takes in a number as an argument.
        The function should return the n-th number of the Fibonacci sequence.

    Explanation:
        The 1st and 2nd number of the sequence is 1.
        To generate the next number of the sequence, we sum the previous 2.

    Example:
        n:    : 1, 2, 3, 4, 5, 6, 7,  8,   9, ...
        fib(n): 1, 1, 2, 3, 5, 8, 13, 21, 34, ...  //Note: 5+8=13
        The 7th Fibonacci is 13

    Code:
        const fib = (n) => {                 //take nth number of fib sequence
            if (n <= 2) return 1;            //if number is less or equals to 2, then return as 1
            return fib(n-1) + fib(n-2);      //sum of previous 2 sequence          
        };
        
        console.log(fib(6));                   //Answer: 8
        console.log(fib(7));                   //Answer: 13
        console.log(fib(8));                   //Answer: 21
        console.log(fib(50));                  //Answer: Takes too long to compute
    
    Problem Explanation: Example calling fib(7)
        (n-2) will be on the right side: (7-2)=5
        (n-1) will be on the left: (7-1)=6
        This will continue until it gets to 2 or 1 (Base case)
        The tree below will take shape
        //                                                                          7
        //                                               |-----------------------------------------------------------|
        //                                              6                                                            5
        //                              |-----------------------------|                                   |-----------------------|
        //                              5                             4                                   4                       3
        //                       |-------------|              |-----------------|               |-------------------|      |--------------|
        //                       4             3              3                 2               3                   2      2              1
        //            |------------|     |-----------|   |-----------|                    |----------------|   
        //            3            2     2           1   2           1                    2                1
        //    |----------|
        //    2          1
        
        Since in base case, returns 2 as 1, the integer 2 at the  bottom most of the tree will return 1
        Add 1+1 = 2
        Therefore the integer fib(3)=2
        This will continue up the tree: 3 will return as 2
        Therefore 2+1=3
        fib(4)=3
        
        See table below for full calculation:
        //                                                                       13
        //                                        |-------------------------------------------------------------------|
        //                                        8                                                                   5
        //                           |-----------------------------|                                     |--------------------------|
        //                           5                             3                                     3                          2
        //                   |-------------|                 |-----------------|               |-------------------|         |--------------|
        //                   3             2                 2                 1               2                   1         1              1
        //            |------------|   |-----------|   |-----------|                    |----------------|   
        //            2            1   1           1   1           1                    1                1
        //    |----------|
        //    1          1
        
        Final fib(7)=13
        
    Underlying Functions: (Foo, Bar, Dib, Lib, Fib)
        Foo Functions: 
            #Tree: 5 > 4 > 3 >2 > 1
            #O(n) time
            #O(n) space            
            
            const foo = (n) => {                     
                if (n <= 1) return;                
                foo(n-1);              
            };
        
        Bar Functions:
            #Tree: 6 > 4 > 2 > 0
            #O(n/2) time = O(n) time
            #O(n/2) space = O(n) space          
        
            const bar = (n) => {                     
                if (n <= 1) return;                
                bar(n-2);              
            };

        Dib Functions:
            #Tree: 
                //                                                        5                                                                  //Level 1, 1 node 
                //                                |---------------------------------------------------------|
                //                                4                                                         4                                //Level 2, 2 nodes
                //                   |-------------------------------|                           |-----------------------|
                //                   3                               3                           3                       3                   //Level 3, 4 nodes
                //            |-------------|               |-----------------|            |------------|          |------------|
                //            2             2               2                 2            2            2          2            2            //Level 4, 8 nodes
                //       |---------|   |----------|   |-----------|      |---------|   |--------|   |--------|  |--------|  |--------|  
                //       1         1   1          1   1           1      1         1   1        1   1        1  1        1  1        1       //Level 5, 16 nodes
                //
                //Height of tree = n = 5 > 4 > 3 > 2 > 1
                //To calculate number of nodes in the level = 2 to power of (5 levels - 1) = 2^(5-1) = 2^4
                //Level 4 = 2^4 = 16 nodes
                
            #O(2^n) time
            #O(n) space       
        
            const dib = (n) => {                     
                if (n <= 1) return;                
                dib(n-1);              
                dib(n-1);     
            };        

        Lib Functions:
            #Tree: 
                //                                                          8                                                                  //Level 1, 1 node 
                //                                |----------------------------------------------------------|
                //                                6                                                          6                                 //Level 2, 2 nodes
                //                    |------------------------------|                             |------------------------|
                //                    4                              4                             4                        4                  //Level 3, 4 nodes
                //             |--------------|              |-----------------|            |--------------|           |-----------|
                //             2              2              2                 2            2              2           2           2           //Level 4, 8 nodes
                //       |---------|     |----------|   |-----------|      |---------|   |--------|     |--------|  |--------|  |--------|  
                //       0         0     0          0   0           0      0         0   0        0     0        0  0        0  0        0     //Level 5, 16 nodes
                //
                //Height of tree = n/2 = n = 8 > 6 > 4 > 2 > 0
                //To calculate number of nodes in the level = 2 to power of [(5 levels - 1)] = 2^(5-1) = 2^4
                //Level 4 = 2^4 = 16 nodes
                
            #O(2^n) time
            #O(n) space           
            
            const lib = (n) => {                     
                if (n <= 1) return;                
                lib(n-2);              
                lib(n-2);     
            };     
        
        Fib Functions: (Combination of Dib and Lib)            
            #Time
                O(dib) =< O(fib) =< O(lib)
                O(2^n) =< O(2^n) =< O(2^n)
            #O(n) space 
            
            const fib = (n) => { 
                if (n <= 2) return 1;    
                return fib(n-1) + fib(n-2);         
            };

    Solution for Fib Function:
        fib(50) = 2^50 = 1.12e+15  = 1,125,899,906,842,624 //Undesireable result in the calculator therefore will take a long time to process

        Breaking down the Fibonacci Tree:
        //                                                                      7
        //                                        |-----------------------------------------------------------------|
        //                                        6                                                                 5
        //                        |----------------------------------|                                 |--------------------------|
        //                        5                                  4                                 4                          3
        //                |-----------------|               |-----------------|               |-------------------|         |--------------|
        //                4                 3               3                 2               3                   2         2              1
        //         |------------|     |-----------|   |-----------|                   |----------------|   
        //         3            2     2           1   2           1                   2                1
        //    |----------|
        //    2          1        
        //
        //Notice that there are 5 subtrees - fib(3), recursive throughout the tree
        //Also notice that there are 3 subtrees - fib(4), also recursive throughout the tree
        //Also notice that there are 2 subtrees - fib(5), also recursive throughout the tree
        //Therefore, the code must have the ability to calculate the subtrees and store the value to save time
        //Using the stored values to solve the recurring subtrees in order to save time is called Dynamic Programming

    Solution Code:
        //memoization
        //    js object, keys will be arg to fn, value will be the return value
        //    > obj = {name: 'Bob', faveColor: 'grey'}
        //    > "name" in obj                             //Returns 'True
        
    
        const fib = (n, memo = {}) => {                              //assign a memory "memo" to be an empty object, to store a key "n"
            if (n in memo) return memo [n];                          //check for existence of key inside of memo, if yes, return memo value. 
            if (n <= 2) return 1;                
            //memo [n] = fib(n-1) + fib(n-2);                        //store entire value in key     
            memo [n] = fib(n-1, memo) + fib(n-2, memo);              //store subtree value in memo
            return memo[n];
        };
        
        console.log(fib(6));                   //Answer: 8
        console.log(fib(7));                   //Answer: 13
        console.log(fib(8));                   //Answer: 21
        console.log(fib(50));                  //Answer: 12586269025
        
        Note: 
            The memo value will store a list of calculated subtree and the result will be recalled whenever the program come across a similar subtree.
            This method cuts down recurring calculation across the entire tree, therefore saving time.
            Example: fib(6)
            Memo {
                3:2,
                4:3,
                5:5,
                6:8
            }        
        
            The tree will be trimmed down leaving the tree as only a linear backbone
            
            New Tree: fib(7)
            //                                      7
            //                                |----------|
            //                                6          5           
            //                         |----------|
            //                         5          4         
            //                  |----------|
            //                  4          3        
            //           |----------|
            //           3          2
            //    |----------|
            //    2          1           
        
        
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////      
02. gridTraveler  
    Question:
        Let's say you're a traveler on a 2D grid.
        You begin in the top-left corner and your goal is to travel to the bottom right corner.
        You can only move down or right.
        In how many ways can you travel to the goal on a grid with dimensions m*n?
        Write a function 'gridTraveler(m, n)' that calculates this.
        
    Explanation:
        gridTraveler(2, 3) 
            -> 2 rows 3 col grid
            Answer: 3 ways to travel
                -> right, right, down
                -> right, down, right
                -> down, right, right
            
        gridTraveler(1, 1)
            -> 1 row 1 col, a box
            Answer: 1 way, "do nothing"

        gridTraveler(1, 0) OR gridTraveler(0, 1)
            -> "No grid"
            Answer: 0 way to travel

    Movement:
        Let's start with gridTraveler(3, 3) - 4 movements
        Moving downwards means removing the entire previous row, therefore, grid becomes gridTraveler(2, 3)
        Moving right means removing the entire previous column, therefore, grid becomes gridTraveler(2, 2)
        Moving downwards means removing the entire previous row, therefore, grid becomes gridTraveler(1, 2)
        Moving right means removing the entire previous column, therefore, grid becomes gridTraveler(1, 1)

    Forming a Tree:
        gridTraveler(2, 3) -> 3 movement
        
        //         |------|------|------|
        //         |      |      |      |
        //         |------|------|------|
        //         |      |      |      |
        //         |------|------|------|        
        
        //                                             (2,3)
        //                      |-----------------------------------------------------|
        //                  Down(1, 3)                                           Right(2, 2)
        //          |-------------------------|                          |-------------------------|
        //        NIL(0, 3)              Right(1, 2)                Down(1, 2)               Right(2, 1)
        //                            |--------------|         |--------------|           |-------------| 
        //                         NIL(0,2)     Right(1,1)    NIL(0,2)    Right(1,1)    Down(1,1)   NIL(0,0)
        //
        
   Using BaseCase calculation:
        Anything with 1,1: Returns 1
        Anything with 0: Return 0
        Add all the numbers and you will get 3 for gridTraveler(2, 3)

    CODE:
        const gridTraveler = (m, n) => {
            if (m === 1 && n === 1) return 1;                            //When grid is at (1, 1), then return as 1
            if (m === 0 || n === 0) return 0;                            //When grid is at (0, 1) OR (1, 0), then return 0
            return gridTraveler(m - 1, n) + gridTraveler(m, n - 1);      //Move down and move right
        };
        
        console.log(gridTraveler(1, 1));  //1
        console.log(gridTraveler(2, 3));  //3
        console.log(gridTraveler(3, 2));  //3
        console.log(gridTraveler(3, 3));  //6
        console.log(gridTraveler(18, 18));  //Too Slow
        
        
    Problem Explanation:
        gridTraveler(2, 3)
        //                                             (2,3)
        //                      |-----------------------------------------------------|
        //                  Down(1, 3)                                           Right(2, 2)
        //          |-------------------------|                          |-------------------------|
        //        NIL(0, 3)              Right(1, 2)                Down(1, 2)               Right(2, 1)
        //                            |--------------|         |--------------|           |-------------| 
        //                         NIL(0,2)     Right(1,1)    NIL(0,2)    Right(1,1)    Down(1,1)   NIL(0,0)
        //    

        The height of the tree is (n +m), [step 0, step 1, step 2, ..., step 4]
        #O(2^ (n+m)) time
        #O(n+m) space

    Optimizing the tree:
        Pattern with (1,2)
        Also note that if grid (1,2) is flipped to (2,1), the result will be the same
        Therefore:
            gridTraveler(a,b) = gridTraveler(b,a)
                If (1,2) = 1+0 = 1, 
                Then (2,1) = 0+1 = 1

    SOLUTION CODE:
        const gridTraveler = (m, n, memo={}) => {
            const key = m + ',' + n;                                                 //Separating comas from values by defining coma as another "key", to make program understand what comas stand for
            if (key in memo) return memo[key];                                       //Check for values in key
            if (m === 1 && n === 1) return 1;                                        //When grid is at (1, 1), then return as 1
            if (m === 0 || n === 0) return 0;                                        //When grid is at (0, 1) OR (1, 0), then return 0
            //return gridTraveler(m - 1, n) + gridTraveler(m, n - 1);                //Move down and move right
            memo[key =] gridTraveler(m - 1, n, memo) + gridTraveler(m, n - 1, memo);
            return memo[key];
        };
        
        console.log(gridTraveler(1, 1));  //1
        console.log(gridTraveler(2, 3));  //3
        console.log(gridTraveler(3, 2));  //3
        console.log(gridTraveler(3, 3));  //6
        console.log(gridTraveler(18, 18));  //2333606220
       
        
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
03. Memoization Recipe        
























