///////////////////////////////////////////////////////////////////////
Dynamic Programming (Memoization and Tabulation in Javascript)
CTRL+C to stop coderun in VSCode
///////////////////////////////////////////////////////////////////////
CONTENTS

Memoization
01. Fibonacci
02. gridTraveler
03. memoization recipe
04. canSum
05. howSum
06. bestSum
07. canConstruct
08. countConstruct
09. allConstruct

Tabulation
10. Fibonacci
11. gridTraveler
12. tabulation recipe
13. canSum
14. howSum
15. bestSum
16. canConstruct
17. countConstruct
18. allConstruct

**to run program, type in: node *.js
NOTE: 
    For Python: https://github.com/medwatt/Notes/tree/main/Python/Dynamic_Programming
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Big O Analysis
    https://www.youtube.com/watch?v=HfIH3czXc-8

Time Complexity
    Time taken to run the program
    https://www.youtube.com/watch?v=QnRx6V8YQy0
    
Space Complexity
    Memory usage to run a program
    https://www.youtube.com/watch?v=SHIg5UIfBnI

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
01. Fibonacci (Memoization)
    
    Question:
        Write a function 'fib(n)' that takes in a number as an argument.
        The function should return the n-th number of the Fibonacci sequence.

    Explanation:
        The 1st and 2nd number of the sequence is 1.
        To generate the next number of the sequence, we sum the previous 2.

    Example:
        n:    : 1, 2, 3, 4, 5, 6, 7,  8,   9, ...
        fib(n): 1, 1, 2, 3, 5, 8, 13, 21, 34, ...  //Note: 5+8=13
        The 7th Fibonacci is 13

    Code:
        const fib = (n) => {                 //take nth number of fib sequence
            if (n <= 2) return 1;            //if number is less or equals to 2, then return as 1
            return fib(n-1) + fib(n-2);      //sum of previous 2 sequence          
        };
        
        console.log(fib(6));                   //Answer: 8
        console.log(fib(7));                   //Answer: 13
        console.log(fib(8));                   //Answer: 21
        console.log(fib(50));                  //Answer: Takes too long to compute
    
    Problem Explanation: Example calling fib(7)
        (n-2) will be on the right side: (7-2)=5
        (n-1) will be on the left: (7-1)=6
        This will continue until it gets to 2 or 1 (Base case)
        The tree below will take shape
        //                                                                          7
        //                                               |-----------------------------------------------------------|
        //                                              6                                                            5
        //                              |-----------------------------|                                   |-----------------------|
        //                              5                             4                                   4                       3
        //                       |-------------|              |-----------------|               |-------------------|      |--------------|
        //                       4             3              3                 2               3                   2      2              1
        //            |------------|     |-----------|   |-----------|                    |----------------|   
        //            3            2     2           1   2           1                    2                1
        //    |----------|
        //    2          1
        
        Since in base case, returns 2 as 1, the integer 2 at the  bottom most of the tree will return 1
        Add 1+1 = 2
        Therefore the integer fib(3)=2
        This will continue up the tree: 3 will return as 2
        Therefore 2+1=3
        fib(4)=3
        
        See table below for full calculation:
        //                                                                       13
        //                                        |-------------------------------------------------------------------|
        //                                        8                                                                   5
        //                           |-----------------------------|                                     |--------------------------|
        //                           5                             3                                     3                          2
        //                   |-------------|                 |-----------------|               |-------------------|         |--------------|
        //                   3             2                 2                 1               2                   1         1              1
        //            |------------|   |-----------|   |-----------|                    |----------------|   
        //            2            1   1           1   1           1                    1                1
        //    |----------|
        //    1          1
        
        Final fib(7)=13
        
    Underlying Functions: (Foo, Bar, Dib, Lib, Fib)
        Foo Functions: 
            #Tree: 5 > 4 > 3 >2 > 1
            #O(n) time
            #O(n) space            
            
            const foo = (n) => {                     
                if (n <= 1) return;                
                foo(n-1);              
            };
        
        Bar Functions:
            #Tree: 6 > 4 > 2 > 0
            #O(n/2) time = O(n) time
            #O(n/2) space = O(n) space          
        
            const bar = (n) => {                     
                if (n <= 1) return;                
                bar(n-2);              
            };

        Dib Functions:
            #Tree: 
                //                                                        5                                                                  //Level 1, 1 node 
                //                                |---------------------------------------------------------|
                //                                4                                                         4                                //Level 2, 2 nodes
                //                   |-------------------------------|                           |-----------------------|
                //                   3                               3                           3                       3                   //Level 3, 4 nodes
                //            |-------------|               |-----------------|            |------------|          |------------|
                //            2             2               2                 2            2            2          2            2            //Level 4, 8 nodes
                //       |---------|   |----------|   |-----------|      |---------|   |--------|   |--------|  |--------|  |--------|  
                //       1         1   1          1   1           1      1         1   1        1   1        1  1        1  1        1       //Level 5, 16 nodes
                //
                //Height of tree = n = 5 > 4 > 3 > 2 > 1
                //To calculate number of nodes in the level = 2 to power of (5 levels - 1) = 2^(5-1) = 2^4
                //Level 4 = 2^4 = 16 nodes
                
            #O(2^n) time
            #O(n) space       
        
            const dib = (n) => {                     
                if (n <= 1) return;                
                dib(n-1);              
                dib(n-1);     
            };        

        Lib Functions:
            #Tree: 
                //                                                          8                                                                  //Level 1, 1 node 
                //                                |----------------------------------------------------------|
                //                                6                                                          6                                 //Level 2, 2 nodes
                //                    |------------------------------|                             |------------------------|
                //                    4                              4                             4                        4                  //Level 3, 4 nodes
                //             |--------------|              |-----------------|            |--------------|           |-----------|
                //             2              2              2                 2            2              2           2           2           //Level 4, 8 nodes
                //       |---------|     |----------|   |-----------|      |---------|   |--------|     |--------|  |--------|  |--------|  
                //       0         0     0          0   0           0      0         0   0        0     0        0  0        0  0        0     //Level 5, 16 nodes
                //
                //Height of tree = n/2 = n = 8 > 6 > 4 > 2 > 0
                //To calculate number of nodes in the level = 2 to power of [(5 levels - 1)] = 2^(5-1) = 2^4
                //Level 4 = 2^4 = 16 nodes
                
            #O(2^n) time
            #O(n) space           
            
            const lib = (n) => {                     
                if (n <= 1) return;                
                lib(n-2);              
                lib(n-2);     
            };     
        
        Fib Functions: (Combination of Dib and Lib)            
            #Time
                O(dib) =< O(fib) =< O(lib)
                O(2^n) =< O(2^n) =< O(2^n)
            #O(n) space 
            
            const fib = (n) => { 
                if (n <= 2) return 1;    
                return fib(n-1) + fib(n-2);         
            };

    Solution for Fib Function:
        fib(50) = 2^50 = 1.12e+15  = 1,125,899,906,842,624 //Undesireable result in the calculator therefore will take a long time to process

        Breaking down the Fibonacci Tree:
        //                                                                      7
        //                                        |-----------------------------------------------------------------|
        //                                        6                                                                 5
        //                        |----------------------------------|                                 |--------------------------|
        //                        5                                  4                                 4                          3
        //                |-----------------|               |-----------------|               |-------------------|         |--------------|
        //                4                 3               3                 2               3                   2         2              1
        //         |------------|     |-----------|   |-----------|                   |----------------|   
        //         3            2     2           1   2           1                   2                1
        //    |----------|
        //    2          1        
        //
        //Notice that there are 5 subtrees - fib(3), recursive throughout the tree
        //Also notice that there are 3 subtrees - fib(4), also recursive throughout the tree
        //Also notice that there are 2 subtrees - fib(5), also recursive throughout the tree
        //Therefore, the code must have the ability to calculate the subtrees and store the value to save time
        //Using the stored values to solve the recurring subtrees in order to save time is called Dynamic Programming

    Solution Code:
        //memoization
        //    js object, keys will be arg to fn, value will be the return value
        //    > obj = {name: 'Bob', faveColor: 'grey'}
        //    > "name" in obj                             //Returns 'True
        
    
        const fib = (n, memo = {}) => {                              //assign a memory "memo" to be an empty object, to store a key "n"
            if (n in memo) return memo [n];                          //check for existence of key inside of memo, if yes, return memo value. 
            if (n <= 2) return 1;                
            //memo [n] = fib(n-1) + fib(n-2);                        //store entire value in key     
            memo [n] = fib(n-1, memo) + fib(n-2, memo);              //store subtree value in memo
            return memo[n];
        };
        
        console.log(fib(6));                   //Answer: 8
        console.log(fib(7));                   //Answer: 13
        console.log(fib(8));                   //Answer: 21
        console.log(fib(50));                  //Answer: 12586269025
        
        Note: 
            The memo value will store a list of calculated subtree and the result will be recalled whenever the program come across a similar subtree.
            This method cuts down recurring calculation across the entire tree, therefore saving time.
            Example: fib(6)
            Memo {
                3:2,
                4:3,
                5:5,
                6:8
            }        
        
            The tree will be trimmed down leaving the tree as only a linear backbone
            
            New Tree: fib(7)
            //                                      7
            //                                |----------|
            //                                6          5           
            //                         |----------|
            //                         5          4         
            //                  |----------|
            //                  4          3        
            //           |----------|
            //           3          2
            //    |----------|
            //    2          1           
        
        
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////      
02. gridTraveler  
    Question:
        Let's say you're a traveler on a 2D grid.
        You begin in the top-left corner and your goal is to travel to the bottom right corner.
        You can only move down or right.
        In how many ways can you travel to the goal on a grid with dimensions m*n?
        Write a function 'gridTraveler(m, n)' that calculates this.
        
    Explanation:
        gridTraveler(2, 3) 
            -> 2 rows 3 col grid
            Answer: 3 ways to travel
                -> right, right, down
                -> right, down, right
                -> down, right, right
            
        gridTraveler(1, 1)
            -> 1 row 1 col, a box
            Answer: 1 way, "do nothing"

        gridTraveler(1, 0) OR gridTraveler(0, 1)
            -> "No grid"
            Answer: 0 way to travel

    Movement:
        Let's start with gridTraveler(3, 3) - 4 movements
        Moving downwards means removing the entire previous row, therefore, grid becomes gridTraveler(2, 3)
        Moving right means removing the entire previous column, therefore, grid becomes gridTraveler(2, 2)
        Moving downwards means removing the entire previous row, therefore, grid becomes gridTraveler(1, 2)
        Moving right means removing the entire previous column, therefore, grid becomes gridTraveler(1, 1)

    Forming a Tree:
        gridTraveler(2, 3) -> 3 movement
        
        //         |------|------|------|
        //         |      |      |      |
        //         |------|------|------|
        //         |      |      |      |
        //         |------|------|------|        
        
        //                                             (2,3)
        //                      |-----------------------------------------------------|
        //                  Down(1, 3)                                           Right(2, 2)
        //          |-------------------------|                          |-------------------------|
        //        NIL(0, 3)              Right(1, 2)                Down(1, 2)               Right(2, 1)
        //                            |--------------|         |--------------|           |-------------| 
        //                         NIL(0,2)     Right(1,1)    NIL(0,2)    Right(1,1)    Down(1,1)   NIL(0,0)
        //
        
   Using BaseCase calculation:
        Anything with 1,1: Returns 1
        Anything with 0: Return 0
        Add all the numbers and you will get 3 for gridTraveler(2, 3)

    CODE:
        const gridTraveler = (m, n) => {
            if (m === 1 && n === 1) return 1;                            //When grid is at (1, 1), then return as 1
            if (m === 0 || n === 0) return 0;                            //When grid is at (0, 1) OR (1, 0), then return 0
            return gridTraveler(m - 1, n) + gridTraveler(m, n - 1);      //Move down and move right
        };
        
        console.log(gridTraveler(1, 1));  //1
        console.log(gridTraveler(2, 3));  //3
        console.log(gridTraveler(3, 2));  //3
        console.log(gridTraveler(3, 3));  //6
        console.log(gridTraveler(18, 18));  //Too Slow
        
        
    Problem Explanation:
        gridTraveler(2, 3)
        //                                             (2,3)
        //                      |-----------------------------------------------------|
        //                  Down(1, 3)                                           Right(2, 2)
        //          |-------------------------|                          |-------------------------|
        //        NIL(0, 3)              Right(1, 2)                Down(1, 2)               Right(2, 1)
        //                            |--------------|         |--------------|           |-------------| 
        //                         NIL(0,2)     Right(1,1)    NIL(0,2)    Right(1,1)    Down(1,1)   NIL(0,0)
        //    

        The height of the tree is (n +m), [step 0, step 1, step 2, ..., step 4]
        #O(2^ (n+m)) time
        #O(n+m) space

    Optimizing the tree:
        Pattern with (1,2)
        Also note that if grid (1,2) is flipped to (2,1), the result will be the same
        Therefore:
            gridTraveler(a,b) = gridTraveler(b,a)
                If (1,2) = 1+0 = 1, 
                Then (2,1) = 0+1 = 1

    SOLUTION CODE:
        const gridTraveler = (m, n, memo={}) => {
            const key = m + ',' + n;                                                 //Separating comas from values by defining coma as another "key", to make program understand what comas stand for
            if (key in memo) return memo[key];                                       //Check for values in key
            if (m === 1 && n === 1) return 1;                                        //When grid is at (1, 1), then return as 1
            if (m === 0 || n === 0) return 0;                                        //When grid is at (0, 1) OR (1, 0), then return 0
            //return gridTraveler(m - 1, n) + gridTraveler(m, n - 1);                //Move down and move right
            memo[key =] gridTraveler(m - 1, n, memo) + gridTraveler(m, n - 1, memo);
            return memo[key];
        };
        
        console.log(gridTraveler(1, 1));  //1
        console.log(gridTraveler(2, 3));  //3
        console.log(gridTraveler(3, 2));  //3
        console.log(gridTraveler(3, 3));  //6
        console.log(gridTraveler(18, 18));  //2333606220
       
        
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
03. Memoization Recipe

    #Make it work
        > Visualize the problem as a tree
        > Implement the tree using recursion (base cases)
        > Test the brute force solution (Know the difference between code that is slow vs code that is wrong)
        
    #Make it efficient
        > Add memo object into the brute force code (adding keys, return values)
        > Add new base cases to return memo values (via flip subtree, subtree patterns)
        > implement return values into the memo to make a list

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
04. canSum
    
    Question:
        Write a function 'canSum(targetSum, numbers)' that takes in a targetSum and an array of numbers as arguments
        The function should return a boolean indicating whether or not it is possible to generate the targetSum using numbers from the array
        You may use an element of the array as many times as needed
        You may assume that all input numbers are non-negative (can't be subtracted)
    
    Explanation:
        canSum(7, [5, 3, 4, 7]) -> true         //The target number is outside square bracket
        7 can be generated by recalling 7 or adding 3 and 4 from the array
     
        canSum(7 [2, 4]) -> false
        The number doesnt exist within the array and cant be calculated to get 7

    Tree: canSum(7, [5, 3, 4, 7]) -> True
        // 
        //                                 7
        //      |-----------------|------------------|------------------|
        //    -5|               -3|                -4|                -7|
        //      |                 |                  |                  |
        //      2                 4                  3                  0
        //                  |------------|     |------------|       
        //                -3|          -4|   -3|           N/A
        //                  |            |     |
        //                  1            0     0
        //        
        NOTE: 
            From the tree, 0 will be used as the base case
            Therefore, if basecase is 0, then return True. 
            If basecase is NOT 0, return False
            For the Parent-Child tree, if either child node is True, then return True

    Tree: canSum(7, [2, 4]) -> False
        // 
        //                         7
        //               |------------------|
        //              2|                -4|
        //               |                  | 
        //               5                  3 
        //        |------------|      |------------|       
        //      -2|          -4|    -2|           N/A
        //        |            |      |
        //        3            1      1
        //      -2|            
        //        | 
        //        1   
        //

    CODE: - Brute Force Method
        const canSum = (targetSum, numbers) => {                     //numbers array added
            if (targetSum === 0) return true;                        //if targetSum is 0, then return True            
            if (targetSum < 0) return false;                         //Preventing more calculations to be done in for loop if it hits negative numbers
            
            for (let num of numbers) {                               //Add recursive function, iterate through the array of numbers using num
                //console.log(num);                                  //Check the array 
                const remainder = targetSum - num;                   //Calculate the targetsum result by subtracting the numbers in array (Note that this may go to negative numbers)
                //canSum(remainder, numbers);                        //store remainder in numbers array.
                if (canSum(remainder, numbers) === true) {           //canSum is a boolean (true/false), if true, then return true
                    return true;
                }
            }         
            
            return false;                                            //Reason after for loop, after attempt all possibilities in for loop, return false
   
        };
  
        console.log(canSum(7, [2, 3]));           //True
        console.log(canSum(7, [5, 3, 4, 7]));     //True
        console.log(canSum(7, [2, 4]));           //False
        console.log(canSum(8, [2, 3, 5]));        //True
        console.log(canSum(300, [7, 14]));        //Takes too long to calculate
        
    Tree structure with more complexity: 
        Example: canSum(8, [2, 3, 5]) -> True
        //   
        //                                                                                     8
        //                                  |--------------------------------------------------|----------------------------------------|
        //                                -2|                                                -3|                                      -5|
        //                                  |                                                  |                                        |
        //                                  6                                                  5                                        3 
        //              |-------------------|------------------|           |-------------------|--------------------|          |-------------------|
        //            -2|                 -3|                -5|         -2|                 -3|                  -5|        -2|                 -3|                    
        //              |                   |                  |           |                   |                    |          |                   | 
        //              4                   3                  1           3                   2                    0          1                   0
        //       |------------|       |------------|                 |------------|            |               
        //     -2|          -3|     -2|            3               -2|          -3|          -2|                       
        //       |            |       |            |                 |            |            |
        //       2            1       1            0                 1            0            0               
        //     -2|            
        //       | 
        //       0   
        //
        m = tragetSum size
        n = length of array
        height of tree (from top to basecase)
            Because you have to subtract the target sum from the array for 'm' times, so the height will be 'm'
            Therefore, the number of levels is 'm'
        branching factor = number of array length = 3 = n
            If there are 3 numbers in the array, a node would have 3 children
        Complexity
            Time:
                To find the number of nodes, n multiply by n for m times
                Therefore: O(n^m) time                
            Space:
                Just the height of the tree
                O(m) space

    Optimizing: canSum(8, [2, 3, 5])
        Notice that the subtree node 3 with basecases of 1 and 0 is a pattern (3 subtrees)
            The 3 subtrees is the answer for canSum(3, [2, 3, 5])

    CODE: - Memoize Method
        const canSum = (targetSum, numbers, memo={}) => {            //add in memo object
            if (targetSum in memo) return memo[targetSum];           //use targetSum as key for memo
            if (targetSum === 0) return true;      
            if (targetSum < 0) return false;
            
            for (let num of numbers) {      
                const remainder = targetSum - num;         
                if (canSum(remainder, numbers, memo) === true) {      //add in recursive call
                    memo[targetSum] = true;                           //this adds the return value into the memo
                    return true;                                      //this return value will be added into the memo
                }
            }         
            memo[targetSum] = false;                                  //this adds the return value into the memo
            return false;                                             //this return value will be added into the memo
   
        };
  
        console.log(canSum(7, [2, 3]));           //True
        console.log(canSum(7, [5, 3, 4, 7]));     //True
        console.log(canSum(7, [2, 4]));           //False
        console.log(canSum(8, [2, 3, 5]));        //True
        console.log(canSum(300, [7, 14]));        //False

    Explanation:
        Tree:
            m = tragetSum size
            n = length of array
        Brute Force:
            O(n^m) time
            O(m) space
        Memoized:
            O(n*m) time -> Because the program does not need to branch out but instead just recall values directly from the memo
            O(m) space            

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
05. howSum

    Question:
        Write a function 'howSum(targetSum, numbers)' that takes in a targetSum and an array of numbers as arguments.
        The function should return an array containing any combination of elements that add up to exactly the targetSum.
        If there is no combination that adds up to the targetSum, then return null.
        If there are multiple combinations possible, you may return any single one.
        
    Example: 
        howSum(7, [5, 3, 4, 7]) -> Answer: [3, 4] OR [4, 3] OR [7]
        howSum(8, [2, 3, 5]) -> Answer: [3, 5] OR [2, 2, 2, 2]
        howSum(7, [2, 4]) -> Answer: null
        howSum(0, [1, 2, 3]) -> Answer: [] //Takes no element if it's an empty array, even when it does, summing up an empty array will still be 0

    Structure: howSum(7, [5, 3, 4, 7])
        Tree:
        // 
        //                                7
        //      |-----------------|------------------|------------------|
        //    -5|               -3|                -4|                -7|
        //      |                 |                  |                  |
        //      2                 4                  3                  0
        //                  |------------|           |     
        //                -3|          -4|         -3| 
        //                  |            |           |
        //                  1            0           0
        //        
        NOTE:
            Basecase: 0
                Basecases with 0 are already solved because the combination will be empty array
                Therefore, whenever the basecase is 0, return an empty array
                When it goes to the parent node, it needs a parent label, therefore, taking the last subtracted number, -> [4]
                This empty array will again push up to another parent and take in another subtracted number, -> [4, 3]
                Now with that array, node 7 contains [4, 3]
                Therefore, howSum(7, [5, 3, 4, 7]) -> [4, 3]
            Basecase: 2
                For basecase of 2, empty array returns 'null'
            Basecase: 1
                Take note that the other node 4 contains [4] from another child
                From child node 1, [null] is being generated
                Therefore, at node 4, comparator needs to be introduced: Array will always overwrite the null
                Comparison will be repeated until the the top of the tree

    CODE: - Brute Force Method, similar to canSum
        const howSum = (targetSum, numbers) => {    
            if (targetSum === 0) return [];                                //returns an empty array
            if (targetSum < 0) return null;                                //return null if targetsum is below 0 (negative numbers)
            
            for (let num of numbers) {                                
                const remainder = targetSum - num;             
                //howSum(remainder, numbers)
                const remainderResult = howSum(remainder, numbers);       //type howSum returns (array or null element) and store in remainderResult variable
                if (remainderResult !== null) {                           //check remainderResult variable and if not element(null), return the value stored in remainderResult
                    return [...remainderResult, num];                     // [...remainderResult] means copying array into another array (restoperator/spreadoperator)
                }
            }         
            
            return null;                         
   
        };
  
        console.log(howSum(7, [2, 3]));           //[3, 2, 2]
        console.log(howSum(7, [5, 3, 4, 7]));     //[4, 3]
        console.log(howSum(7, [2, 4]));          //null
        console.log(howSum(8, [2, 3, 5]));       //[2, 2, 2, 2]
        console.log(howSum(300, [7, 14]));       //Takes too long to compute

    Explanation: [...remainderResult]
        arr = ['a', 'b', 'c']
        newArr = [...arr]                       //arr will copy to newArr
        otherArray = [...arr, 'z']              //otherArray will be ['a', 'b', 'c', 'z']
        
    Explanation: -Similar to canSum
        m = tragetSum size
        n = length of array
        height of tree (from top to basecase)
            Because you have to subtract the target sum from the array for 'm' times, so the height will be 'm'
            Therefore, the number of levels is 'm'
        branching factor = number of array length = 3 = n
            If there are 3 numbers in the array, a node would have 3 children
        Complexity
            Time:
                To find the number of nodes, n multiply by n for m times
                Therefore: O(n^m) time           
                However, the restoperator adds in 'm' steps by copying an array
                Therefore: O(n^m * m) time 
            Space:
                Just the height of the tree
                O(m) space


    CODE: - Memoization Method, similar to canSum
        const howSum = (targetSum, numbers, memo={}) => {                   //add in memo object
            if (targetSum in memo) return memo;                             //use targetSum as key for memo
            if (targetSum === 0) return [];                 
            if (targetSum < 0) return null;     
            
            for (let num of numbers) {                                
                const remainder = targetSum - num;             
                const remainderResult = howSum(remainder, numbers, memo);   //add memo object to all recursive call
                if (remainderResult !== null) {                           
                    //return [...remainderResult, num];                     //return value to be stored in memo
                    memo[targetSum] = [...remainderResult, num];  
                    return memo[targetSum];
                }
            }         
            
            //return null;                         //return value has to be stored in memo
            memo[targetSum] = null;
            return null;
   
        };
  
        console.log(howSum(7, [2, 3]));           //[3, 2, 2]
        console.log(howSum(7, [5, 3, 4, 7]));     //[4, 3]
        console.log(howSum(7, [2, 4]));           //null
        console.log(howSum(8, [2, 3, 5]));        //[2, 2, 2, 2]
        console.log(howSum(300, [7, 14]));        //null



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
06. bestSum
    Question:
        Write a function 'bestSum(targetSum, numbers)' that takes in a targetSum and an array of numbers as arguments.
        The function should return an array containing the shortest combination of numbers that add up to exactly the targetSum.
        If there is a tie for the shortest combination, you may return any one of the shortest.
        
    Example: 
        bestSum(7, [5, 3, 4, 7]) 
            Solution: [3, 4] OR [7]
            But may need to choose the solution with the smallest arrays
            Therefore: [7]
        bestSum(8, [2, 3, 5]) 
            Solution: [2, 2, 2, 2] OR [2, 3, 3] OR [3, 5]
            But may need to choose the solution with the smallest arrays
            Therefore: [3, 5]

    Structure: bestSum(8, [2, 3, 5])
        Example: canSum(8, [2, 3, 5]) -> True
        //   
        //                                                                             8
        //                                  |------------------------------------------|-----------------------------------|
        //                                -2|                                        -3|                                 -5|
        //                                  |                                          |                                   |
        //                                  6                                          5                                   3 
        //              |----------------|---------------|             |---------------|--------------|          |-------------------|
        //            -2|              -3|             -5|           -2|             -3|            -5|        -2|                 -3|                    
        //              |                |               |             |               |              |          |                   | 
        //              4                3               1             3               2              0          1                   0
        //       |------------|    |------------|                |------------|        |                  
        //     -2|          -3|  -2|            3              -2|          -3|      -2|                       
        //       |            |    |            |                |            |        |
        //       2            1    1            0                1            0        0               
        //     -2|            
        //       | 
        //       0   
        //
        Finding the best subtree
            Here, subtree with node 6 will be used
            Result to get to basecase will be [2, 2, 2] and the other basecase will be [3, 3]
            With the 2 options, the shortest path will be [3, 3]
            Therefore, the answer to the question for the shortest path for node 6 will be [3, 3]
            
        Adding to parent node 8
            With the above subtree, the array will go to the parent node 8
            Therefore, [3, 3] will become [3, 3, 2] at node 8

        Repeat on another subtree (node 5) and (node 3)
            The shortest path for node 5 will be [5]
            At node 8, path will be [5, 3]
            For node 3, path at parent node 8 will be [3, 5]

        Parent node 8
            Now node 8 has 3 paths, [3, 3, 3] , [5, 3] and [3, 5]
            The program will then choose the first answer - [5, 3]
            Note that [3, 5] comes after [5, 3]
            Therefore, the answer for bestSum(8, [2, 3, 5]) will be [5, 3]

    CODE: Brute Force Method - Similar to howSum
        const bestSum = (targetSum, numbers) => {
            if (targetSum === 0) return [];
            if (targetSum < 0) return null;
            
            let shortestCombination = null;                                        //combination default set as null, this adds m to space complexity
            
            for (let num of numbers) {                                             // 'of' - get element, 'in' - get index
                const remainder = targetSum - num;                                                
                const remainderCombination = bestSum(remainder, numbers);
                if (remainderCombination !== null) {
                    //[...remainderCombination, num]                               //a combination for targetSum
                    const combination = [...remainderCombination, num];
                    //if the combination is shorter than the current shortest, then update
                    if (shortestCombination === null || combination.length < shortestCombination.length) {
                        shortestCombination = combination;                        //assign shortestCombination with combination which is shorter 
                    }
                }
            }
            return shortestCombination;
        };
        
        console.log(bestSum(7, [5, 3, 4, 7]));          //[7]
        console.log(bestSum(8, [2, 3, 5]));             //[3, 5]
        console.log(bestSum(8, [1, 4, 5]));             //[4, 4]
        console.log(bestSum(100, [1, 2, 5, 25]));       //Too slow 
         

    CODE: Memoization Method - Similar to howSum
        const bestSum = (targetSum, numbers, memo = {}) => {
            if (targetSum in memo) return memo[targetSum];
            if (targetSum === 0) return [];
            if (targetSum < 0) return null;
            
            let shortestCombination = null;  
            
            for (let num of numbers) {                                                                       
                const remainder = targetSum - num;                                                
                const remainderCombination = bestSum(remainder, numbers, memo);
                if (remainderCombination !== null) {
                    //[...remainderCombination, num]                                    
                    const combination = [...remainderCombination, num];
                    //if the combination is shorter than the current shortest, then update
                    if (shortestCombination === null || combination.length < shortestCombination.length) {
                        shortestCombination = combination;                    
                    }
                }
            }
            //return shortestCombination;               //to be stored in memo
            memo[targetSum] = shortestCombination;
            return shortestCombination;
        };
        
        console.log(bestSum(7, [5, 3, 4, 7]));          //[7]
        console.log(bestSum(8, [2, 3, 5]));             //[3, 5]
        console.log(bestSum(8, [1, 4, 5]));             //[4, 4]
        console.log(bestSum(100, [1, 2, 5, 25]));       //[25, 25, 25, 25]
        
        NOTE: The Time complexity and Space complexity are the same as howSum
        Brute Force:
            time: O(n^m * m)
            space: O(m^2)
            
        Memoization:
            time: O(m^2 * n)
            space: O(m^2)


SUMMARY
NOTE: In a nutshell
    canSum -> Can you do it "Yes/No"?          - Boolean
    howSum -> How will you do it?              - Arrays
    bestSum -> What is the best way to do it - Combination, Optimization
    
    

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
07. canConstruct
    Question:
        Write a function 'canConstruct(target, wordBank)' that accepts a target string and an array of strings.
        The function should return a boolean indicating whether ot not the 'target' can be constructed by concatenating
        elements of the 'wordBank array.
        You may reuse elements of 'wordBank' as many times as needed
        
    Example:
        canConstruct(abcdef, [ab, abc, cd, def, abcd]) -> Answer: True
            Constructing 'abcdef' using elements of the array -> abc + def

        canConstruct(skateboard, [bo, rd, ate, t, ska, sk, boar]) -> Answer: False
        
        canConstruct('', [cat, dog, mouse]) -> True
            Empty strings can take in any elements from the array

    Visualization:
        canConstruct(abcdef, [ab, abc, cd, def, abcd])
        NOTE: Can't take out anything from the middle of the string ("cd" and "def" cannot be used), only prefixes can be used
        //   
        //                                              abcdef
        //                |--------------------------------|-----------------------------|
        //             -ab|                            -abc|                        -abcd|
        //                |                                |                             |
        //              cdef                              def                            ef
        //                |                                |               
        //             -cd|                            -def|                                 
        //                |                                |              
        //               ef                               ''                    
        //                                                             
        //NOTE: 
            'ef' becomes the basecase
            If reach 'ef', return False
            If reach empty string, return True

        canConstruct(skateboard, [bo, rd, ate, t, ska, sk, boar] 
        //
        //                              skateboard
        //                |--------------------------------|
        //            -ska|                             -sk|  
        //                |                                | 
        //             teboard                          ateboard  
        //                |                                |               
        //              -t|                            -ate|                                 
        //                |                                |              
        //             eboard                            board                   
        //                                                 |
        //                                        |------------------|        
        //                                    -bo |            -boar |
        //                                        |                  |       
        //                                       ard                 d
        //NOTE: 
            All basecases returns False
 


    CODE: Brute Force Method
        const canConstruct = (target, wordBank) => {
            if (target === '') {           //check if target is an empty string
                return true;               //if empty string, return true. So this stops taking string from wordBank
            }
            
            for (let word of wordBank) {             //iterating through all the elements (words) in the array (wordBank)
                if (target.indexOf(word) === 0) {  //Check if substring (word) is a prefix of target string, if it is 0, run code
                    const suffix = target.slice(word.length);
                    if (canConstruct(suffix, wordBank) === true) {
                        return true;
                    }
                }
            }
            return false;
        };
        
        console.log(canConstruct("abcdef", ["ab", "abc", "cd", "def", "abcd"]));                      //true
        console.log(canConstruct(skateboard, ["bo", "rd", "ate", "t", "ska", "sk", "boar"]));     //false
        console.log(canConstruct(enterapotentpot, ["a", "p", "ent", "enter", "ot", "o", "t"]));  //true
        console.log(canConstruct(eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef, ["e", "ee", "eee", "eeee", "eeeee", "eeeeee"]));  //True Slow
        
    Example01: target.indexOf(word) === 0;
        "potato".indexOf('pot')    //Answer: Index 0
        "potato".indexOf('tato')    //Answer: Index 2

    Example02: const suffix = target.slice(word.length);
        word = 'pot';
        target = 'potato';
        target.slice(word.length);  //Answer: 'ato'

    Structure:
        m = target.length -> Height
        n = wordBank.length -> Width -> 1 * n (n multiplies by itself as it descends every level) -> O(n^m) time
            Therefore: target.slice(word.length) = O((n^m)*m) time, 
            Multiplied by 'm' since target will be called repetitively to be sliced
            But the one that affects the time is the ^m
        Time: O((n^m)*m)
        Space:
            const suffix = target.slice(word.length);    //each slice will return a new string and then be stored in suffix. 
            if (canConstruct(suffix, wordBank)) { ... }  //Every new string is length 'm'
            Therefore: O(m) -> O(m*m) -> O(m^2)

        Time: O((n^m)*m) -> Exponential in time
        Space: O(m^2) -> Quadratic in space     

    Explanation:
        canConstruct(enterapotentpot, ["a", "p", "ent", "enter", "ot", "o", "t"])
        //
        //                         enterapotentpot
        //                |-----------------------------------------|
        //            -ent|                                  -enter |  
        //                |                                         | 
        //          erapotentpot                               apotentpot
        //                                                          |               
        //                                                        -a|                                 
        //                                                          |              
        //                                                     potentpot                  
        //                                                          |
        //                                                          |               
        //                                                        -p|                                 
        //                                                          |              
        //                                                       otentpot                 
        //                                                          |
        //                                     |--------------------------------|        
        //                                  -o |                            -ot |
        //                                     |                                |       
        //                                  tentpot                           entpot    
        //                                     |                                |    
        //                                  -t |                           -ent |
        //                                     |                                |       
        //                                  entpot                             pot        
        //                                     |                                |    
        //                                -ent |                             -p |
        //                                     |                                |       
        //                                    pot                               ot        
        //                                     |                     |------------------------| 
        //                                  -p |                   -o|                     -ot|
        //                                     |                     |                        |
        //                                    ot                     t                       ' ' 
        //                     |------------------------|            |
        //                   -o|                     -ot|         -t |
        //                     |                        |            |
        //                     t                       ' '          ' '
        //                     |                     
        //                   -t| 
        //                     |  
        //                    ' '
        //Pattern Subtree: 
            "entpot", to be stored in memo
            canConstruct('entpot')
        
    CODE: Memoization Method
        const canConstruct = (target, wordBank, memo={}) => {           //Create memo object
            if (target in memo) return memo[target];                               //Using target as the key
            if (target === '') return true;    
            
            for (let word of wordBank) {            
                if (target.indexOf(word) === 0) {  
                    const suffix = target.slice(word.length);
                    if (canConstruct(suffix, wordBank, memo) === true) {
                        //return true;                                                                //store in memo before completing the return
                        memo[target] = true
                        return true;
                    }
                }
            }
            //return false;                                                                          //store in memo before completing the return
            memo[target] = false;
            return false;
        };
        
        console.log(canConstruct("abcdef", ["ab", "abc", "cd", "def", "abcd"]));                      //true
        console.log(canConstruct(skateboard, ["bo", "rd", "ate", "t", "ska", "sk", "boar"]));     //false
        console.log(canConstruct(enterapotentpot, ["a", "p", "ent", "enter", "ot", "o", "t"]));  //true
        console.log(canConstruct(eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef, ["e", "ee", "eee", "eeee", "eeeee", "eeeeee"]));  //false     

    Brute Force
        O((n^m) * m) time
        O(m^2) space
    Memoized
        O(n*(m^2)) time
        O(m^2) space


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
08. countConstruct
    
    Question:
        Write a function 'countConstruct(target, wordBank)' that accepts a target string and an array of strings.
        The function should return the number of ways that the 'target' can be constructed by concatenating elements of the 'wordBank' array
        You may reuse elements of 'wordBank' as many times as needed.

    Example:
        countConstruct(abcdef, [ab, abc, cd, def, abcd]) -> Answer: 1
        countConstruct(purple, [purp, p, ur, le, purpl]) -> Answer: 2

    Visualization:
        Example 1: countConstruct(abcdef, [ab, abc, cd, def, abcd])   -> Answer: 1
        //   
        //                               abcdef
        //              |-------------------|-------------------|
        //           -ab|               -abc|              -abcd|
        //              |                   |                   |
        //            cdef                 def                 ef
        //              |                   |               
        //           -cd|               -def|                                 
        //              |                   |              
        //             ef                  ''                    
        //               
        //NOTE: 
            'ef' becomes the basecase
            If reach 'ef', return 0
            If reach empty string, return 1
            When returning to parent tree, if there is 1 in the array, add all results and return as result
            
        
        Example 2: countConstruct(purple, [purp, p, ur, le, purpl]) -> Answer: 2
        //   
        //                           purple
        //            |-----------------|------------------|
        //       -purp|               -p|            -purpl|
        //            |                 |                  |
        //           le               urple                e
        //            |                 |               
        //         -le|             -ur |                                 
        //            |                 |              
        //           ' '               ple         
        //                              |
        //                           -p |
        //                              |
        //                             le
        //                              |
        //                          -le |
        //                              |
        //                             ' '        
        //                                                             
        //NOTE: 
            e becomes the basecase
            If reach 'e, return 0
            If reach empty string, return 1
            When returning to parent tree, if there is 1 in the array, add all results and return as result

    CODE: Brute Force Method
        const countConstruct = (target, wordBank) => {
            if (target === '')  return 1;            
            let totalCount = 0;                                                //Set totalCount to 0 before counting for numWaysForRest
            
            for (let word of wordBank) {       
                if (target.indexOf(word) === 0) {                              //If it is 0, then it is a prefix
                    //const suffix = target.slice(word.length);                //taken from canConstruct
                    //if (countConstruct(suffix, wordBank) === true) {         //taken from canConstruct
                    //    return true;                                         //taken from canConstruct
                    //}                                                                         //taken from canConstruct
                    //const countConstruct(target.slice(word.length), wordBank);                //take the suffix and call recursively, countConstruct returns a number
                    const numWaysForRest = countConstruct(target.slice(word.length), wordBank); //countConstruct to add a number to numWaysForRest
                    totalCount += numWaysForRest;                                               //To count number of times a number being added into numWaysForRest
                }
            }
            return totalCount;      //if none of the 'word' is a valid prefix after finishing the 'for loop', return as 0. Otherwise return the new totalCount calculated in 'for loop'
        };
        
        console.log(countConstruct("purple", ["purp", "p", "ur", "le", "purpl"]));                   //2
        console.log(countConstruct("abcdef", ["ab", "abc", "cd", "def", "abcd"]));                   //1
        console.log(countConstruct("skateboard", ["bo", "rd", "ate", "t", "ska", "sk", "boar"]));    //0
        console.log(countConstruct("enterapotentpot", ["a", "p", "ent", "enter", "ot", "o", "t"]));  //4
        console.log(countConstruct("eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef", ["e", "ee", "eee", "eeee", "eeeee", "eeeeee"]));  //Too Slow

    CODE: Memoization Method
        const countConstruct = (target, wordBank, memo={}) => {
            if (target in memo) return memo[target];
            if (target === '')  return 1;            
            let totalCount = 0;                                                //Set totalCount to 0 before counting for numWaysForRest
            
            for (let word of wordBank) {       
                if (target.indexOf(word) === 0) {                              //If it is 0, then it is a prefix
                    //const suffix = target.slice(word.length);                //taken from canConstruct
                    //if (countConstruct(suffix, wordBank) === true) {         //taken from canConstruct
                    //    return true;                                         //taken from canConstruct
                    //}                                                                               //taken from canConstruct
                    //const countConstruct(target.slice(word.length), wordBank);                      //take the suffix and call recursively, countConstruct returns a number
                    const numWaysForRest = countConstruct(target.slice(word.length), wordBank, memo); //countConstruct to add a number to numWaysForRest
                    //memo[target] = totalCount;                                                      //Not needed but still works with this line added
                    totalCount += numWaysForRest;                                                     //To count number of times a number being added into numWaysForRest

                }
            }
            memo[target] = totalCount;
            return totalCount;      //if none of the 'word' is a valid prefix after finishing the 'for loop', return as 0. Otherwise return the new totalCount calculated in 'for loop'
        };

        console.log(countConstruct("purple", ["purp", "p", "ur", "le", "purpl"]));                   //2
        console.log(countConstruct("abcdef", ["ab", "abc", "cd", "def", "abcd"]));                   //1
        console.log(countConstruct("skateboard", ["bo", "rd", "ate", "t", "ska", "sk", "boar"]));    //0
        console.log(countConstruct("enterapotentpot", ["a", "p", "ent", "enter", "ot", "o", "t"]));  //4
        console.log(countConstruct("eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef", ["e", "ee", "eee", "eeee", "eeeee", "eeeeee"]));  //0

    Complexity:
        Similar to canConstruct
        Brute Force
            O((n^m) * m) time
            O(m^2) space
        Memoized
            O(n*(m^2)) time
            O(m^2) space    

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
09. allConstruct
    
    Question: 
        Write a function 'allConstruct(target, wordBank)' that accepts a target string and an array of strings.
        The function should return a 2D array containing all of the ways that the 'target' can be constructed by 
        concatenating elements of the 'wordBank' array.
        Each element of the 2D array should represent one combination that constucts the 'target'.
        You may reuse elements of 'wordBank' as many times as needed.

    Example: 
        allConstruct("purple", ["purp", "p", "ur", "le", "purpl"])
            Answer:
            [
                [purp, le],
                [p, ur, p, le]
            ]

        allConstruct("abcdef", ["ab", "abc", "cd", "def", "abcd", "c"])
            Answer:
            [
                [ab, cd, ef],
                [ab, c, def],
                [abc, def],
                [abcd, ef]
            ]

        allConstruct("hello", ["cat", "dog", "mouse"])
            Answer:
            []

        allConstruct("", ["cat", "dog", "mouse"])
            Answer:
            [[]]            
            
    Visualization Tree: -allConstruct("abcdef", ["ab", "abc", "cd", "def", "abcd", "c"])
        //   
        //                                                abcdef
        //                          |------------------------|---------------------|
        //                       -ab|                    -abc|                -abcd|
        //                          |                        |                     |
        //                         cdef                     def                   ef
        //              |-------------------------|          |                     |
        //           -cd|                       -c|     -def |                 -ef |
        //              |                         |          |                     |
        //             ef                        def        ' '                   ' '
        //              |                         |
        //          -ef |                    -def |
        //              |                         |
        //             ' '                       ' '
        //
        //NOTE:
            The empty string will become the basecase
            Basecases containing empty strings will return an empty array "[[]]"
            The empty array will then return to the immediate parent node. 
                Example: Node "ef" and "def" will contain "[[ef]]" and "[[def]]" respectively. (Absorbing the subtracted strings of the parent nodes)
            The 2 nodes will continue upwards to another parent node
                Example: Parent node "cdef" will now contain [[cd, ef]], [[c, def]]
            Since there are to arrays in the node, the arrays will concatenate to form a single 2D array -> [[cd, ef], [c, def]]
            Same process happens in other subtrees.
                Node def -> [[def]]
                Node ef -> [[ef]]
            The arrays will move again to node "abcdef"
                [[cd, ef], [c, def]],
                [[def]],
                [[ef]]
            They will absorb the subtracted strings to form:
                [[ab, cd, ef], [ab, c, def]],
                [[abc, def]],
                [[abcd, ef]]                
            Now these arrays will be concatenated to form a single 2D array
                [
                    [ab, cd, ef], 
                    [ab, c, def],
                    [abc, def],
                    [abcd, ef]
                ]                































