///////////////////////////////////////////////////////////////////////
Dynamic Programming (Memoization and Tabulation in Javascript)
CTRL+C to stop coderun in VSCode
///////////////////////////////////////////////////////////////////////
CONTENTS

Memoization
01. Fibonacci
02. gridTraveler
03. memoization recipe
04. canSum
05. howSum
06. bestSum
07. canConstruct
08. countConstruct
09. allConstruct

Tabulation
10. Fibonacci
11. gridTraveler
12. tabulation recipe
13. canSum
14. howSum
15. bestSum
16. canConstruct
17. countConstruct
18. allConstruct

**to run program, type in: node *.js
NOTE: 
    For Python: https://github.com/medwatt/Notes/tree/main/Python/Dynamic_Programming
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Big O Analysis
    https://www.youtube.com/watch?v=HfIH3czXc-8

Time Complexity
    Time taken to run the program
    https://www.youtube.com/watch?v=QnRx6V8YQy0
    
Space Complexity
    Memory usage to run a program
    https://www.youtube.com/watch?v=SHIg5UIfBnI
    
Advanced Dynamic Programming
    https://www.youtube.com/watch?v=Tw1k46ywN6E    

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
01. Fibonacci (Memoization)
    
    Question:
        Write a function 'fib(n)' that takes in a number as an argument.
        The function should return the n-th number of the Fibonacci sequence.

    Explanation:
        The 1st and 2nd number of the sequence is 1.
        To generate the next number of the sequence, we sum the previous 2.

    Example:
        n:    : 1, 2, 3, 4, 5, 6, 7,  8,   9, ...
        fib(n): 1, 1, 2, 3, 5, 8, 13, 21, 34, ...  //Note: 5+8=13
        The 7th Fibonacci is 13

    Code:
        const fib = (n) => {                 //take nth number of fib sequence
            if (n <= 2) return 1;            //if number is less or equals to 2, then return as 1
            return fib(n-1) + fib(n-2);      //sum of previous 2 sequence          
        };
        
        console.log(fib(6));                   //Answer: 8
        console.log(fib(7));                   //Answer: 13
        console.log(fib(8));                   //Answer: 21
        console.log(fib(50));                  //Answer: Takes too long to compute
    
    Problem Explanation: Example calling fib(7)
        (n-2) will be on the right side: (7-2)=5
        (n-1) will be on the left: (7-1)=6
        This will continue until it gets to 2 or 1 (Base case)
        The tree below will take shape
        //                                                                          7
        //                                               |-----------------------------------------------------------|
        //                                              6                                                            5
        //                              |-----------------------------|                                   |-----------------------|
        //                              5                             4                                   4                       3
        //                       |-------------|              |-----------------|               |-------------------|      |--------------|
        //                       4             3              3                 2               3                   2      2              1
        //            |------------|     |-----------|   |-----------|                    |----------------|   
        //            3            2     2           1   2           1                    2                1
        //    |----------|
        //    2          1
        
        Since in base case, returns 2 as 1, the integer 2 at the  bottom most of the tree will return 1
        Add 1+1 = 2
        Therefore the integer fib(3)=2
        This will continue up the tree: 3 will return as 2
        Therefore 2+1=3
        fib(4)=3
        
        See table below for full calculation:
        //                                                                       13
        //                                        |-------------------------------------------------------------------|
        //                                        8                                                                   5
        //                           |-----------------------------|                                     |--------------------------|
        //                           5                             3                                     3                          2
        //                   |-------------|                 |-----------------|               |-------------------|         |--------------|
        //                   3             2                 2                 1               2                   1         1              1
        //            |------------|   |-----------|   |-----------|                    |----------------|   
        //            2            1   1           1   1           1                    1                1
        //    |----------|
        //    1          1
        
        Final fib(7)=13
        
    Underlying Functions: (Foo, Bar, Dib, Lib, Fib)
        Foo Functions: 
            #Tree: 5 > 4 > 3 >2 > 1
            #O(n) time
            #O(n) space            
            
            const foo = (n) => {                     
                if (n <= 1) return;                
                foo(n-1);              
            };
        
        Bar Functions:
            #Tree: 6 > 4 > 2 > 0
            #O(n/2) time = O(n) time
            #O(n/2) space = O(n) space          
        
            const bar = (n) => {                     
                if (n <= 1) return;                
                bar(n-2);              
            };

        Dib Functions:
            #Tree: 
                //                                                        5                                                                  //Level 1, 1 node 
                //                                |---------------------------------------------------------|
                //                                4                                                         4                                //Level 2, 2 nodes
                //                   |-------------------------------|                           |-----------------------|
                //                   3                               3                           3                       3                   //Level 3, 4 nodes
                //            |-------------|               |-----------------|            |------------|          |------------|
                //            2             2               2                 2            2            2          2            2            //Level 4, 8 nodes
                //       |---------|   |----------|   |-----------|      |---------|   |--------|   |--------|  |--------|  |--------|  
                //       1         1   1          1   1           1      1         1   1        1   1        1  1        1  1        1       //Level 5, 16 nodes
                //
                //Height of tree = n = 5 > 4 > 3 > 2 > 1
                //To calculate number of nodes in the level = 2 to power of (5 levels - 1) = 2^(5-1) = 2^4
                //Level 4 = 2^4 = 16 nodes
                
            #O(2^n) time
            #O(n) space       
        
            const dib = (n) => {                     
                if (n <= 1) return;                
                dib(n-1);              
                dib(n-1);     
            };        

        Lib Functions:
            #Tree: 
                //                                                          8                                                                  //Level 1, 1 node 
                //                                |----------------------------------------------------------|
                //                                6                                                          6                                 //Level 2, 2 nodes
                //                    |------------------------------|                             |------------------------|
                //                    4                              4                             4                        4                  //Level 3, 4 nodes
                //             |--------------|              |-----------------|            |--------------|           |-----------|
                //             2              2              2                 2            2              2           2           2           //Level 4, 8 nodes
                //       |---------|     |----------|   |-----------|      |---------|   |--------|     |--------|  |--------|  |--------|  
                //       0         0     0          0   0           0      0         0   0        0     0        0  0        0  0        0     //Level 5, 16 nodes
                //
                //Height of tree = n/2 = n = 8 > 6 > 4 > 2 > 0
                //To calculate number of nodes in the level = 2 to power of [(5 levels - 1)] = 2^(5-1) = 2^4
                //Level 4 = 2^4 = 16 nodes
                
            #O(2^n) time
            #O(n) space           
            
            const lib = (n) => {                     
                if (n <= 1) return;                
                lib(n-2);              
                lib(n-2);     
            };     
        
        Fib Functions: (Combination of Dib and Lib)            
            #Time
                O(dib) =< O(fib) =< O(lib)
                O(2^n) =< O(2^n) =< O(2^n)
            #O(n) space 
            
            const fib = (n) => { 
                if (n <= 2) return 1;    
                return fib(n-1) + fib(n-2);         
            };

    Solution for Fib Function:
        fib(50) = 2^50 = 1.12e+15  = 1,125,899,906,842,624 //Undesireable result in the calculator therefore will take a long time to process

        Breaking down the Fibonacci Tree:
        //                                                                      7
        //                                        |-----------------------------------------------------------------|
        //                                        6                                                                 5
        //                        |----------------------------------|                                 |--------------------------|
        //                        5                                  4                                 4                          3
        //                |-----------------|               |-----------------|               |-------------------|         |--------------|
        //                4                 3               3                 2               3                   2         2              1
        //         |------------|     |-----------|   |-----------|                   |----------------|   
        //         3            2     2           1   2           1                   2                1
        //    |----------|
        //    2          1        
        //
        //Notice that there are 5 subtrees - fib(3), recursive throughout the tree
        //Also notice that there are 3 subtrees - fib(4), also recursive throughout the tree
        //Also notice that there are 2 subtrees - fib(5), also recursive throughout the tree
        //Therefore, the code must have the ability to calculate the subtrees and store the value to save time
        //Using the stored values to solve the recurring subtrees in order to save time is called Dynamic Programming

    Solution Code:
        //memoization
        //    js object, keys will be arg to fn, value will be the return value
        //    > obj = {name: 'Bob', faveColor: 'grey'}
        //    > "name" in obj                             //Returns 'True
        
    
        const fib = (n, memo = {}) => {                              //assign a memory "memo" to be an empty object, to store a key "n"
            if (n in memo) return memo [n];                          //check for existence of key inside of memo, if yes, return memo value. 
            if (n <= 2) return 1;                
            //memo [n] = fib(n-1) + fib(n-2);                        //store entire value in key     
            memo [n] = fib(n-1, memo) + fib(n-2, memo);              //store subtree value in memo
            return memo[n];
        };
        
        console.log(fib(6));                   //Answer: 8
        console.log(fib(7));                   //Answer: 13
        console.log(fib(8));                   //Answer: 21
        console.log(fib(50));                  //Answer: 12586269025
        
        Note: 
            The memo value will store a list of calculated subtree and the result will be recalled whenever the program come across a similar subtree.
            This method cuts down recurring calculation across the entire tree, therefore saving time.
            Example: fib(6)
            Memo {
                3:2,
                4:3,
                5:5,
                6:8
            }        
        
            The tree will be trimmed down leaving the tree as only a linear backbone
            
            New Tree: fib(7)
            //                                      7
            //                                |----------|
            //                                6          5           
            //                         |----------|
            //                         5          4         
            //                  |----------|
            //                  4          3        
            //           |----------|
            //           3          2
            //    |----------|
            //    2          1           
        
        
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////      
02. gridTraveler  
    Question:
        Let's say you're a traveler on a 2D grid.
        You begin in the top-left corner and your goal is to travel to the bottom right corner.
        You can only move down or right.
        In how many ways can you travel to the goal on a grid with dimensions m*n?
        Write a function 'gridTraveler(m, n)' that calculates this.
        
    Explanation:
        gridTraveler(2, 3) 
            -> 2 rows 3 col grid
            Answer: 3 ways to travel
                -> right, right, down
                -> right, down, right
                -> down, right, right
            
        gridTraveler(1, 1)
            -> 1 row 1 col, a box
            Answer: 1 way, "do nothing"

        gridTraveler(1, 0) OR gridTraveler(0, 1)
            -> "No grid"
            Answer: 0 way to travel

    Movement:
        Let's start with gridTraveler(3, 3) - 4 movements
        Moving downwards means removing the entire previous row, therefore, grid becomes gridTraveler(2, 3)
        Moving right means removing the entire previous column, therefore, grid becomes gridTraveler(2, 2)
        Moving downwards means removing the entire previous row, therefore, grid becomes gridTraveler(1, 2)
        Moving right means removing the entire previous column, therefore, grid becomes gridTraveler(1, 1)

    Forming a Tree:
        gridTraveler(2, 3) -> 3 movement
        
        //         |------|------|------|
        //         |      |      |      |
        //         |------|------|------|
        //         |      |      |      |
        //         |------|------|------|        
        
        //                                             (2,3)
        //                      |-----------------------------------------------------|
        //                  Down(1, 3)                                           Right(2, 2)
        //          |-------------------------|                          |-------------------------|
        //        NIL(0, 3)              Right(1, 2)                Down(1, 2)               Right(2, 1)
        //                            |--------------|         |--------------|           |-------------| 
        //                         NIL(0,2)     Right(1,1)    NIL(0,2)    Right(1,1)    Down(1,1)   NIL(0,0)
        //
        
   Using BaseCase calculation:
        Anything with 1,1: Returns 1
        Anything with 0: Return 0
        Add all the numbers and you will get 3 for gridTraveler(2, 3)

    CODE:
        const gridTraveler = (m, n) => {
            if (m === 1 && n === 1) return 1;                            //When grid is at (1, 1), then return as 1
            if (m === 0 || n === 0) return 0;                            //When grid is at (0, 1) OR (1, 0), then return 0
            return gridTraveler(m - 1, n) + gridTraveler(m, n - 1);      //Move down and move right
        };
        
        console.log(gridTraveler(1, 1));  //1
        console.log(gridTraveler(2, 3));  //3
        console.log(gridTraveler(3, 2));  //3
        console.log(gridTraveler(3, 3));  //6
        console.log(gridTraveler(18, 18));  //Too Slow
        
        
    Problem Explanation:
        gridTraveler(2, 3)
        //                                             (2,3)
        //                      |-----------------------------------------------------|
        //                  Down(1, 3)                                           Right(2, 2)
        //          |-------------------------|                          |-------------------------|
        //        NIL(0, 3)              Right(1, 2)                Down(1, 2)               Right(2, 1)
        //                            |--------------|         |--------------|           |-------------| 
        //                         NIL(0,2)     Right(1,1)    NIL(0,2)    Right(1,1)    Down(1,1)   NIL(0,0)
        //    

        The height of the tree is (n +m), [step 0, step 1, step 2, ..., step 4]
        #O(2^ (n+m)) time
        #O(n+m) space

    Optimizing the tree:
        Pattern with (1,2)
        Also note that if grid (1,2) is flipped to (2,1), the result will be the same
        Therefore:
            gridTraveler(a,b) = gridTraveler(b,a)
                If (1,2) = 1+0 = 1, 
                Then (2,1) = 0+1 = 1

    SOLUTION CODE:
        const gridTraveler = (m, n, memo={}) => {
            const key = m + ',' + n;                                                 //Separating comas from values by defining coma as another "key", to make program understand what comas stand for
            if (key in memo) return memo[key];                                       //Check for values in key
            if (m === 1 && n === 1) return 1;                                        //When grid is at (1, 1), then return as 1
            if (m === 0 || n === 0) return 0;                                        //When grid is at (0, 1) OR (1, 0), then return 0
            //return gridTraveler(m - 1, n) + gridTraveler(m, n - 1);                //Move down and move right
            memo[key =] gridTraveler(m - 1, n, memo) + gridTraveler(m, n - 1, memo);
            return memo[key];
        };
        
        console.log(gridTraveler(1, 1));  //1
        console.log(gridTraveler(2, 3));  //3
        console.log(gridTraveler(3, 2));  //3
        console.log(gridTraveler(3, 3));  //6
        console.log(gridTraveler(18, 18));  //2333606220
       
        
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
03. Memoization Recipe

    #Make it work
        > Visualize the problem as a tree
        > Implement the tree using recursion (base cases)
        > Test the brute force solution (Know the difference between code that is slow vs code that is wrong)
        
    #Make it efficient
        > Add memo object into the brute force code (adding keys, return values)
        > Add new base cases to return memo values (via flip subtree, subtree patterns)
        > implement return values into the memo to make a list

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
04. canSum
    
    Question:
        Write a function 'canSum(targetSum, numbers)' that takes in a targetSum and an array of numbers as arguments
        The function should return a boolean indicating whether or not it is possible to generate the targetSum using numbers from the array
        You may use an element of the array as many times as needed
        You may assume that all input numbers are non-negative (can't be subtracted)
    
    Explanation:
        canSum(7, [5, 3, 4, 7]) -> true         //The target number is outside square bracket
        7 can be generated by recalling 7 or adding 3 and 4 from the array
     
        canSum(7 [2, 4]) -> false
        The number doesnt exist within the array and cant be calculated to get 7

    Tree: canSum(7, [5, 3, 4, 7]) -> True
        // 
        //                                 7
        //      |-----------------|------------------|------------------|
        //    -5|               -3|                -4|                -7|
        //      |                 |                  |                  |
        //      2                 4                  3                  0
        //                  |------------|     |------------|       
        //                -3|          -4|   -3|           N/A
        //                  |            |     |
        //                  1            0     0
        //        
        NOTE: 
            From the tree, 0 will be used as the base case
            Therefore, if basecase is 0, then return True. 
            If basecase is NOT 0, return False
            For the Parent-Child tree, if either child node is True, then return True

    Tree: canSum(7, [2, 4]) -> False
        // 
        //                         7
        //               |------------------|
        //              2|                -4|
        //               |                  | 
        //               5                  3 
        //        |------------|      |------------|       
        //      -2|          -4|    -2|           N/A
        //        |            |      |
        //        3            1      1
        //      -2|            
        //        | 
        //        1   
        //

    CODE: - Brute Force Method
        const canSum = (targetSum, numbers) => {                     //numbers array added
            if (targetSum === 0) return true;                        //if targetSum is 0, then return True            
            if (targetSum < 0) return false;                         //Preventing more calculations to be done in for loop if it hits negative numbers
            
            for (let num of numbers) {                               //Add recursive function, iterate through the array of numbers using num
                //console.log(num);                                  //Check the array 
                const remainder = targetSum - num;                   //Calculate the targetsum result by subtracting the numbers in array (Note that this may go to negative numbers)
                //canSum(remainder, numbers);                        //store remainder in numbers array.
                if (canSum(remainder, numbers) === true) {           //canSum is a boolean (true/false), if true, then return true
                    return true;
                }
            }         
            
            return false;                                            //Reason after for loop, after attempt all possibilities in for loop, return false
   
        };
  
        console.log(canSum(7, [2, 3]));           //True
        console.log(canSum(7, [5, 3, 4, 7]));     //True
        console.log(canSum(7, [2, 4]));           //False
        console.log(canSum(8, [2, 3, 5]));        //True
        console.log(canSum(300, [7, 14]));        //Takes too long to calculate
        
    Tree structure with more complexity: 
        Example: canSum(8, [2, 3, 5]) -> True
        //   
        //                                                                                     8
        //                                  |--------------------------------------------------|----------------------------------------|
        //                                -2|                                                -3|                                      -5|
        //                                  |                                                  |                                        |
        //                                  6                                                  5                                        3 
        //              |-------------------|------------------|           |-------------------|--------------------|          |-------------------|
        //            -2|                 -3|                -5|         -2|                 -3|                  -5|        -2|                 -3|                    
        //              |                   |                  |           |                   |                    |          |                   | 
        //              4                   3                  1           3                   2                    0          1                   0
        //       |------------|       |------------|                 |------------|            |               
        //     -2|          -3|     -2|            3               -2|          -3|          -2|                       
        //       |            |       |            |                 |            |            |
        //       2            1       1            0                 1            0            0               
        //     -2|            
        //       | 
        //       0   
        //
        m = tragetSum size
        n = length of array
        height of tree (from top to basecase)
            Because you have to subtract the target sum from the array for 'm' times, so the height will be 'm'
            Therefore, the number of levels is 'm'
        branching factor = number of array length = 3 = n
            If there are 3 numbers in the array, a node would have 3 children
        Complexity
            Time:
                To find the number of nodes, n multiply by n for m times
                Therefore: O(n^m) time                
            Space:
                Just the height of the tree
                O(m) space

    Optimizing: canSum(8, [2, 3, 5])
        Notice that the subtree node 3 with basecases of 1 and 0 is a pattern (3 subtrees)
            The 3 subtrees is the answer for canSum(3, [2, 3, 5])

    CODE: - Memoize Method
        const canSum = (targetSum, numbers, memo={}) => {            //add in memo object
            if (targetSum in memo) return memo[targetSum];           //use targetSum as key for memo
            if (targetSum === 0) return true;      
            if (targetSum < 0) return false;
            
            for (let num of numbers) {      
                const remainder = targetSum - num;         
                if (canSum(remainder, numbers, memo) === true) {      //add in recursive call
                    memo[targetSum] = true;                           //this adds the return value into the memo
                    return true;                                      //this return value will be added into the memo
                }
            }         
            memo[targetSum] = false;                                  //this adds the return value into the memo
            return false;                                             //this return value will be added into the memo
   
        };
  
        console.log(canSum(7, [2, 3]));           //True
        console.log(canSum(7, [5, 3, 4, 7]));     //True
        console.log(canSum(7, [2, 4]));           //False
        console.log(canSum(8, [2, 3, 5]));        //True
        console.log(canSum(300, [7, 14]));        //False

    Explanation:
        Tree:
            m = tragetSum size
            n = length of array
        Brute Force:
            O(n^m) time
            O(m) space
        Memoized:
            O(n*m) time -> Because the program does not need to branch out but instead just recall values directly from the memo
            O(m) space            

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
05. howSum

    Question:
        Write a function 'howSum(targetSum, numbers)' that takes in a targetSum and an array of numbers as arguments.
        The function should return an array containing any combination of elements that add up to exactly the targetSum.
        If there is no combination that adds up to the targetSum, then return null.
        If there are multiple combinations possible, you may return any single one.
        
    Example: 
        howSum(7, [5, 3, 4, 7]) -> Answer: [3, 4] OR [4, 3] OR [7]
        howSum(8, [2, 3, 5]) -> Answer: [3, 5] OR [2, 2, 2, 2]
        howSum(7, [2, 4]) -> Answer: null
        howSum(0, [1, 2, 3]) -> Answer: [] //Takes no element if it's an empty array, even when it does, summing up an empty array will still be 0

    Structure: howSum(7, [5, 3, 4, 7])
        Tree:
        // 
        //                                7
        //      |-----------------|------------------|------------------|
        //    -5|               -3|                -4|                -7|
        //      |                 |                  |                  |
        //      2                 4                  3                  0
        //                  |------------|           |     
        //                -3|          -4|         -3| 
        //                  |            |           |
        //                  1            0           0
        //        
        NOTE:
            Basecase: 0
                Basecases with 0 are already solved because the combination will be empty array
                Therefore, whenever the basecase is 0, return an empty array
                When it goes to the parent node, it needs a parent label, therefore, taking the last subtracted number, -> [4]
                This empty array will again push up to another parent and take in another subtracted number, -> [4, 3]
                Now with that array, node 7 contains [4, 3]
                Therefore, howSum(7, [5, 3, 4, 7]) -> [4, 3]
            Basecase: 2
                For basecase of 2, empty array returns 'null'
            Basecase: 1
                Take note that the other node 4 contains [4] from another child
                From child node 1, [null] is being generated
                Therefore, at node 4, comparator needs to be introduced: Array will always overwrite the null
                Comparison will be repeated until the the top of the tree

    CODE: - Brute Force Method, similar to canSum
        const howSum = (targetSum, numbers) => {    
            if (targetSum === 0) return [];                                //returns an empty array
            if (targetSum < 0) return null;                                //return null if targetsum is below 0 (negative numbers)
            
            for (let num of numbers) {                                
                const remainder = targetSum - num;             
                //howSum(remainder, numbers)
                const remainderResult = howSum(remainder, numbers);       //type howSum returns (array or null element) and store in remainderResult variable
                if (remainderResult !== null) {                           //check remainderResult variable and if not element(null), return the value stored in remainderResult
                    return [...remainderResult, num];                     // [...remainderResult] means copying array into another array (restoperator/spreadoperator)
                }
            }         
            
            return null;                         
   
        };
  
        console.log(howSum(7, [2, 3]));           //[3, 2, 2]
        console.log(howSum(7, [5, 3, 4, 7]));     //[4, 3]
        console.log(howSum(7, [2, 4]));          //null
        console.log(howSum(8, [2, 3, 5]));       //[2, 2, 2, 2]
        console.log(howSum(300, [7, 14]));       //Takes too long to compute

    Explanation: [...remainderResult]
        arr = ['a', 'b', 'c']
        newArr = [...arr]                       //arr will copy to newArr
        otherArray = [...arr, 'z']              //otherArray will be ['a', 'b', 'c', 'z']
        
    Explanation: -Similar to canSum
        m = tragetSum size
        n = length of array
        height of tree (from top to basecase)
            Because you have to subtract the target sum from the array for 'm' times, so the height will be 'm'
            Therefore, the number of levels is 'm'
        branching factor = number of array length = 3 = n
            If there are 3 numbers in the array, a node would have 3 children
        Complexity
            Time:
                To find the number of nodes, n multiply by n for m times
                Therefore: O(n^m) time           
                However, the restoperator adds in 'm' steps by copying an array
                Therefore: O(n^m * m) time 
            Space:
                Just the height of the tree
                O(m) space


    CODE: - Memoization Method, similar to canSum
        const howSum = (targetSum, numbers, memo={}) => {                   //add in memo object
            if (targetSum in memo) return memo;                             //use targetSum as key for memo
            if (targetSum === 0) return [];                 
            if (targetSum < 0) return null;     
            
            for (let num of numbers) {                                
                const remainder = targetSum - num;             
                const remainderResult = howSum(remainder, numbers, memo);   //add memo object to all recursive call
                if (remainderResult !== null) {                           
                    //return [...remainderResult, num];                     //return value to be stored in memo
                    memo[targetSum] = [...remainderResult, num];  
                    return memo[targetSum];
                }
            }         
            
            //return null;                         //return value has to be stored in memo
            memo[targetSum] = null;
            return null;
   
        };
  
        console.log(howSum(7, [2, 3]));           //[3, 2, 2]
        console.log(howSum(7, [5, 3, 4, 7]));     //[4, 3]
        console.log(howSum(7, [2, 4]));           //null
        console.log(howSum(8, [2, 3, 5]));        //[2, 2, 2, 2]
        console.log(howSum(300, [7, 14]));        //null



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
06. bestSum
    Question:
        Write a function 'bestSum(targetSum, numbers)' that takes in a targetSum and an array of numbers as arguments.
        The function should return an array containing the shortest combination of numbers that add up to exactly the targetSum.
        If there is a tie for the shortest combination, you may return any one of the shortest.
        
    Example: 
        bestSum(7, [5, 3, 4, 7]) 
            Solution: [3, 4] OR [7]
            But may need to choose the solution with the smallest arrays
            Therefore: [7]
        bestSum(8, [2, 3, 5]) 
            Solution: [2, 2, 2, 2] OR [2, 3, 3] OR [3, 5]
            But may need to choose the solution with the smallest arrays
            Therefore: [3, 5]

    Structure: bestSum(8, [2, 3, 5])
        Example: canSum(8, [2, 3, 5]) -> True
        //   
        //                                                                             8
        //                                  |------------------------------------------|-----------------------------------|
        //                                -2|                                        -3|                                 -5|
        //                                  |                                          |                                   |
        //                                  6                                          5                                   3 
        //              |----------------|---------------|             |---------------|--------------|          |-------------------|
        //            -2|              -3|             -5|           -2|             -3|            -5|        -2|                 -3|                    
        //              |                |               |             |               |              |          |                   | 
        //              4                3               1             3               2              0          1                   0
        //       |------------|    |------------|                |------------|        |                  
        //     -2|          -3|  -2|            3              -2|          -3|      -2|                       
        //       |            |    |            |                |            |        |
        //       2            1    1            0                1            0        0               
        //     -2|            
        //       | 
        //       0   
        //
        Finding the best subtree
            Here, subtree with node 6 will be used
            Result to get to basecase will be [2, 2, 2] and the other basecase will be [3, 3]
            With the 2 options, the shortest path will be [3, 3]
            Therefore, the answer to the question for the shortest path for node 6 will be [3, 3]
            
        Adding to parent node 8
            With the above subtree, the array will go to the parent node 8
            Therefore, [3, 3] will become [3, 3, 2] at node 8

        Repeat on another subtree (node 5) and (node 3)
            The shortest path for node 5 will be [5]
            At node 8, path will be [5, 3]
            For node 3, path at parent node 8 will be [3, 5]

        Parent node 8
            Now node 8 has 3 paths, [3, 3, 3] , [5, 3] and [3, 5]
            The program will then choose the first answer - [5, 3]
            Note that [3, 5] comes after [5, 3]
            Therefore, the answer for bestSum(8, [2, 3, 5]) will be [5, 3]

    CODE: Brute Force Method - Similar to howSum
        const bestSum = (targetSum, numbers) => {
            if (targetSum === 0) return [];
            if (targetSum < 0) return null;
            
            let shortestCombination = null;                                        //combination default set as null, this adds m to space complexity
            
            for (let num of numbers) {                                             // 'of' - get element, 'in' - get index
                const remainder = targetSum - num;                                                
                const remainderCombination = bestSum(remainder, numbers);
                if (remainderCombination !== null) {
                    //[...remainderCombination, num]                               //a combination for targetSum
                    const combination = [...remainderCombination, num];
                    //if the combination is shorter than the current shortest, then update
                    if (shortestCombination === null || combination.length < shortestCombination.length) {
                        shortestCombination = combination;                        //assign shortestCombination with combination which is shorter 
                    }
                }
            }
            return shortestCombination;
        };
        
        console.log(bestSum(7, [5, 3, 4, 7]));          //[7]
        console.log(bestSum(8, [2, 3, 5]));             //[3, 5]
        console.log(bestSum(8, [1, 4, 5]));             //[4, 4]
        console.log(bestSum(100, [1, 2, 5, 25]));       //Too slow 
         

    CODE: Memoization Method - Similar to howSum
        const bestSum = (targetSum, numbers, memo = {}) => {
            if (targetSum in memo) return memo[targetSum];
            if (targetSum === 0) return [];
            if (targetSum < 0) return null;
            
            let shortestCombination = null;  
            
            for (let num of numbers) {                                                                       
                const remainder = targetSum - num;                                                
                const remainderCombination = bestSum(remainder, numbers, memo);
                if (remainderCombination !== null) {
                    //[...remainderCombination, num]                                    
                    const combination = [...remainderCombination, num];
                    //if the combination is shorter than the current shortest, then update
                    if (shortestCombination === null || combination.length < shortestCombination.length) {
                        shortestCombination = combination;                    
                    }
                }
            }
            //return shortestCombination;               //to be stored in memo
            memo[targetSum] = shortestCombination;
            return shortestCombination;
        };
        
        console.log(bestSum(7, [5, 3, 4, 7]));          //[7]
        console.log(bestSum(8, [2, 3, 5]));             //[3, 5]
        console.log(bestSum(8, [1, 4, 5]));             //[4, 4]
        console.log(bestSum(100, [1, 2, 5, 25]));       //[25, 25, 25, 25]
        
        NOTE: The Time complexity and Space complexity are the same as howSum
        Brute Force:
            time: O(n^m * m)
            space: O(m^2)
            
        Memoization:
            time: O(m^2 * n)
            space: O(m^2)


SUMMARY
NOTE: In a nutshell
    canSum -> Can you do it "Yes/No"?          - Boolean
    howSum -> How will you do it?              - Arrays
    bestSum -> What is the best way to do it - Combination, Optimization
    
    

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
07. canConstruct
    Question:
        Write a function 'canConstruct(target, wordBank)' that accepts a target string and an array of strings.
        The function should return a boolean indicating whether ot not the 'target' can be constructed by concatenating
        elements of the 'wordBank array.
        You may reuse elements of 'wordBank' as many times as needed
        
    Example:
        canConstruct(abcdef, [ab, abc, cd, def, abcd]) -> Answer: True
            Constructing 'abcdef' using elements of the array -> abc + def

        canConstruct(skateboard, [bo, rd, ate, t, ska, sk, boar]) -> Answer: False
        
        canConstruct('', [cat, dog, mouse]) -> True
            Empty strings can take in any elements from the array

    Visualization:
        canConstruct(abcdef, [ab, abc, cd, def, abcd])
        NOTE: Can't take out anything from the middle of the string ("cd" and "def" cannot be used), only prefixes can be used
        //   
        //                                              abcdef
        //                |--------------------------------|-----------------------------|
        //             -ab|                            -abc|                        -abcd|
        //                |                                |                             |
        //              cdef                              def                            ef
        //                |                                |               
        //             -cd|                            -def|                                 
        //                |                                |              
        //               ef                               ''                    
        //                                                             
        //NOTE: 
            'ef' becomes the basecase
            If reach 'ef', return False
            If reach empty string, return True

        canConstruct(skateboard, [bo, rd, ate, t, ska, sk, boar] 
        //
        //                              skateboard
        //                |--------------------------------|
        //            -ska|                             -sk|  
        //                |                                | 
        //             teboard                          ateboard  
        //                |                                |               
        //              -t|                            -ate|                                 
        //                |                                |              
        //             eboard                            board                   
        //                                                 |
        //                                        |------------------|        
        //                                    -bo |            -boar |
        //                                        |                  |       
        //                                       ard                 d
        //NOTE: 
            All basecases returns False
 


    CODE: Brute Force Method
        const canConstruct = (target, wordBank) => {
            if (target === '') {           //check if target is an empty string
                return true;               //if empty string, return true. So this stops taking string from wordBank
            }
            
            for (let word of wordBank) {             //iterating through all the elements (words) in the array (wordBank)
                if (target.indexOf(word) === 0) {  //Check if substring (word) is a prefix of target string, if it is 0, run code
                    const suffix = target.slice(word.length);
                    if (canConstruct(suffix, wordBank) === true) {
                        return true;
                    }
                }
            }
            return false;
        };
        
        console.log(canConstruct("abcdef", ["ab", "abc", "cd", "def", "abcd"]));                      //true
        console.log(canConstruct(skateboard, ["bo", "rd", "ate", "t", "ska", "sk", "boar"]));     //false
        console.log(canConstruct(enterapotentpot, ["a", "p", "ent", "enter", "ot", "o", "t"]));  //true
        console.log(canConstruct(eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef, ["e", "ee", "eee", "eeee", "eeeee", "eeeeee"]));  //True Slow
        
    Example01: target.indexOf(word) === 0;
        "potato".indexOf('pot')    //Answer: Index 0
        "potato".indexOf('tato')    //Answer: Index 2

    Example02: const suffix = target.slice(word.length);
        word = 'pot';
        target = 'potato';
        target.slice(word.length);  //Answer: 'ato'

    Structure:
        m = target.length -> Height
        n = wordBank.length -> Width -> 1 * n (n multiplies by itself as it descends every level) -> O(n^m) time
            Therefore: target.slice(word.length) = O((n^m)*m) time, 
            Multiplied by 'm' since target will be called repetitively to be sliced
            But the one that affects the time is the ^m
        Time: O((n^m)*m)
        Space:
            const suffix = target.slice(word.length);    //each slice will return a new string and then be stored in suffix. 
            if (canConstruct(suffix, wordBank)) { ... }  //Every new string is length 'm'
            Therefore: O(m) -> O(m*m) -> O(m^2)

        Time: O((n^m)*m) -> Exponential in time
        Space: O(m^2) -> Quadratic in space     

    Explanation:
        canConstruct(enterapotentpot, ["a", "p", "ent", "enter", "ot", "o", "t"])
        //
        //                         enterapotentpot
        //                |-----------------------------------------|
        //            -ent|                                  -enter |  
        //                |                                         | 
        //          erapotentpot                               apotentpot
        //                                                          |               
        //                                                        -a|                                 
        //                                                          |              
        //                                                     potentpot                  
        //                                                          |
        //                                                          |               
        //                                                        -p|                                 
        //                                                          |              
        //                                                       otentpot                 
        //                                                          |
        //                                     |--------------------------------|        
        //                                  -o |                            -ot |
        //                                     |                                |       
        //                                  tentpot                           entpot    
        //                                     |                                |    
        //                                  -t |                           -ent |
        //                                     |                                |       
        //                                  entpot                             pot        
        //                                     |                                |    
        //                                -ent |                             -p |
        //                                     |                                |       
        //                                    pot                               ot        
        //                                     |                     |------------------------| 
        //                                  -p |                   -o|                     -ot|
        //                                     |                     |                        |
        //                                    ot                     t                       ' ' 
        //                     |------------------------|            |
        //                   -o|                     -ot|         -t |
        //                     |                        |            |
        //                     t                       ' '          ' '
        //                     |                     
        //                   -t| 
        //                     |  
        //                    ' '
        //Pattern Subtree: 
            "entpot", to be stored in memo
            canConstruct('entpot')
        
    CODE: Memoization Method
        const canConstruct = (target, wordBank, memo={}) => {           //Create memo object
            if (target in memo) return memo[target];                               //Using target as the key
            if (target === '') return true;    
            
            for (let word of wordBank) {            
                if (target.indexOf(word) === 0) {  
                    const suffix = target.slice(word.length);
                    if (canConstruct(suffix, wordBank, memo) === true) {
                        //return true;                                                                //store in memo before completing the return
                        memo[target] = true
                        return true;
                    }
                }
            }
            //return false;                                                                          //store in memo before completing the return
            memo[target] = false;
            return false;
        };
        
        console.log(canConstruct("abcdef", ["ab", "abc", "cd", "def", "abcd"]));                      //true
        console.log(canConstruct(skateboard, ["bo", "rd", "ate", "t", "ska", "sk", "boar"]));     //false
        console.log(canConstruct(enterapotentpot, ["a", "p", "ent", "enter", "ot", "o", "t"]));  //true
        console.log(canConstruct(eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef, ["e", "ee", "eee", "eeee", "eeeee", "eeeeee"]));  //false     

    Brute Force
        O((n^m) * m) time
        O(m^2) space
    Memoized
        O(n*(m^2)) time
        O(m^2) space


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
08. countConstruct
    
    Question:
        Write a function 'countConstruct(target, wordBank)' that accepts a target string and an array of strings.
        The function should return the number of ways that the 'target' can be constructed by concatenating elements of the 'wordBank' array
        You may reuse elements of 'wordBank' as many times as needed.

    Example:
        countConstruct(abcdef, [ab, abc, cd, def, abcd]) -> Answer: 1
        countConstruct(purple, [purp, p, ur, le, purpl]) -> Answer: 2

    Visualization:
        Example 1: countConstruct(abcdef, [ab, abc, cd, def, abcd])   -> Answer: 1
        //   
        //                               abcdef
        //              |-------------------|-------------------|
        //           -ab|               -abc|              -abcd|
        //              |                   |                   |
        //            cdef                 def                 ef
        //              |                   |               
        //           -cd|               -def|                                 
        //              |                   |              
        //             ef                  ''                    
        //               
        //NOTE: 
            'ef' becomes the basecase
            If reach 'ef', return 0
            If reach empty string, return 1
            When returning to parent tree, if there is 1 in the array, add all results and return as result
            
        
        Example 2: countConstruct(purple, [purp, p, ur, le, purpl]) -> Answer: 2
        //   
        //                           purple
        //            |-----------------|------------------|
        //       -purp|               -p|            -purpl|
        //            |                 |                  |
        //           le               urple                e
        //            |                 |               
        //         -le|             -ur |                                 
        //            |                 |              
        //           ' '               ple         
        //                              |
        //                           -p |
        //                              |
        //                             le
        //                              |
        //                          -le |
        //                              |
        //                             ' '        
        //                                                             
        //NOTE: 
            e becomes the basecase
            If reach 'e, return 0
            If reach empty string, return 1
            When returning to parent tree, if there is 1 in the array, add all results and return as result

    CODE: Brute Force Method
        const countConstruct = (target, wordBank) => {
            if (target === '')  return 1;            
            let totalCount = 0;                                                //Set totalCount to 0 before counting for numWaysForRest
            
            for (let word of wordBank) {       
                if (target.indexOf(word) === 0) {                              //If it is 0, then it is a prefix
                    //const suffix = target.slice(word.length);                //taken from canConstruct
                    //if (countConstruct(suffix, wordBank) === true) {         //taken from canConstruct
                    //    return true;                                         //taken from canConstruct
                    //}                                                                         //taken from canConstruct
                    //const countConstruct(target.slice(word.length), wordBank);                //take the suffix and call recursively, countConstruct returns a number
                    const numWaysForRest = countConstruct(target.slice(word.length), wordBank); //countConstruct to add a number to numWaysForRest
                    totalCount += numWaysForRest;                                               //To count number of times a number being added into numWaysForRest
                }
            }
            return totalCount;      //if none of the 'word' is a valid prefix after finishing the 'for loop', return as 0. Otherwise return the new totalCount calculated in 'for loop'
        };
        
        console.log(countConstruct("purple", ["purp", "p", "ur", "le", "purpl"]));                   //2
        console.log(countConstruct("abcdef", ["ab", "abc", "cd", "def", "abcd"]));                   //1
        console.log(countConstruct("skateboard", ["bo", "rd", "ate", "t", "ska", "sk", "boar"]));    //0
        console.log(countConstruct("enterapotentpot", ["a", "p", "ent", "enter", "ot", "o", "t"]));  //4
        console.log(countConstruct("eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef", ["e", "ee", "eee", "eeee", "eeeee", "eeeeee"]));  //Too Slow

    CODE: Memoization Method
        const countConstruct = (target, wordBank, memo={}) => {
            if (target in memo) return memo[target];
            if (target === '')  return 1;            
            let totalCount = 0;                                                //Set totalCount to 0 before counting for numWaysForRest
            
            for (let word of wordBank) {       
                if (target.indexOf(word) === 0) {                              //If it is 0, then it is a prefix
                    //const suffix = target.slice(word.length);                //taken from canConstruct
                    //if (countConstruct(suffix, wordBank) === true) {         //taken from canConstruct
                    //    return true;                                         //taken from canConstruct
                    //}                                                                               //taken from canConstruct
                    //const countConstruct(target.slice(word.length), wordBank);                      //take the suffix and call recursively, countConstruct returns a number
                    const numWaysForRest = countConstruct(target.slice(word.length), wordBank, memo); //countConstruct to add a number to numWaysForRest
                    //memo[target] = totalCount;                                                      //Not needed but still works with this line added
                    totalCount += numWaysForRest;                                                     //To count number of times a number being added into numWaysForRest

                }
            }
            memo[target] = totalCount;
            return totalCount;      //if none of the 'word' is a valid prefix after finishing the 'for loop', return as 0. Otherwise return the new totalCount calculated in 'for loop'
        };

        console.log(countConstruct("purple", ["purp", "p", "ur", "le", "purpl"]));                   //2
        console.log(countConstruct("abcdef", ["ab", "abc", "cd", "def", "abcd"]));                   //1
        console.log(countConstruct("skateboard", ["bo", "rd", "ate", "t", "ska", "sk", "boar"]));    //0
        console.log(countConstruct("enterapotentpot", ["a", "p", "ent", "enter", "ot", "o", "t"]));  //4
        console.log(countConstruct("eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef", ["e", "ee", "eee", "eeee", "eeeee", "eeeeee"]));  //0

    Complexity:
        Similar to canConstruct
        Brute Force
            O((n^m) * m) time
            O(m^2) space
        Memoized
            O(n*(m^2)) time
            O(m^2) space    

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
09. allConstruct
    
    Question: 
        Write a function 'allConstruct(target, wordBank)' that accepts a target string and an array of strings.
        The function should return a 2D array containing all of the ways that the 'target' can be constructed by 
        concatenating elements of the 'wordBank' array.
        Each element of the 2D array should represent one combination that constucts the 'target'.
        You may reuse elements of 'wordBank' as many times as needed.

    Example: 
        allConstruct("purple", ["purp", "p", "ur", "le", "purpl"])
            Answer:
            [
                [purp, le],
                [p, ur, p, le]
            ]

        allConstruct("abcdef", ["ab", "abc", "cd", "def", "abcd", "c"])
            Answer:
            [
                [ab, cd, ef],
                [ab, c, def],
                [abc, def],
                [abcd, ef]
            ]

        allConstruct("hello", ["cat", "dog", "mouse"])
            Answer:
            []

        allConstruct("", ["cat", "dog", "mouse"])
            Answer:
            [[]]            
            
    Visualization Tree: -allConstruct("abcdef", ["ab", "abc", "cd", "def", "abcd", "c"])
        //   
        //                                                abcdef
        //                          |------------------------|---------------------|
        //                       -ab|                    -abc|                -abcd|
        //                          |                        |                     |
        //                         cdef                     def                   ef
        //              |-------------------------|          |                     |
        //           -cd|                       -c|     -def |                 -ef |
        //              |                         |          |                     |
        //             ef                        def        ' '                   ' '
        //              |                         |
        //          -ef |                    -def |
        //              |                         |
        //             ' '                       ' '
        //
        //NOTE:
            The empty string will become the basecase
            Basecases containing empty strings will return an empty array "[[]]"
            The empty array will then return to the immediate parent node. 
                Example: Node "ef" and "def" will contain "[[ef]]" and "[[def]]" respectively. (Absorbing the subtracted strings of the parent nodes)
            The 2 nodes will continue upwards to another parent node
                Example: Parent node "cdef" will now contain [[cd, ef]], [[c, def]]
            Since there are to arrays in the node, the arrays will concatenate to form a single 2D array -> [[cd, ef], [c, def]]
            Same process happens in other subtrees.
                Node def -> [[def]]
                Node ef -> [[ef]]
            The arrays will move again to node "abcdef"
                [[cd, ef], [c, def]],
                [[def]],
                [[ef]]
            They will absorb the subtracted strings to form:
                [[ab, cd, ef], [ab, c, def]],
                [[abc, def]],
                [[abcd, ef]]                
            Now these arrays will be concatenated to form a single 2D array
                [
                    [ab, cd, ef], 
                    [ab, c, def],
                    [abc, def],
                    [abcd, ef]
                ]                

    Visualization Tree 01: -allConstruct("purple", ["purp", "p", "ur", "le", "purpl"])
        //   
        //                           purple
        //            |-----------------|-----------------------|
        //       -purp|               -p|                 -purpl|
        //            |                 |                       |
        //           le               urple                     e
        //            |                 |               
        //         -le|             -ur |                                 
        //            |                 |              
        //           ' '               ple         
        //                              |
        //                           -p |
        //                              |
        //                             le
        //                              |
        //                          -le |
        //                              |
        //                             ' '        
        //                                                           
        //NOTE:
            The empty string will become the basecase
            Basecases containing empty strings will return an empty array "[[]]"
            The empty array will then return to the immediate parent node. 
                Example: Node "le" and "le" will contain "[[le]]" and "[[le]]" respectively. (Absorbing the subtracted strings of the parent nodes)
            The 2 arrays will continue upwards to another parent node until it reaches the main parent node
                Example: Parent node "purple" will now contain [[purp, le]], [[p, ur, p, le]]             
            Now these arrays will be concatenated to form a single 2D array
                [
                    [purp, le],
                    [p, ur, p, le]
                ]                
            For the tree that does not end with empty string, return 1D empty array -> []
                1D -> []
                2D -> [[]]

    CODE: Brute Force Method
        const allConstruct = (target, wordBank) => {
            if (target === '') return [[]];            
            const result = [];                                                 //Create an array to store results
            
            for (let word of wordBank) {
                if (target.indexOf(word) === 0) {                              //check if it is a prefix
                    const suffix = target.slice(word.length);                  //returns the remainder of string and store in suffix
                    //allConstruct(suffix, wordBank);                          //calls the function recursively on the suffix. allConstruct will contain an array containing suffix
                    const suffixWays = allConstruct(suffix, wordBank);         //return value stored in suffixWays
                    const targetWays = suffixWays.map(way => [word, ...way]);  //To find out the ways that make the original "target" string. Adding "word" to "suffixWays"
                    result.push(...targetWays);                                //Pushes results from targetWays into the result array
                }
            }
            return result;
        };
        
        console.log(allConstruct('purple', ['purp', 'p', 'ur', 'le', 'purpl']));                             // [[purp, le], [p, ur, p, le]]
        console.log(allConstruct('abcdef', ['ab', 'abc', 'cd', 'def', 'abcd', 'ef', 'c']));                  // [[ab, cd, ef], [ab, c, def],  [abc, def], [abcd, ef]]   
        console.log(allConstruct('skateboard', ['bo', 'rd', 'ate', 't', 'ska', 'sk', 'boar']));              // []
        console.log(allConstruct('aaaaaaaaaaaaaaaaaaaaaaaaaaaaz', ['a', 'aa', 'aaa', 'aaaa', 'aaaaa']));     // []

    Explanation: string.map()
        Example 01:
            arr = [1, 2, 3, 4];        //Creates the array
            arr.map(el => el * 2);     //multiply every element by 2, Answer: [2, 4, 6, 8]
        Example 02:
            suffixWays = [['xy, 'z'], ['x', 'yz']];  //Creates the array
            suffixWays.map(way => ['a', ...way])     //Answer: [['a', 'xy', 'z'], ['a', 'x', 'yz']]
        Example 03:
            arr = [1, 2, 3, 4];         //Creates the array
            nums = [7, 8];              //Creates another array
            arr.push(nums);             //Adds in entire array into another. -> [1, 2, 3, 4, [7, 8]]
            arr.push(...nums);          //Adds in contents of an array into another to form a single array -> [1, 2, 3, 4, 7, 8]

    CODE: Memoization Method
        const allConstruct = (target, wordBank, memo={} ) => {        //Create memo object
            if (target in memo) return memo[target];                  //Use target as key
            if (target === '') return [[]];            
            const result = [];                              
            
            for (let word of wordBank) {
                if (target.indexOf(word) === 0) {                            
                    const suffix = target.slice(word.length);  
                    //allConstruct(suffix, wordBank);          
                    const suffixWays = allConstruct(suffix, wordBank, memo);      //Add memo to recursive calls 
                    const targetWays = suffixWays.map(way => [word, ...way]);  
                    result.push(...targetWays);         
                }
            }
            memo[target] = result;           //Stores result in memo
            return result;
        };
        
        console.log(allConstruct('purple', ['purp', 'p', 'ur', 'le', 'purpl']));                         // [[purp, le], [p, ur, p, le]]
        console.log(allConstruct('abcdef', ['ab', 'abc', 'cd', 'def', 'abcd', 'ef', 'c']));              // [[ab, cd, ef], [ab, c, def],  [abc, def], [abcd, ef]]   
        console.log(allConstruct('skateboard', ['bo', 'rd', 'ate', 't', 'ska', 'sk', 'boar']));          // []
        console.log(allConstruct('aaaaaaaaaaaaaaaaaaaaaaaaaaaaz', ['a', 'aa', 'aaa', 'aaaa', 'aaaaa'])); // []    NOTE: If there is no 'z' at the end of the target, memoization will never solve the problem as it is infinite in itself.

    Complexity:
        m = target.length
        n = wordBank.length
        O(n^m) time
        O(m) space


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
10. Fibonacci (Tabulation)
    
    Question:
        Write a function 'fib(n)' that takes in a number as an argument.
        The function should return the n-th number of the Fibonacci sequence.
        The 0th number of the sequence is 0.
        The 1st number of the sequence is 1.
        To generate the next number of the sequence, we sum the previous 2.
        
        n:       0, 1, 2, 3, 4, 5, 6,  7,  8,  9, ...
        fib(n):  0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...

    Explanation: 
        fib(6) -> 8
        Instead of doing recursively, this will be done iteratively by building a table
    
        Initialization:
              0   1   2   3   4   5   6
            | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
            Length: 7

        Make fib(1):
              0   1   2   3   4   5   6
            | 0 | 1 | 0 | 0 | 0 | 0 | 0 |        
            First fibonacci number is 1

        Iteration 1:
            Starts with 0th number and compare with the next 2 positions (Position 1 and 2)
            #   0   1   2   3   4   5   6
            # | 0 | 1 | 0 | 0 | 0 | 0 | 0 |  
            #   ^   ^   ^
            #   |  +0  +0
            #   +-- Start here

        Iteration 2:
            Starts with 1st number and compare with the next 2 positions (Position 2 and 3)
            #   0   1   2   3   4   5   6
            # | 0 | 1 | 1 | 1 | 0 | 0 | 0 |  
            #       ^   ^   ^
            #       |  +1  +1
            #       +-- Start here

        Iteration 3:
            Starts with 2nd number and compare with the next 2 positions (Position 3 and 4)
            #   0   1   2   3   4   5   6
            # | 0 | 1 | 1 | 2 | 1 | 0 | 0 |  
            #           ^   ^   ^
            #           |  +1  +1
            #           +-- Start here

        Iteration 4:
            Starts with 3rd number and compare with the next 2 positions (Position 4 and 5)
            #   0   1   2   3   4   5   6
            # | 0 | 1 | 1 | 2 | 3 | 2 | 0 |  
            #               ^   ^   ^
            #               |  +2  +2
            #               +-- Start here

        Iteration 5:
            Starts with 4th number and compare with the next 2 positions (Position 5 and 6)
            #   0   1   2   3   4   5   6
            # | 0 | 1 | 1 | 2 | 3 | 5 | 3 |  
            #                   ^   ^   ^
            #                   |  +3  +3
            #                   +-- Start here

        Iteration 6:
            Starts with 5th number and compare with the next 2 positions (Position 6 and 7)
            #   0   1   2   3   4   5   6
            # | 0 | 1 | 1 | 2 | 3 | 5 | 8 | Out of Bound |
            #                       ^   ^       ^
            #                       |  +5      +5
            #                       +-- Start here

        NOTE:
            So the whole process is just about iterating through the entire array of numbers
            Also note that the index numbers in the array could be used as fib(index)

    Complexity:
        O(n) time
        O(n) space
        
    Turning into a tree:
        #                      |-----|
        #                    |---|   |
        #    0   1   2   3   4   5   6
        #  | 0 | 1 | 1 | 2 | 3 | 5 | 8 |        

        Simplified:
        //
        //       fib(6)
        //   |-----------|
        //   |           |
        // fib(4)      fib(5)


    CODE: 
        const fib = (n) => {
            //const table = Array(n + 1);           //creating an array and naming it "table", with dimension of 'n'. Last index will be 'n'. Indices start at 0 hence +1
            //console.log(table);                   //Only be used for testing the line above. Answer: [<7 empty items>]. Meaning elements are undefined.
            
            //const table = Array(n + 1).fill(0);   //To define an array, fill with numbers by filling up the array with zeros
            //console.log(table);                   //Only be used for testing the line above. Answer: [0, 0, 0, 0, 0, 0, 0]. Meaning elements are defined.
            
            const table = Array(n + 1).fill(0);
            table[1] = 1;                           //Adding 1 to index 1 of the table, as mentioned in the explanation section
            for (let i = 0; i <= n; i++) {          //Iteration loop: starts with 0; includes 'n'; increment through every position
                //table[i + 1];                     //Looks at position 1 from starting point
                //table[i + 2];                     //Looks at position 2 from starting point
                table[i + 1] += table[i];           //increment by the value of the current position
                table[i + 2] += table[i];           //increment by the value of the current position
            }
            return table[n];
        };
        
        console.log(fib(6));  //8
        console.log(fib(7));  //13
        console.log(fib(8));  //21
        console.log(fib(50)); //12586269025

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
11. gridTraveller
    
    Question:
        Say that you are a traveller on a 2D grid. 
        You begin in the top-left corner and your goal is to travel to the bottom-right corner.
        You may only move down or right.        
        In how many ways can you travel to the goal on a grid with dimensions m*n?
        Write a function 'gridTraveler(m, n)' that calculates this.
    
    Example: 
        gridTraveler(3, 3) -> 6
            To match the indices, (4, 4) grid will be drawn and the bottom right will be (3, 3)
            In tabulation, another row and column will be added to coincide with the indices 0 -> 3
            
            // (4, 4) grid
            //
            //         |------|------|------|------|
            //         |      |      |      |      |
            //         |------|------|------|------|
            //         |      |      |      |      |
            //         |------|------|------|------|
            //         |      |      |      |      |
            //         |------|------|------|------|
            //         |      |      |      |      |
            //         |------|------|------|------|
            //
            //
            
            // Zeros will be placed throughout the grid
            //
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //        
            
            // Make gridTraveller(1, 1) to contain 1, That means row 2 and column 2 of the grid will have the value of 1
            //
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //         |   0  |  1   |  0   |  0   |
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //      

            Then iterate through the table and come up with a logic that combines the value of the table 
               Combining sub-problem to solve a larger problem
               
            // Begin at (0,0) of the grid which means at this location, will contain 0
            // Move either to (0, 1) OR (1, 0) and add them with the value from (0, 0). Basically will still be 0.
            //
            //         |------|------|------|------|
            //         |   +  >  0   |  0   |  0   |
            //         |---V--|------|------|------|
            //         |   0  |  1   |  0   |  0   |
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //                      
            
            // Start adding the numbers throughout
            //
            //         |------|------|------|------|
            //         |   0  |  +   >  0   |  0   |
            //         |------|--V---|------|------|
            //         |   0  |  1   |  0   |  0   |
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //  
            // NOTE: Nothing changes for calculating row 0. 
            
            // Start adding the numbers throughout for row 1
            //
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //         |   +  >  1   |  0   |  0   |
            //         |---v--|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //  
            // NOTE: Nothing changes yet since it is 0

            // At this point, the right and down neighbor will become 1
            //
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //         |   0  |  +   >  1   |  0   |
            //         |------|---V--|------|------|
            //         |   0  |  1   |  0   |  0   |
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //  

            // At this point, make sure there is another row that is out of bound for arithematic operation
            //
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //         |   0  |  1   |  1   |  +   >
            //         |------|------|------|--V---|
            //         |   0  |  1   |  1   |  1   |
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //  

            // Then iterate to the next row
            //
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //         |   0  |  1   |  1   |  1   |
            //         |------|------|------|------|
            //         |  +   >   1  |  1   |  1   |
            //         |--V---|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //  
            
            // Then iterate to the next column
            //
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //         |   0  |  1   |  1   |  1   |
            //         |------|------|------|------|
            //         |   0  |  +   >  2   |  1   |
            //         |------|--V---|------|------|
            //         |   0  |  1   |  0   |  0   |
            //         |------|------|------|------|
            //              

            // Then iterate to the next column
            //
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //         |   0  |  1   |  1   |  1   |
            //         |------|------|------|------|
            //         |   0  |  1   |  +   >  3   |
            //         |------|------|--V---|------|
            //         |   0  |  1   |  2   |  0   |
            //         |------|------|------|------|
            //              

            // The end result of the entire grid will have values shown below
            //
            //         |------|------|------|------|
            //         |   0  |  0   |  0   |  0   |
            //         |------|------|------|------|
            //         |   0  |  1   |  1   |  1   |
            //         |------|------|------|------|
            //         |   0  |  1   |  2   |  3   |
            //         |------|------|------|------|
            //         |   0  |  1   |  3   |  6   |
            //         |------|------|------|------|
            //             

    Complexity:
        Since there are m rows and n columns, therefore m*n
            Time: O(mn)
        Space complexity will be the same as Time complexity
            Space: O(mn)

    CODE:
        const gridTraveller = (m , n) => {
            //const table = Array(m + 1)                        //+1 more row because of the indexing number begins at 0
            //const table = Array(m + 1).fill().map()     //To apply the same thing on other subarrays
            
            const table = Array(m + 1)
                .fill()                                                                              //See explanation code on why ".fill(Array(n+1))" is not being used
                //.map(() => Array(n+1));                                              //Make every element a new array, add 1 for number of columns
                .map(() => Array(n+1).fill(0));                                       //Fill entire grid with zeros
            table[1][1] = 1;                                                                 //Set gridTraveller(1,1) value to 1
            //console.log(table);                                                        //Only used for testing
            for (let i = 0; i <= m; i++) {                                                  //To travel through the grid by iteration (Nested loop)
                for (let j = 0; j <= n; j++) {                                               //To travel through the grid by iteration (Inner loop)
                    const current = table[i][j];                                        //Take the current location (i, j) and add to right and bottom neighbors
                    //table[i][j + 1] += current;                                      //Take value of current location and add to the neighbor on the right
                    //table[i + 1][j] += current;                                      //Take value of current location and add to the neighbor below it
                    if (j + 1 <= n) table[i][j + 1] += current;                   //Add out of bound logic: If j value is lower than required value, then increment
                    if (i + 1 <= m) table[i + 1][j] += current;                  //Add out of bound logic: If i value is lower than required value, then increment
                }
            }
            
            return table [m] [n];
        };

        console.log(gridTraveller(1, 1)); //1
        console.log(gridTraveller(2, 3)); //3
        console.log(gridTraveller(3, 2)); //3
        console.log(gridTraveller(3, 3)); //6
        console.log(gridTraveller(18, 18)); //2333606220


    Explanation code: .fill(Array(n+1))
    
        Example 1:        This fills the outer array with single array instance multiple times not allowing to select individual grid as required by the question
            const gridTraveller = (m , n) => {
                const table = Array(m + 1).fill(Array(n+1));
                table [0] [0] = 'x';
                console.log(table);            
            };
            console.log(gridTraveller(3, 2)); //3

        Example 2:
            const gridTraveller = (m , n) => {
                const table = Array(m + 1).fill().map(() => Array(n+1));
                table [0] [0] = 'x';
                console.log(table);            
            };
            console.log(gridTraveller(3, 2)); //3

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
12. Tabulation recipe

    Main Steps
        1. visualize the problem as a table (size and dimensions based on inputs)
        2. Initialize the table with default values (numbers, booleans)
        3. Seed the trivial answer into the table. Example: Use (3, 3) grid before running on (200, 200) grid
        4. Iterate through the table (Loops), fill further positions based on the current position


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
13. canSum

    Question:
        Write a function 'canSum(targetSum, numbers)' that takes in a targetSum and an array of numbers as arguments.
        The function should return a boolean indicating whether or not it is possible to generate the targetSum using numbers from the array.
        You may use an element of the array as many times as needed.
        You may assume that all input numbers are nonnegative.
        
    Example:
        canSum(7, [5, 3, 4]) -> true, 3+4 OR 4+3
        
        Determine the table size by using the target number. 
            length = targetSum + 1        
            Therefore: 7+1=8 (0->7)
            
        Determine what should be stored inside the table    
            Answer is in boolean (true or false)
            Therefore: boolean data should be in the table

        Initialization:
               0   1    2   3    4   5   6    7
            | F | F | F | F | F | F | F | F |

        Seeding:
            Using canSum(0, [...]) -> true
            Since the target is zero, anything in the array will result with True, hence, index 0 will contain the value of "true"
               0   1    2   3    4   5   6    7
            | T | F | F | F | F | F | F | F |
            This will be the base before the iteration

        Iterating through the table from index 0
            Start by looking at index 0 of the table which contains the value of "true"
            And then look at the array with the first value of 5, which means index 5 of the table
            Jumping from index 0 to index 5 will return true since index 5 will absorb the value from index 0
               0   1    2   3    4   5   6    7
            | T | F | F | F | F | T | F | F |

            Repeat process for index 3 and 4
               0   1    2   3    4   5   6    7
            | T | F | F | T | T | T | F | F |

        Iterating through the table from index 1 and 2
            Think of F as 0 and T as 1, Therefore anything with the result of T cant absorb the value F        
            Start by looking at index 1 of the table which contains the value of "false"
               0   1    2   3    4   5   6    7
            | T | F | F | T | T | T | F | F |

        Iterating through the table from index 3
            Jumping 5 steps ahead from index 3 will return "out of bounds", index 8
            Jumping 3 steps ahead from index 3 will return "True", index 6
            Jumping 4 steps ahead from index 3 will return "True", index 7
               0   1    2   3    4    5    6    7           8
            | T | F | F | T | T | T | F | F | Out of Bounds |

            NOTE: Notice that at this point everything past 7 will all be True


    Complexity:
        m = targetSum
        n = numbers.length

        O(mn) time
        O(m) space
        
    CODE: 
        const canSum = (targetSum, numbers) => {
            //const table = Array(targetSum + 1);                    //Creating a table with 8 columns (0 -> 7)
            const table = Array(targetSum + 1).fill(false);          //Initialize with all values as false
            table[0] = true;                                         //Set index 0 to true
            
            //for (let i = 0; i <= table.length; i++) {              //Iterate through every element
            for (let i = 0; i <= targetSum; i++) {                   //Better than table.length. See code problem below
                if (table[i] === true) {                             //Check if the value in table is true
                    for (let num of numbers) {                       //If true, then grab the values (num) from the numbers array
                        //table[i + num];                            //Add current position to num to jump
                        table[i + num] = true;                       //Assign the destination position as true
                    }
                }
            }            
            return table[targetSum];
        };

        

        console.log(canSum(7, [2, 3]));       //T
        console.log(canSum(7, [5, 3, 4, 7])); //T
        console.log(canSum(7, [2, 4]));       //F
        console.log(canSum(8, [2, 3, 5]));    //T
        console.log(canSum(300, [2, 3]));     //F


    CODE Bug;
        const arr = ['a', 'b', 'c'];
        arr[10] = 'x';             //This will actually add 7 more sections to the array and also add 'x' on the 11th
        console.log(arr);          //Answer: ['a', 'b', 'c', <7 empty items>, 'x']



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
14. howSum

    Question:
        Write a function 'howSum(targetSum, numbers)' that takes in a targetSum and an array of numbers as arguments.
        The function should return an array containing any combination of elements that add up to exactly the targetSum.
        If there is no combination that adds up to the targetSum, then return null.
        If there are multiple combinations possible, you may return any single one.
        NOTE: Similar to previous problem but instead of boolean it needs to return an array

    Example:
        howSum(7, [5, 3, 4]) -> [4, 3]
        
        Initialize:
            length = targetSum + 1
               0   1    2    3    4   5    6    7
            | n | n | n | n | n | n | n | n |        
            where 'n' is null

        Seeding
            Using canSum(0, [...]) -> [ ]          //Returns an empty array

              0    1   2   3   4   5   6   7
            | [] | n | n | n | n | n | n | n |       

        Iterating through the table from index 0
            Begin with 5 (first number in the array), 
            Add 5 to the array
               0    1   2   3   4    5    6   7
            | [ ] | n | n | n | n | [5] | n | n | 
            
            Repeat process for index 3 and 4
               0    1   2    3     4     5    6   7
            | [ ] | n | n | [3] | [4] | [5] | n | n | 

        Iterating through the table from index 1 and 2
            Think of null as 0 and [] as 1, Therefore anything with the result of [] cant absorb the value null        
            Start by looking at index 1 of the table which contains the value of null
               0    1   2    3     4     5    6   7
            | [ ] | n | n | [3] | [4] | [5] | n | n | 

        Iterating through the table from index 3
            Jumping 5 steps ahead from index 3 will return "out of bounds", index 8
            Jumping 3 steps ahead from index 3 will return "[3, 3]", index 6
            Jumping 4 steps ahead from index 3 will return "[3, 4]", index 7
               0    1   2    3     4     5       6       7            8
            | [ ] | n | n | [3] | [4] | [5] | [3, 3] | [3, 4] |  Out of Bounds |

            Note: Push forward the current value and then adds in the steps value [Current, steps]

        Iterating through the table from index 4
            Jumping 3 steps ahead from index 4 will overwrite "[3, 4]" with "[4, 3]", index 7

    Complexity:
        m = targetSum
        n = numbers.length

        O(m^2*n) time
        O(m^2) space


    CODE: 
        const howSum = (targetSum, numbers) => {        
            const table = Array(targetSum + 1).fill(null); 
            table[0] = [];                                  
              
            for (let i = 0; i <= targetSum; i++) {                 //m iteration - (m)
                if (table[i] !== null) {                      
                    for (let num of numbers) {                     //n iteration - (m*n)        
                        //table[i + num] = true;                   //from previous example
                        table[i + num] = [ ...table[i], num ];     //copying over logic - (m*n*m)
                    }
                }
            }            
            return table[targetSum];
        };

        console.log(howSum(7, [2, 3]));        //[3, 2, 2]
        console.log(howSum(7, [5, 3, 4, 7]));  //[4, 3]
        console.log(howSum(7, [2, 4]));        //null
        console.log(howSum(8, [2, 3, 5]));     //[2, 2, 2, 2]
        console.log(howSum(300, [7, 14]));     //null


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
15. bestSum

    Question:
        Write a function 'bestSum(targetSum, numbers)' that takes in a targetSum and an array of numbers as arguments.
        The function should return an array containing the shortest combination of numbers that add up to exactly the targetSum.
        If there is a tie for the shortest combination, you may return any one of the shortest.
        
    Example:
        bestSum(8, [2, 3, 5]) -> 
            Possible answers: [2, 2, 2, 2], [2, 3, 3], [3, 5]
            Shortest answer: [3, 5]
        
        Determine size of table:
              0   1   2   3   4   5   6   7   8
            | n | n | n | n | n | n | n | n | n |         
            Where 'n' is null

        Seeding
            Using canSum(0, [...]) -> [ ]          //Returns an empty array

               0   1   2   3   4   5   6   7
            | [] | n | n | n | n | n | n | n |     

        Iterating through the table from index 0
            Begin with 2 (first number in the array), 
            Add 2 to the array
               0    1    2    3   4   5   6   7   8
            | [ ] | n | [2] | n | n | n | n | n | n |  
            
            Repeat process for index 3 and 5
               0    1    2     3    4    5    6   7   8
            | [ ] | n | [2] | [3] | n | [5] | n | n | n |  

        Iterating through the table from index 1
            Think of null as 0 and [] as 1, Therefore anything with the result of [] cant absorb the value null        
            Start by looking at index 1 of the table which contains the value of null
               0    1    2     3    4    5    6   7   8
            | [ ] | n | [2] | [3] | n | [5] | n | n | n |  

        Iterating through the table from index 2
            Jumping 2 steps ahead from index 2 will return "[2, 2]", index 4
            Jumping 3 steps ahead from index 2 will change "[5]" to "[2, 3]", index 5 
                //Note that since [5] is shorter than [2, 3], [5] will stay
            Jumping 5 steps ahead from index 2 will return "[2, 5]", index 7
               0    1    2     3      4       5    6     7      8          9
            | [ ] | n | [2] | [3] | [2, 2] | [5] | n | [2, 5] | n |  Out of Bounds |

            Note: Push forward the current value and then adds in the steps value [Current, steps]

        Iterating through the table from index 3
            Jumping 2 steps ahead from index 3 will change "[2, 3]" to "[3, 2]", index 5
                //Note that since [5] is shorter than [2, 3], [5] will stay            
            Jumping 3 steps ahead from index 3 will return "[3, 3]", index 6
            Jumping 5 steps ahead from index 3 will return "[3, 5]", index 8
               0    1    2     3      4       5      6        7        8            9
            | [ ] | n | [2] | [3] | [2, 2] | [5] | [3, 3] | [2, 5] | [3, 5] |  Out of Bounds |

        Iterating through the table from index 4
            Proceeding from here will return arrays of 3 elements which will be ignored since it is longer than the original
            Therefore, nothing changes

    Complexity:
        m = targetSum
        n = numbers.length

        O(m^2*n) time
        O(m^2) space
        

    CODE:
        const bestSum = (targetSum, numbers) => {
            const table = Array(targetSum + 1).fill(null); 
            table[0] = [];                                  
              
            for (let i = 0; i <= targetSum; i++) {                              //m iteration - (m)
                if (table[i] !== null) {                      
                    for (let num of numbers) {                                  //n iteration - (m*n)        
                        const combination = [ ...table[i], num ];               //Keeping the shortest array
                        //table[i + num] = [ ...table[i], num ];                //copying over logic - (m*n*m) -> Original from canSum
                        //if (table[i + num].length > combination.length) {     //If combination is shorter than stored value
                        if (!table[i + num] || table[i + num].length > combination.length) {       //Added "!table[i+num" due to existence of .length cant read null values
                            table[i + num] = combination;                       //Replace
                        }
                    }
                }
            }            
            return table[targetSum];        
        };

        console.log(bestSum(7, [5, 3, 4, 7]));        //[7]
        console.log(bestSum(8, [2, 3, 5]));           //[3, 5]
        console.log(bestSum(8, [1, 4, 5]));           //[4, 4]
        console.log(bestSum(100, [1, 2, 5, 25]));     //[25, 25, 25, 25]


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
16. canConstruct



























































