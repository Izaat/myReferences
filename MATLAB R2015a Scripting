//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Matlab 2015a
5e-3 = 5*10^-3 = 0.005
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CONTENTS
01. Introduction (Basic syntax, command window, and working directory)
02. Basic matrix arithmetic in Matlab including an overview of different operators
03. Built in functions, constants and write custom functions
04. Linear equations
05. For loops, while loops, and if statements
06. Data types
07. Plotting data with Fibonacci Sequence
08. Plots useful for data analysis
09. Loading and Saving data
10. Subplots, 3D plots, and labeling plots
11. Sound processing
12. Reversing and Speeding up an audio signal
13. The Fourier transform (Viewing the frequency components of a signal)
14. Fourier transform of a sine wave
15. Applying a low-pass filter to an audio stream
16. Saving images (resolution sampling)
17. Image manipulation (Flip images, etc)
18. Convolution (Blurring an image with Gaussian filter, Edge Detection)
19. Probability
        Measuring probability
        Generating random values from a certain distribution
        Birthday paradox
        Continuous variables from Discrete variables
        Mean and variance
        Gaussian (normal) distribution
        Test for normality (Test if a random variable is Gaussian distributed)
        2 sample tests (Compare 2 groups of Gaussian Distributed data)
        Multivariate Gaussian (Multidimensional Gaussian)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
01. Introduction (Basic syntax, command window, and working directory)

    3 Basic types of numbers in Matlab
        Scalars (Plain numbers), Physical quantity described by magnitude (Volume, density, speed, etc)
        Vectors (List of numbers), Physical quantity described by magnitude and direction (Force, velocity, etc)
        Matrices (Table of numbers)
            Matlab recognizes variables as matrices by default
            Type in:
                x=5
                size(x)
                Answer will be 1, 1. 
                Unlike other programming languages, "x" will be a table
            Rows and Columns
                [1, 3]
                [R, C]
                Row = horizontal
                Column = vertical
        
    Syntax
        Basics:
            x=5
            size(x)
            Answer will be 1, 1. 
            Unlike other programming languages, "x" will be a table
        Commas:
            v = [1, 2, 3];
            v = [1 2 3];
            Matlab doesn't really need commas
        Semicolon:
            v=[1 2 3]        //Automatically prints out "v = 1 2 3"
            v=[1 2 3];       //Auto print disabled
            
    Matrices/Vectors
        Separating rows:
            A = [1 2; 3 4]   //This will be 2x2 matrix. 1 and 2 in first row, 3 and 4 second row
        Transpose a matrix/vector (Horizontal to Vertical)
            v = [1 2 3];   //(1,3)
            v = v'            //(3,1)
        Calling values from matrices/vectors
            A = [1 2; 3 4];
            A(2,1)              //Prints out "3"
        Prints ALL values in a Row
            A = [1 2; 3 4];
            A(2,:)              //Prints out "3, 4"
        Prints ALL values in a Column
            A = [1 2; 3 4];
            A(:,2)              //Prints out "2, 4"
        Prints entire table
            A = [1 2; 3 4];
            A(:,:)              //Prints out entire table
            A                   //Prints out entire table
        Matlab does not do indexing like normal programming languages (Start with 0)
            A = [1 2 3 4; 5 6 7 8; 9 10 11 12; 13 14 15 16]
            A(1, 1)            //Prints out 1
        Prints inner table (2,2) from a (4, 4) matrix
            A = [1 2 3 4; 5 6 7 8; 9 10 11 12; 13 14 15 16]
            A(2:3, 2:3)      //Prints out 6, 7, 10, 11
        Range of numbers
            1:10               //Prints out 1 through 10
            w=1:10;         //Stores a vector of single row of 10 columns
            size(w)          //(1, 10)        

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
02. Basic matrix arithmetic in Matlab including an overview of different operators

    Refer
        https://www.mathworks.com/help/matlab/matlab_prog/matlab-operators-and-special-characters.html
        
    Adding, Subtracting, Multiply and Divide Matrices
        A = [1 2; 3 4];
        B = [5 6; 7 8];
        B2=[1 2; 4 5; 6 7]
        A+B                  //Ans=[6 8; 10 12]
        A-B                  //Ans=[-4 -4; -4 -4]
        A*B                  //Ans=[19 22; 43 50] - Matrix dimensions must be the same, Ref Matrix multiplication 
         //                      [A B; C D] * [E F; G H] = [(AE+BG)  (AF+BH);  (CE+DG)  (CF+DH)]
        A*B2'                //Ans=[5 14 20; 11 32 46], where the apostrophe represents transpose B2 from (3,2) to (2,3)
        A/B                  //Ans=[3.0 -2.0; 2.0 -1.0] - https://www.mathworks.com/help/fixedpoint/ref/mrdivide.html
        1/3                  //0.333
        3\1                  //3 - https://www.mathworks.com/help/symbolic/mldivide.html

    Check whether 2 values are equal
        1 == 1                           //Ans: 1 (True)
        1 == 0                           //Ans: 0 (False)  

    Elementwise, Multiply and Division
        A = [1 2; 3 4];
        B = [5 6; 7 8];
        A.*B              //Ans=[5 12; 21 32]
        A./B              //Ans=[0.2 0.33; 0.43 0.5]    

    Inner Product, Outer Product, Cross Product
        Row Vectors
            x=[1 2 3];
            y=[4 5 6];
            x*y'           //Ans=32, Inner product
            dot(x,y)       //Ans=32, same answer as x*y'
            x'*y           //Ans= [4 5 6; 8 10 12; 12 15 18],  Outer product
            cross(x,y)     //Ans=[-3 6 -3], Cross product
        Column Vectors
            x=[1; 2; 3];
            y=[4; 5; 6];
            x'*y           //Ans=32, Inner product
            dot(x,y)       //Ans=32, same answer as x*y'
            x*y'           //Ans= [4 5 6; 8 10 12; 12 15 18], Outer product
            cross(x,y)     //Ans=[-3; 6; -3], Cross product

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
03. Built in functions, constants and write custom functions

    Functions
        Sine, Cosine, Tangent
            sin(0)       //Ans=0
            cos(0)       //Ans=1
            tan(0)       //Ans=0
        Functions with Matrix
            A = [1 2; 3 4];
            sin(A)       //Ans=[0.84 0.91; 0.14 -0.76], elementwise
        Exponential, Logarithm, Squareroot
            exp(0)       //Ans=1
            log(1)       //Ans=0
            log(exp(1))  //Ans=1
            sqrt(4)      //Ans=2
        Built in Constants (Pi, Variable E, i)
            pi           //By default, this constant is at 3.1416
            pi=2         //pi can be assigned to another value, 2. To reset to its default value, go to workspace panel and delete "pi"
            exp(1)       //There is no vaiable e in Matlab. e^1 = exp(1)
            sqrt(-1)     //Ans=0.0000 + 1.0000i
            i            //Ans=0.0000 + 1.0000i
            i*i OR i^2   //Ans= -1
            sin(pi) + i*cos(pi)  //Ans=0.0000-1.000i
        Identity matrix (1s in diagonal)
            A=[1 0 0 0; 0 1 0 0; 0 0 1 0; 0 0 0 1]    //Ans: [1 0 0 0; 0 1 0 0; 0 0 1 0; 0 0 0 1]
            eye(4)                                    //Ans: [1 0 0 0; 0 1 0 0; 0 0 1 0; 0 0 0 1]
        Matrix of zeros and ones
            zeros(4)                   //Ans: [0 0 0 0; 0 0 0 0; 0 0 0 0; 0 0 0 0] - (4, 4) matrix
            zeros(3,2)                 //Ans: [0 0; 0 0; 0 0] - (3,2) matrix
            ones(4)                    //Ans: [1 1 1 1; 1 1 1 1; 1 1 1 1; 1 1 1 1] - (4, 4) matrix
            ones(3,2)                  //Ans: [1 1; 1 1; 1 1] - (3,2) matrix
        Modulus
            mod(3,2)                   //Ans: 1, Returns remainder - Since the "%" is used for the comment, MATLAB uses "mod" for modulus operations
        Invert
            ~0                         //Ans: 1, This returns the opposite number
            ~1                         //Ans: 0, This returns the opposite number

    Define custom functions
        Home Tab > New > Function > Editor Panel  
            -OR-   
        Right Click on Current Folder Panel > New File > Function
        Editor
            function [output_args] = untitled(input_args)
                %function code goes in here
            end
        Syntax
            When the function returns things, specify "output_arguments"
            If more than 1 "output_args", specify as an array
            If no "output_args", remove "[output_args] ="
        Saving the Function file
            The function name must be the same as the filename

    Define hyperbolic sine function
        Hyperbolic sine formula:
            sinh z = (0.5) * [(e^z) - (e^-z)]
        Editor
            function y = my_sinh(x)
                y = (exp(x) - exp(-x))/2;
            end
        Save file as "my_sinh.m"
        Command:
            my_sinh(1)                 //Ans=1.1752
            my_sinh(0)                 //Ans=0
        Calculate Hyperbolic sine of matrix "x"
            x=0:10;
            my_sinh(x)                 //Ans: 1.0e+04 * 0 ... 1.1013
        
    Define "is_even.m" function
        Editor
            function y = is_even(x)
                %function return 1 if x is even
                y = ~mod(x,2);                
            end        
        Command
            is_even([1 2 3 4 5])       //Ans: [0 1 0 1 0]


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
04. Linear equations
    
    Method
        Solving Linear Equations
            3x + 2y - z = 1
            2x - 2y + 4z = -2
            -x + 0.5y - z = 0
        Solution in Command Window
            A = [3 2 -1; 2 -2 4; -1 0.5 -1];
            b = [1 -2 0];
            inv(A)*b'            //Transpose b to column vector. Ans: 1, -2, -2
            NOTE:
                12/3 = 4
                12*3^-1 = 12*inv(3) = 12*(1/3),
                12*(1/3) = (12/3) = 4
        Other Method
            https://www.mathworks.com/help/symbolic/mldivide.html
            Ax = b               //This is similar to x = inv(A)*b OR A\b in MATLAB (mldivide - left matrix division)
            A\b'                 //Transpose b to column vector. Ans: 1, -2, -2
        Determinant
            det(A)               //Ans: -3
        Eigenvalues
            https://www.mathworks.com/help/matlab/ref/eig.html
            eig(A)               //Ans: [3.63; -3.84; 0.22]
        Eigenvectors
            [V, D] = eig(A)      //D = diagonal matrix, V = eigenvectors
        Checking eig
            A*V == V*D           //Ans: Should be an array of ones. But there will always be round off errors, therefore returning arrays of zeros
            A*V - V*D            //This finds out the differences between both matrices, it should return a very small number, ie "1.0e-14"
            norm(A*V - V*D)      //This finds out how big or small the values are, the distance from the origin (Especially for large matrix)
            norm(A*V - V*D, 2)   //Ans: Same as above because P = 2 by default
    Norms
        norm(A*V - V*D)          //Euclidian Distance - Square the values, then add the results and then take the squareroot
        norm(A*V - V*D, 2)       //P Norm - Value power of P, sum the results, get the p root
        norm(A*V - V*D, 1)       //P Norm - Manhattan distance, (L1 Norm)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
05. For loops, while loops, and if-else statements

    Timing
        To measure the function, add "tic" at the begining of the code and "toc" at the end of code
    
    FOR LOOPS
        Example 1
            Code:
                for i=[1 2 4 8 16 32]
                    disp(i);
                end
            Output:
                Prints out 1 through 32 on every line
                
        Example 2
            Code:
                for i=1:10
                    disp(i);
                end
            Output:
                Prints out 1 through 10 on every line      

        Example 3: Mean Squared Error
            Takes the difference between predicted value and actual value, squares them all, add all and then divide for average
            Code:
                E=randn(1000, 1)          //Generates random numbers in an array, this represents the differences
                SSE = 0;                  //Initialize sum of error to 0
                for i=1:1000              //Iterates 1 to 1000
                    SSE=SSE+E(i)*E(i);    //Squares every single value and adds to previous sum result
                end    
                MSE=SSE/1000;
            Command:
                MSE                       //Ans: Sum
            Shorter method
                E'*E/1000

    IF STATEMENT - Example 1 - Return 1 if the number in x is even
        CODE: 
            X=1:10;
            Y=zeros(1,10);
            for i=1:10
                if mod(X(i),2) == 0
                    Y(i)=1;
                else
                    Y(i)=0;
                end
            end
        Command:
            Y             //Ans: [0 1 0 1 0 1 0 1 0 1]

    IF STATEMENT - Example 2 - Return 1 if the number in x is divisible by 3
        CODE: 
            X=1:10;
            Y=zeros(1,10);
            S = 0;
            for i=1:10
                if mod(X(i),3) == 0
                    S = S + X(i);
                end
            end
        Command:
            S             //Ans: 18, which is 3 + 6 + 9

    WHILE LOOP - Example - Find element in a matrix    
        X=1:10;
        found = 0;
        i=0;
        while ~found    
            i = i+1
            if X(i) == 8
                disp('I found it!\n');
                found=1;
            end
        end

    FOR LOOP - Example - Find element in a matrix    
        X=1:10;
        found = 0;
        i=0;
        for i=1:10
            fprintf('i=%d\n', i);
            if X(i) == 8
                disp('I found it!\n');
                break;
            end
        end

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
06. Data types

    Strings
        disp('Hello there')
        Workspace panel but in Command window
            whos                           //Similar to "dir/w" in DOS6.2. Also not that "Hello" and "there" are in double and not string
            class('Hello there')           //Note this is returned as "char"
        Enter as "char"
            myString = 'Hello there'       //This will return as "char in "whos"

    Structs
        my_struct.name = 'My new struct'   //Single field struct, this case adds a string
        my_struct.age = 12                 //Adds another field dynamically, this case adds integer
        class()                            //Returns data type
        class(my_struct)                   //Returns data type for "my_struct"
        class(my_struct.name)              //Returns data type for name (char)
        class(my_struct.age)               //Returns data type for age (double)
        isfield(my_struct, 'name')         //Returns if the field (name) exists in "my_struct". Returns Boolean where 1 is true
        rmfield(my_struct, 'age')          //Removes a field (age) from "my_struct"
        setfield(my_struct, 'gender', 'f') //Similar to adding a field (my_struct.**), but setfield can be used while the program is running
        
    Struct within a struct
        my_struct.contact.phone = 123456789          //Adds a contact struct inside of my-struct, adds contact stuct with phone field
        my_struct.contact.email = person@gmail.com   //Adds a contact struct inside of my-struct, adds email field to contact struct
        my_struct.contact                            //Shows fields in my_struct.contact

    Initialize a struct
        S = struct('name', 'Abu', 'email', 'abu@gmail.com')   //Creates a struct (S) with name and email fields

    Cell
        Similar to struct but contains arbitrary fields (array, index, matrix, etc)
        my_cell{1} = 'hello bitch';              //Creates a cell with values containing "hello bitch"
        my_cell                                  //Prints out "hello bitch"
        my_cell2{1} = 'hello';
        my_cell2{'A'} = [1 2; 3 4];              //Adds a 2x2 matrix to cell A
        my_cell2                                 //Prints out rows and columns
        my_cell2{1}                              //Print out 'hello'
        my_cell2{'A'}                            //Prints out matrix


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
07. Plotting data with Fibonacci Sequence

    Simple Plotting
        Example 1: (1 dimension)
            y = [1,1,2,3,5,8,13,21];          //Adding previous 2 number to create current number (Fibonacci)
            ploy(y)                           //Plots the sequence as graph, note the x axis is 1-8
        Example 2: (2 dimensions)
            y = [1,1,2,3,5,8,13,21];  
            x = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7];
            plot(x, y)                        //Plots the sequence as graph, note the x axis is an increment of 0.1s instead of default 1-8
    
    Syntax:
        y = [1,1,2,3,5,8,13,21];  
        x = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7];
        size(x)                              //Prints the dimension, "1,8"

    Plotting a function:
        Linspace 1:                          //Creates a range of x values automatically
            x = linspace(0,100,200);         //linspace(start, end, points in between). The lower the number "in between", the higher the graph resolution
            y = sin(x);
            plot(x,y)                        //Shows a sine wave from -1, 0, 1 on amplitude and 0-100 on x-scale
        Linspace 2:
            x = linspace(0, 2*pi, 100);
            y = sin(x);
            plot(x,y)                        //Plots a smoother sine wave than "linspace 1"

    Plotting multiple functions on same plot:
        Multiple Functions:
            x = linspace(0, 2*pi, 100);
            y = sin(x);
            y2 = cos(x);
            plot(x,y,x,y2);                  //Shows 2 graphs on top of each other "plot(x1,y1,x2,y2,.....,xn,yn)"     
            plot(x,y, '-', x,y2, '.');       //Graph 1 will be in continuous line, graph 2 will be dotted line
            plot(x,y, '--', x,y2, '.');      //Graph 1 will be in dashed line, graph 2 will be dotted line

    Saving the graph
        In graph window, go to main menu > save as > select format > choose file format (pdf, png, jpg, etc)
        Fig files enables users to zoom into the graph in high resolution unlike image file (png, jpg, etc)
    
    Open graph from command window
        open('test.fig')                     //Opens the saved *.fig file 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
08. Plots useful for data analysis

    Bar charts
        Example 1:
            x=1:10;
            bar(x)
        Example 2 (Sine):
            x = linspace(0, 2*pi, 100);
            y=sin(x);
            bar(x,y)
    
    Histogram:
        x = randn(1000, 1);
        plot(x)           //Noise
        hist(x)           //Histogram with 4 bars resolution
        hist(x, 50)       //Histogram with 50 bars resolution

    Pie Chart:
        x=1:5;
        pie(x)      

    Scatter Plot:
        Ordered data
            x = linspace(0, 2*pi, 1000);
            y = 10*sin(x) + randn(1,1000);    //So that sine x has amplitude of 10 and add noise with variance of 1
            plot(x,y)                         //Sine wave of noise
            scatter(x,y)                      //Sine wave of dots
        Disordered data
            x = randn(1000, 1)*2;
            y = 5*sin(x) + rand(1,1000);
            plot(x,y)                         //Randomness
            scatter(x,y)                      //Sine wave of dots

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
09. Loading and Saving data

    Excel Files (*.xlsx)
        help xlsread                        //Opens help and displays xlsread syntax
        help xlswrite                       //Opens help and displays xlswrite syntax
        NOTE: 
            Usually Matlab cant read or write into Excel spreadsheet
            Therefore, *.csv files are commonly used together with Matlab
    
    CSV Files (*.csv)
        Create a 3x3 matrix in CSV
            1,2,3
            4,5,6
            7,8,9
        Save file as "csv_example.csv" into Project Tree

    Functions
        Example 1:
            A = csvread('csv_example.csv')     //Stores csv into "A" variable and prints out content
        Example 2:    
            B = eye(4)*5;                      //Creates a new matrix (4x4 zero matrix with diagonal col contains 5)
            csvwrite('another.csv', B)         //Creates new CSV file and store B matrix into the file
        Example 3:
            A = [1,2;3,4];
            B = [5,6;7,8];
            save('my_workspace.mat')           //Saves current variables as a single file
            load('my_workspace.mat')           //Loads saved variables
        Example 4:
            A = [1,2;3,4];
            B = [5,6;7,8];
            C = [9,10;11,12]
            save('AC.mat, 'A', 'C')             //Pass in the name of the variable to store into a file. This will store A and C without B

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
10. Subplots, 3D plots, and labeling plots

    Subplots
        X = linspace(0,2*pi,100);
        Y = sin(X);
        Z = Y + randn(1,100);      //Noise
        plot(X,Z)                  //Individual Plot
        plot(X,Z,X,Y)              //Multiplot
        
        subplot(2,1,1);            //subplot(number of rows in subplot, number of cols in subplot, which subplot to plot), from above, we have 2 subplots
        plot(X,Y)

        subplot(2,1,2);
        plot(X,Z)
        
        NOTE: The entire subplots will create a window with 2 plots over each other for comparison purposes (Stacked)

    3D Plots
        Z = randn(100,100);         //Create 2 dimensional dataset - random noise
        surf(Z)                     //3D plot will appear and this can be rotated via circular arrow in toolbar
        contour(Z)                  //Creates 2D topology of 3D data where red is the high value and blue is low value

    Label Plots
        x = linspace(0,2*pi,100);
        y = sin(x);
        plot(x,y)                   //Opens 2D plot
        title('Plot of sin(x)')     //Adds title to the plot
        xlabel('myLabelX')          //Labels the X axis
        ylabel('myLabelY')          //Labels the Y axis

    Label subplot
        z = cos(x);
        
        subplot(2,1,1)
        plot(x,y)
        title('sin(x)')             //Adds title to subplot 1

        subplot(2,1,2)
        plot(x,y)
        title('cos(x)')            //Adds title to subplot 1

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
11. Sound processing

    2 types of waves
        Transverse Wave      //Pitch is constant throught its length - This doesn't create sound
        Longitudinal Wave    //Pitch are different through out the length and ability to move back and forth

    When viewing the sound wave from electrical standpoint, we generally see the transverse wave
    But in reality, longitudinal wave produces the sound
    Also note that we are also viewing the analog waves from the digital standpoint
    Example, Ears > Longitudinal > Transverse > Matrix > Sampling Rate > Computer
    A matrix of 1000 in length that recreates analog transverse waves that in turn produces longitudinal waves
    The matrix also translates into 500 samples per second 
    This process of sampling is called "discretization"
    Discretization means datapoints along x-axis(time)
    Another type of discretization is Quantization, meaning, datapoints along y-axis(amplitude)

    Record a short clip and save as wave file (sample.wav) and mp3 file (sample.mp3)
    Add both files into Matlab project
    
    Wavread Syntax
        https://mathworks.com/help/matlab/ref/wavread.html
        y = wavread(filename)                      //where y is the sampled data itself
        [y, Fs] = wavread(filename)                //where Fs is sampling frequency
        [y, Fs, nbits] = wavread(filename)         //where nbits is number of bits per sample
        [y, Fs, nbits, opts] = wavread(filename)   //where opts is text description of audio file (title, author, etc)
        [__] = wavread(filename, N)
        [__] = wavread(filename, [N1 N2])
        siz = wavread(filename, 'size')
    
    Reading (*.wav)
        Note: Wavread only works with wav files
        d = wavread('sample.wav')                  //Note that wavread is no longer in use in newer versions of matlab. Audioread will be used instead
        plot(d)                                    //Plots the wave into matlab, this will look similar to what being shown in other audio softwares
        size(d)                                    //Check size of matrix (number of samples, number of dimensions), where dimension is number of channels (Stereo = 2 dimensions)
        
        [d,fs] = wavread('sample.wav');
        sound(d,fs)                                //Playback sound

    Reading (*.mp3)
        Note: Audioread has the ability to also read wav files
        [d,fs] = audioread('sample.mp3');
        sound(d,fs)                                //Playback sound

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
12. Reversing and Speeding up an audio signal

    Two methods to reverse an audio signal
        Flip L-R           //Reverse the 2 channels
        Flip U-D          //Reverse the signal
    
    Speeding up audio signal process: Downsampling
    
    Reading (*.wav)
        [d,fs] = audioread('sample.mp3');
        sound(d,fs)              
        size(d)                          //Size=84480

    Flip U-D
        d2 = flipud(d);
        plot(d2)                                                                        //Shows reversed version of the audio wave
        audiowrite('sample_reversed.mp4', d2, fs)               //Matlab cannot save to mp3 despite being able to read mp3s
        [d3, fs] = audioread('sample_reversed.mp4')
        sound(d3, fs)                                                               //Plays reversed audio

    Speed up soundwave (Downsampling)
        [d,fs] = audioread('sample.mp3');
        sound(d,fs)              
        size(d)                          //Size=84480
        d4 = downsample(d, 2);                                            
        size(d)                          //Size=44240
        sound(d4,fs)                //Plays audio at twice the speed, also note the pitch has increased
        sound(d4,fs/2)            //Plays audio at original speed, also note that there will be compression loss since audio has been compressed

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
13. The Fourier transform (Viewing the frequency components of a signal)
    
    f(x) is the original signal, a continuous signal of x (time domain)
        f(x) is the same thing as f(t)
        f(x) = For signal
        f(t) = For Sound (signals varying in time)
    Convert time domain to frequency domain - Fourier
    Convert frequency domain to time domain - Reverse Fourier
    To work in Matlab, Discrete Fourier Tranform will be used
    f(k) is the discrete signal (original signal)
    From f(k), the Discrete Fourier Transform "f(n)" can be calculated
    In Matlab, FFT (Fast Fourier Transform) will be used for calculating discrete fourier transform to analog n time
    Discrete Fourier Transform contains real part and imaginary part (0.0123 + 0.0012i) => (Real, Imaginary)
    Typically when plotting FFTs, real pert will be used

    Example 1:
        x = linspace(0,5*pi,1000);
        y = sin(x)                            //Create sine wave
        Y = fft(y);                           //Calculates fft for the sine wave
        plot(real(Y))                         //Plots the real number, Usually in fourier transform visualization, the graph is symmetric in the center

    Example 2:
        d = audioread('helloworld.mp3');     //Male more bassy voice
        D = fft(d(:, 1));
        size(D)                              //84480
        plot(real(D))

        f = audioread('helloworld_female.mp3');     //Female more high pitch voice
        F = fft(f);
        size(F)                              //8297
        plot(real(F))

        subplot(2,1,1);                             //Plotting 2 separate graphs of different sizes
        plot(real(F))
        subplot(2,1,2);     
        plot(real(D))

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
14. Fourier transform of a sine wave

    Usually in Fourier Transform, a delta function or a spike will be seen in frequency domain
    But in Matlab, 2 spikes (300, -300) will be seen instead of a single spike when zoomed in
    This is due to the absence of infinite sinewave
    Example (w/o infinite sine wave):
        x = linspace(0,5*pi,1000);
        plot(real(fft(sin(x))))
    Example (with infinite sine wave):
        x = linspace(0,10*pi,5000);
        plot(real(fft(sin(x))))

    
    Fourier Transform of a music piece
    Every single musical note has it's own frequency, multiples of each other
    Therefore, frequency changes constantly throughout the music
    Showing the frequency change with Fourier transform
    Fourier transform takes in the entire signal from time = -inf to +inf
    Therefore it takes in all the different frequencies over all of time and then plotting on fourier transform
    Short Time Fourier Transform will be used, aka Spectogram
    2 dimensional graph will show time on one axis and frequency on another axis
    https://www.mathworks.com/help/signal/ref/spectogram.html

    Example:
        x = linspace(0,10*pi,5000);
        y2 = sin(x.*x);              //Element bby element multiplication
        spectogram(y2)           //Blocky spectogram
        spectogram(y2,500)    //Less blocky but shows uncertainty principles. (When momentum is being measured, it will be accurate, but position will never be as accurately)
        //                                 //Same applies to Fourier Transform, to measure frequency accurately, longer time window is required

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
15. Applying a low-pass filter to an audio stream

    Listen to soundwave at different frequencies
        x = linspace(0,50*pi,10000);
        y = sin(x);
        sound(y,44100)      //Listen at common sampling frequency
        sound(y,22050)      //Listen at lower pitch

    Create low pass filter (Blocks out higher sets of frequencies)
    Blocks 2.5kHz and above, Gradient at 1kHz to 2.5kHz, Pass at 10Hz to 1kHz, No sweep
    Link: https://www.mathworks.com/help/matlab/ref/filter.html
    
    Apply High Pass filter
        b = ones(40,1)/40;                                  //Create matrix, See topic 3, Matrix of ones
        [d,fs] = audioread('helloworld.wav');               //Load data
        dlp = filter(b, 1, d);                              //filter(denominator, numerator, data)
        sound(d,fs)                                         //Play original sound 'helloworld.wav'
        sound(dlp,fs)                                       //Play sound with low pass filter (Muffled, where high frequency is not being played)

    Plotting 
        xaxis = 1:84480;
        plot(xaxis,d,xaxis,dlp)                             //Note that the waveform with low pass filter is smoother without sharp edges

    Plot to frequency domain
        subplot(2,1,1);
        plot(real(fft(d)))                                  //Original
        subplot(2,1,2);
        plot(real(fft(dlp)))                                //Filtered


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
16. Saving images (resolution sampling)

    Sound is a one dimensional function - Amplitude
    Sound is plotted amplitude against time
    Images are 2 dimensional functions
    Image is plotted against resolution

    Think of image "A" with coordinates "i" and "j"
    1 parameter = greyscale
    3 parameters = rgb colour
    Values will be 0 to 255, therefore 256
    RGB can gold up to 256*3 = 16,777,216
    For 500 by 500 rgb image, then 500*500*3        //Matrix being used for representing RGB image aka image bitmap
    uint8:
        unsigned integer 8 bits
        8bits = 2^8 = 256
    
    Open an image:
        A = imread('example.bmp');
        size(A)                                     //512, 512, 3
        imshow(A)                                   //This plots the image
        
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
17. Image manipulation (Flip images, RGB)

    Open an image:
        A = imread('example.bmp');
        size(A)                                                            //512, 512, 3
        imshow(A)                                                          //This plots the image

    Flip Up Down (Vertical Flip)
        U = flipud(A);                                                     //Flips image upside down
        imshow(U)

    Flip (Horizontal Flip)
        V = fliplr(A);                                                     //Flips image horizontal direction
        imshow(V)

    Flip Horizontally and Vertically
        UL = flipud(fliplr(A));
        imshow(UL)

    Show blue channel
        B = A;
        B(:,:,1) = 0;                //Meaning: (Select all rows, select all columns, set first channel) = set to 0, Red OFF
        B(:,:,2) = 0;                //Meaning: (Select all rows, select all columns, set second channel) = set to 0, Green OFF
        imshow(B)                    //Blue channel image

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
18. Convolution (Blurring an image with Gaussian filter, Edge Detection)

    The filter used for sound is called "moving average"
    Moving average is taking a window (let's say 5 samples in a window) and then "sweeping" across the entire signal and taking in the average as the output
    The "sweeping" action is called convolution
    Convolution:
        https://mathworld.wolfram.com/Convolution.html
        Since convolution in time equals to multiplication in frequency
        Therefore, take Fourier Transform of both signals and then multiply them
        Then do the inverse Fourier Transform to return to time domain

    Reference:
        https://graphics.stanford.edu/courses/cs178/applets/convolution.html
        Single Dimension, ie across time
            Continuous variable filtered by another continuous variable
                f(x) * g(x) = integral [ f(tau) . g(x - tau) d tau ]
            Discretize by turning into sum
                f|x| * g|x| = Sum [ f|k| . g|x-k| ]        
        Two dimensions (with 2 dummy variables), ie Spatial dimensions (x,y) of an image
            f(x,y) * g(x,y) = integral1 integral2 [ f(tau1,tau2) . g(x-tau1, y-tau2) dtau1 dtau2 ]  //Where integral1 is Tau1 and Integral2 is Tau2
            -OR-
            f[x,y] * g[x,y] = Sum1 Sum2 f[n1, n2] . g[x-n1, y-n2]      //Where Sum1 is n1 and Sum2 is n2

    Create a function (my_gaussian.m)
    my_gaussian.m
        function H = my_gaussian(n, sigma)
        
        two_sigma_sq = 2*sigma*sigma;
        H = zeros(n);     //Initialize n by n matrix with zeros
        for i=1:n         //Assign every value of H
            for j=1:n
                x = 1 - n/2;       //Enables the center point of H to be the highest point of gaussian
                y = j - n/2;       //Enables the center point of H to be the highest point of gaussian
                H(i,j) = exp(-(x*x + y*y)/two_sigma_sq);       // (x=0, y=0), exponent of 0 is 1
            end
        end
        end
        
        //Where n is the size of the square, output will be n by n matrix
        //Sigma is the standard deviation of gaussian

    Command Window
        H = my_gaussian(100,10);    //n=100, sigma=10
        imshow(H)                   //Shows the Gaussian brush (Circular with brightest at center)

        H = my_gaussian(100,25);    //n=100, sigma=25
        imshow(H)                   //Shows the Gaussian brush (Radius of the brightest inner strength increased)

    Gaussian + Image
        C = conv2(double(A(:,:,1)), H);     //A=512x512x3, 3 dimensional, so split into 1 dimension with (:,:,1) RGB and double it with "double()" because H is 2 dimensional
        imshow(C)                           //All turns white, intensity of gaussian too high

    Smaller Gaussian Filter + Image
        H = my_gaussian(25,5);                   //Smaller filter, sigma value smaller, therefore Lower blur value
        C = conv2(double(A(:,:,1)), H/50000);    //Lowers down the intensity by 50k
        imshow(C)

    Using fspecial to create the filter automatically
        https://www.mathworks.com/help/images/ref/fspecial.html
        Enables Gaussian filter, Laplacian filter, averaging filter, sobel filter, etc

    Using fspecial
        h = fspecial('gaussian', 25, 5);
        c = conv2(double(A(:,:,1)), h/500);
        imshow(c)
        imshow(h)                        //All black filter
        max(max(h))                      //Shows max value of h (brightest part of the brush), 0.0065, therefore close to black instead of white (1)
        imshow(h/max(max(h)))            //Shows the normal brush
        //The value for h is small because of normalization (Probability, sum everything = 1)
        sum(sum(h))                      //Ans: 1

    Edge detection
        E = edge(A(:,:,1));
        imshow(E)                        //Shows the outlines of objects inside image


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
19. Probability

    How a programmer approach problems in probability.
    Therefore, does not follow standard probability and statistics approach
    
    Content:
        Measuring Probability (Identify and quantify uncertainty)
        Generating random values
        Birthday paradox
        Continuous variables from Discrete variables
        Mean and variance
        Gaussian (normal) distribution
        Test for normality (Test if a random variable is Gaussian distributed)
        2 sample tests (Compare 2 groups of Gaussian Distributed data)
        Multivariate Gaussian (Multidimensional Gaussian)

    ///////////////////////////////////////////////////////////////////////////////////////////////////////
    19A Measuring Probability (Identify and quantify uncertainty)
    
        Theory: 
            Coin flips are 50% heads or tails. 
            As the number of flips approaches infinity, probability will approach 0.5 -OR- 50%
            
        Link: github.com/lazyprogrammer/matlab-probability-class
        Clone and download the files
        In Matlab, change "Current Folder" panel to the downloaded folder
        Command Window
            R = csvread('random_integers.csv');        //Load data to R 
            size(R)                                    //Shows 100 as the size of R, 100 by 1 matrix
            sum(R == -5) / length(R)                   //Calculates the probability of data that R = -5.  //Ans: 0.07 -OR- 7%
            hist(R)                                    //Shows the Histogram of R
            sum(mod(R,2) == 0) / length                //Using modulo to find out if probability is even, //Ans: 0.43
            sum(mod(R,2) == 1) / length                //Using modulo to find out if probability is odd,   //Ans: 0.57
            sum(R == 5 | R == -5) / 2                  //If R takes in a specific value, in this case, 5 or -5.  Ans: 0.21 -OR- 21%

    ///////////////////////////////////////////////////////////////////////////////////////////////////////
    19B Generating random variable from certain distribution
    
        Useful for simulations of systems with uncertainty
        
        randi(imax)        //Uniformed distributed variable between "1" and "imax"
        randi(10)          //Ans: 9, between 1 and 10 where 10 is the "imax"

        R = randi(10, 3)   //Where imax = 10 and n = 3, will return nxn matrix, "randi(imax, n)"
            Ans:
                10  7    6
                2    1  10
                10  3  10

        R = randi(10, 3) + 10  //Returns values between 10 to 20
            Ans:
                12  15  15
                20  19  20
                20  12  18

        rand                  //Return numbers between 0 to 1, in 4 decimal places
        hist(rand(100,1))     //Returns histogram of random numbers, the higher the imax number, the more equally distributed it is
        //                    //"When n approaches infinity, probability approach their true values"

        P(heads) = 0.25, P(tails) = 0.75 
            Discreet distribution: Simulate an unfair coin and to draw its distribution, not from a uniformed distribution
            To create a function to do this
            
            Test 1
                Function file 1: (biased_coin.m)
                    function [face] = biased_coin(p_heads)       //Returns the coin "face" from "biased coin"
                        if rand < p_heads                        //Generate random value
                            face = 'h';                          //Return heads
                        else
                            face = 't';                          //Else return tails
                        end    
                    end

                Function file 2: (test_biased_coin.m)
                    function test_biased_coin(p_heads, n)
                        A = zeros(n, 1);
                        for i=1:n
                            A(i) = biased_coin(p_heads);
                        end    
                        hist(A);
                    end

                Command Window:
                    biased_coin(0.25)              //Ans = h OR t, enter multiple times
                    test_biased_coin(0.25, 1000)   //Shows the histogram of biased distribution, where 104 is heads

    ///////////////////////////////////////////////////////////////////////////////////////////////////////
    19C Birthday Paradox

    Problem: Given a class of n students, what is the probability that at least 1 pair of students shares a birthday
    At n = 23, probability is about 50%, which is why this problem is called a paradox.
    Therefore if a class has more than 23 students, there is more likely to have 2 students sharing the same birthday.
    This is counterintuitive when there are 365 days per year and having 2 students sharing the same birthday is more unlikely
    And with a class of 50, 100% chance that there will be 2 people sharing a birthday
    
    P(at least 1 pair shares a birthday) + P(nobody shares a birthday) = 1
    P(at least 1 pair shares a birthday) = 1 - P(nobody shares a birthday)
    1st person = 365/365
    2nd person = 1 - (364/365) = 0.0027 (Case for 2 people)
    3rd person = 1 - (364/365)*(363/365) = 0.0082 (Case for 3 people sharing a birthday)

    birthday.m
        function [A] = birthday(n)
            A = ones(n,1);
            p = 1;
            for i=1:n
                A(i) = 1 - p;
                p = p*(365-i)/365;
            end
        end

    Command window
        A = birthday(100);
        plot(A)

        A(23)   //Ans: 0.507

    ///////////////////////////////////////////////////////////////////////////////////////////////////////
    19D Continuous Variables

        Discrete variables can only take discrete values
        Continuous variables can take on any values
        In continuous variables, there is no such thing as exact value
        This is because in continuous variable, X can take infinite number of values
        This in turn makes continuous variables to have no probability of exact value, but are usually in range format
            Exact: x = 3.2342
            Range: x = 3 to 3.5
        Probability for ranges in continuous variable
            P(3 < x < 3.5) > 0
        Cumulative Distribution Function (CDF):- To measure the probabiliy for ranges
            Fx(x) = P(-inf < X < x)
            Also note that the probability for X is between -inf and +inf is 1 since x has to take a value
                Fx(inf) = P(-inf < X < inf) = 1
        P(3.13 < X < 3.15) > 0
            = F(3.15) - F(3.13)

        Probability Density Function (PDF)
            https://www.youtube.com/watch?v=Fvi9A_tEmXQ
            fx(x) is defined by the derivative of Fx(x) with respecto to x (Slope)
            Therefore: fx(x) = [dFx(x)] / dx
            This can be greater than 1 since it's not a probability
            But, f(x) has to be greater or equal to 0, f(x) >= 0

            Example where f(x) is greater than 1
                Assume the random numbers "x" is distributed uniformly between 0 and 0.1 
                Then f(x) 
                    10 (IF 0 <= x < 0.1), 
                    0 (IF otherwise)   
                Because F(x) is the integral of f(x)
                    |         x
                    F(x) = integral [f(x)dx]
                    |       -inf
                Take constant out
                    |                x
                    F(x) = const. integral dx
                    |                0
                Integral
                    |                            0.1
                    Integral = F(inf) = const. integral dx = 0.1c
                    |                             0
                Therefore, find value of c 
                    c = 10

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    19E Mean and Variance

        Measuring the distribution of continuous variables
        Discrete: How often the variable takes a certain value and divide by the total number of values
        Continuous: Need certain characteristics of the distribution that defines the shape of the distribution curve (Mean and Variance)
        
        Mean: Add all values and divide by total values to get the middle value (The center of all values)
        Command Window 
            R = csvread('random_integers.csv');                       //Refer to 19A for the csv file
            sum(R)                     //Sum of all values
            length(R)                  //Total number of values 
            sum(R)/length(R)           //Mean
            mean(R)                    //Exactly the same as "sum(R)/length(R)"

        Variance: The spread of a distribution from the middle value "E[(X-mean(X))^2]"
        Command Window
            meanR = mean(R)        //Set mean of R as meanR
            varR = (R-meanR)'      //Dot product (squaring of all individual values)
            varR = (R-meanR)'*(R-meanR)                 //Multiply with corresponding value, Treating R as a vector and then finding the dot product with itself after subtracting the mean
            varR = (R-meanR)'*(R-meanR)/length(R)       //Subtracting the mean and then taking the squared distance/length. The answer is the variance
            varR = (R-meanR)'*(R-meanR)/(length(R)-1)   //Unbiased estimate of the variance
            var(R)                                      //Exactly the same as "(R-meanR)'*(R-meanR)/(length(R)-1)". Therefore MATLAB's variance is the unbiased form

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    19F Gaussian (normal) distribution
    
        Mean and Variance in topic 19E describes what a continuous distribution looks like
        In Gaussian Distribution, the mean and variance completely describe the shape of the distribution curve
        The standard distribution shows the normal bell curve
        The mean shows the amplitude of the bell curve or how high the peak is in the bell curve. 
        Variance shows the how much the bell curve is spread out horizontally 

        Sigma = standard deviation
        Sigma^2 = variance

        Probability density of normal distribution
            PDF = f(x | mu, sigma)                          //Where mu is the mean
            PDF = [1 / (sigma sqrt(2*pi))] e -[((x-mu)^2)/2sigma^2]

        my_gaussian.m
            function [X, f] = my_gaussian(mu, sigma_sq, min_x, max_x, n) //n is the number of different values between min_x and max_x, X is in array format
                
                X = zeros(n, 1);      //Initialize the X array
                f = zeros(n, 1);      //Initialize the f array
                x = min_x;            //Begin with min_x
                dx = (max_x - min_x) / n;      //Mean
                
                for i = 1:n           //Increment at each iteration
                    X(i) = x;
                    f(i) = 1/sqrt(2*pi*sigma_sq) * exp( -(x-mu)^2 / (2*sigma_sq) );
                    x = x + dx;
                end
                
            end

        Command Window
            [X, f] = my_gaussian(0, 1, -10, 10, 1000);     //Where my_gaussian(mu, sigma_sq, min_x, max_x, n)
            plot(X, f)      //Bell curve will pop up and the peak will be at 0.4, and the spread will be from -2 to 2

            [X, f] = my_gaussian(0, 0.1, -2, 2, 1000);
            plot(X, f)      //Bell curve will pop up and the peak will be at 1.2, and the spread will be from -1 to 1. In PDF, value above 1 is allowed (See 19D)

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    19F Test for normality (Test if a random variable is Gaussian distributed)














