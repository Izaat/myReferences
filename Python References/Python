Python 3 in Jupyter Notebook and VSCode
///////////////////////////////////////////////////////////////////////
CONTENTS
01. Structure, Variables and Data Types
02. Working with Strings and Numbers
03. Input from users
04. Basic Calculator
05. Lists, List Functions and Tuples
06. Functions - Structure, Parameter
07. Return Statement
08. Statements  (If, While, For)
09. Comparison Statements
10. Better Calculator
11. Dictionaries
12. Guessing game with While loop
13. Exponent Power Function
14. 2D List and Nested Loops
15. Build Translator
16. Comments
17. Catching Errors, Exceptions, Try-Catch Block - Topic 30 for more
18. Reading Files
19. Writing Files
20. Modules and Pip
21. Classes & Objects
22. Multiple Choice Quiz
23. Object Functions
24. Inheritence
25. Interpreter
26. Sets
27. Collections (Counter, named Tuple, OrderDict, defaultdict, deque)
28. Iter Tools (Product, Permutations, Combinations, Accumulate, GroupBy, Infinite Iterators)
29. Lambda Functions
30. Logging - Error Messages (Ctd from Topic 17) - Logging to different levels
31. JSON
32. Random Numbers
33. Decorators - Basic, Arguments, Function Identities, Repeating, Nested, Class
34. Generators
35. Threading & Processing
36. Multithreading - Sharing, Locking, Queueing, Daemon
37. Multiprocessing - Sharing, Locking, Queueing, Process Pool
38. Function Arguments (Args, Kwargs, Unpacking, Local, Global, Mutable, Immutable)
39. Asterisk (*) Operator
40. Shallow & Deep Copying
41. Context Managers
42. Python Unique Features - Classes in Functions, Functions in For-Loops, Function-Statement-Function, Inspect Module
43. Dunder/Magic/Datamodel Method
44. Metaclasses

////////////////////////////////////////////////////////////////////////
01. Strings, Structure, Variables and Data Types
    //Just type in 
        print("Just type anything here")
        Shift+Enter in Jupyter   
        
    //Program
        character_name = "Name01"
        character_age = 35
        print("The name is " + character_name + " and he is " + character_age + " years old.")
        character_name = "Name02"    //Reassigning another value to the variable
        print("He has a brother named " + character_name + ".")
        
    //Data types
        string_name = "Tom"              //string
        int_num_double = 35.123123 //the variable will recognize if it is a float, num, int, or double unlike C language
        is_Male = True | False             //boolean

////////////////////////////////////////////////////////////////////////
02. Working with Strings and Numbers

    //Strings
        //Adding new line
            print ("First line \n Second Line")
            
        //Print out Quotation Mark
            print("Print this \"Quotation Mark\" ")
            
        //Print out variable
            variable = "Hello"
            print(variable)
            
        //Print on multiple lines
            variable = """Hello
            World"""
            print(variable)     //Output: Prints Hello on one line and World on another line
            
        //Print on single line
            variable = """Hello \
            World"""
            print(variable)     //Output: Prints Hello World on single line due to existence of "\" 
            
        //Concatenate
            variable = "Hello"
            print(variable + " there!")
            
        //Convert entire string to lower case
            variable = "HELLO"
            print(variable.lower())
            
        //Convert entire string to upper case
            variable = "hello"
            print(variable.upper())
            
        //Check strings in lower or upper and returns true or false
            variable = "hello"
            print(variable.isupper())   //Output: False
        
        //Converts to Uppercase and then check strings in lower or upper and returns true or false
            variable = "hello"
            print(variable.upper().isupper())   //Output: True
        
        //Length            
            variable = "hello"
            print(len(variable))   //Output: 5
            
        //Indexing - Grab Character    
            variable = "hello"
            print(variable[1])   //Output: e    //Negative numbers can also be used
        
        //Indexing - Find index number of a character  
            variable = "hello"
            print(variable.index("h"))   //Output: 0   
            
        //Check substring present in string
            variable = "hello world"
            print(variable.startswith('hello'))     //Output: True      //.endswith() = False
            
        //Count characters
            variable = "hello world"
            print(variable.count(o))     //Output: 2
            
        //Replace String  
            variable = "hello there"
            print(variable.replace("hello", "hi"))   //Output: hi there   
            
        //White Space
            variable = "       Hello       "
            variable = variable.strip()
            print(variable)         //Output: Hello     //Without white space
            
        //Splitting  string into list
            variable = "how,are,you,there"
            mylist = variable.split(",")    //Use space for space delimiter and comma if comma is the demilitier
            print(mylist)       //Output: ['how', 'are', 'you', 'there']
            new_string = ','.join(mylist)    //This combines back list into string
            print(new_string)   //Output: how,are,you,there
            
        //List to String
            mylist = ['a'] * 6
            print(variable)     //Output: ['a', 'a', 'a', 'a', 'a', 'a']
            
            mystring = ' '.join(mylist)
            print(mystring)     //Output:   a a a a a a
            
        //For Loop
            variable = "Hello"
            for variable2 in variable:
                print(variable2)    //Output: Types in character on every line
                
       //IF ELSE
            variable = "Hello"
            if 'e' in greeting:
                print('yes')
            else:
                print('no')
                
       //Find index
            variable = "Hello"
            print(variable.find('o'))   //Output: 4
            
        //Other Method - Slicing, Stepping, Reverse
            Rules similar. See Topic 5, Slicing, Stepping and Reverse Section.
            
        //Formatting - %
            var = "Tom"
            mystring = "The variable is %s" % var       //%s for string, "%d" for decimal, %f for float, %.2f for 2 decimal places
            print(mystring) //Output: The variable is Tom
            
        //Formatting - dot formatting
            var = 3.123415
            var2 = 6
            mystring = "The variable is {} and {}".format(var, var2)         //Add {:.2f} for 2 decimal places
            print(mystring)     //Output: The variable is 3.123415 and 6
            
        //Formatting - F String
            var = 3.123415
            var2 = 6
            mystring = f"The variable is {var} and {var2*2}" 
            print(mystring)     //Output: The variable is 3.123415 and 12
            
        //Timer
            from timeit import default_timer as timer
            mylist = ['a'] * 1000000
            print(mylist)
            
            start = timer()
            mystring = ' '.join(mylist)
            stop = timer()
            
            print(stop-start)       //Output: 0.016s

    //Numbers
        //Basic Arithemetics
            print(3 * 4 + 5)    //Output: 17
            print(3 * (4 + 5))    //Output: 27

        //Modulus (Remainder)
            print(10%3) //Output: 1

        //Convert number into String
            my_num = 23
            print(str(my_num) + "is my favourite number") //Output: 23 is my favourite number
            NOTE: You can't print out number within a sentence, calling the variable name is required
        
        //Absolute value
            my_num = -5
            print(abs(my_num)) //Output: 5
        
        //Exponent - See topic 13
            print(2**3) //2 to the power of 3 = 8
        
        //Squared
            print(pow(5, 2)) //Output: 25

        //Which number is higher (max, min)
            print(max(4, 6)) //Output: 6

        //Rounding numbers to whole numbers
            print(round(3.2123)) //Output: 3

        //Import other math functions
            from math import *

            //Floor - To erase the decimals
                print(floor(3.1234))    //Output: 3
                
            //Ceiling - To erase the decimals but add 1
                print(ceil(3.1234))    //Output: 4

            //Square Root
                print(sqrt(4)) //Output: 2

////////////////////////////////////////////////////////////////////////
03. Input from Users
    //Program
        name = input ("Enter your name: ")
        age = input("Enter your age: ")
        print ("Hello " + name + " and you are " + age + " years old!")

////////////////////////////////////////////////////////////////////////
04. Basic Calculator
    //Program
        num1 = input("Enter a number: ")
        num2 = input("Enter another number: ")
        result = int(num1) + int(num2)  //The "int" converts string to whole number. Use "float" for decimal
        print(result)

////////////////////////////////////////////////////////////////////////
05. Lists, List Functions and Tuples
    //Lists
        friends = ["Friend01", "Friend02", "Friend03", 20, "Friend04"]  //You can add number and strings in the list
        print(friends[0]) //Output: Friend01
        print(friends[-1]) //Output: 20
        print(friends[-2]) //Output: Friend03
        print(friends[1]) //Output: Friend02
        print(friends[1:]) //Output: Friend02, Friend03, 20 
        print(friends[1:3]) //Output: Friend02, Friend03 
        //Change list value
        friends[1] = "Mike"
        print(friends[1])   //Output: "Mike"

    //List Functions
        lucky_numbers = [4, 8, 15, 16, 23, 42]
        friends = ["Kevin", "Karen", "Jim", "Oscar", "Toby"]
        
        friends.extend(lucky_numbers)
        print(friends)  //Output: Concatenate friends with lucky_numbers

        friends.append("Creed")
        print(friends) //Output: Adds  Creed to the friends list

        friends.insert(1, "Kelly")
        print(friends) //Output: Inserts Kelly to the friends list between Kevin and Karen

        friends.remove("Jim")
        print(friends) //Output: Removes Jim from the friends list

        friends.clear()
        print(friends) //Output: Clear the entire friends list

        friends.pop()
        print(friends) //Output: Removes the last element from the list

        print(friends.index("Kevin")) //Output: Shows the index number of Kevin in the list
        print(friends.count("Jim")) //Output: Counts the number of occurrences of Jim in the list  

        friends.sort()
        print(friends) //Output: Alphabetical order

        friends.reverse()
        print(friends) //Output: Reverse sort the list
        
        friends2 = friends.copy()
        print(friends2) //Output: Copies friends list to friend2 list
        
        friends2 = list(friends)
        print(friends2) //Output: Copies friends list to friend2 list
        
        friends2 = friends[:]
        print(friends2) //Output: Copies friends list to friend2 list
        
        mylist = [0] * 5
        print(mylist) //Output: Creates a new list with 5 columns of 0
        
        concat_list = friends + mylist
        print(concat_list)  //Output: Like Append. Combines Friends and new list
        
    //Slicing by index
        a = friends[1:4]
        print(a)    //Output: "Friend02", "Friend03", 20 //index 1 to 3 excluding 4
        
        a = friends[:2]
        print(a)    //Output: "Friend01", "Friend02", "Friend03"
        
        a = friends[2:]
        print(a)    //Output: "Friend03", 20, "Friend04"
        
    //Stepping by index of 1
        mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9]
        a = mylist[::1]
        print(a)    //Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]
        
    //Stepping by index of 2
        mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9]
        a = mylist[::1]
        print(a)    //Output: [1, 3, 5, 7, 9]
        
    //Reverse Stepping by index
        mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9]
        a = mylist[::-1]
        print(a)    //Output: [9, 8, 7, 6, 5, 4, 3, 2, 1]
        
    //Tuples - Similar to list, but tuples can't be changed or modified
        //Syntax to differentiate strings from tuples
        mytuple = ("String",)
        print(type(mytuple))    //Output: Tuple. Note the comma. 
        
        //Call by index
        coordinates = (4, 5, 6)
        print(coordinates[0])   //Output: 4
        
        //Call by index
        mytuple = tuple(["String1", 10, "String2"])
        item = mytuple[0]
        print(item) //Output: String1

        //Can also be used as list of tuples
        coordinates = [(1, 2), (3, 4), (5, 6)]
        print(coordinates)
        
        //Tuple function
        mytuple = tuple(["String1", 10, "String2"])
        print(mytuple)
        
        //Using For Loop
        mytuple = tuple(["String1", 10, "String2"])
        for i in mytuple:
            print(i)        //Output: List element in new line
            
        //Using If statement
        mytuple = tuple(["String1", 10, "String2"])
        if "String1" in mytuple:
            print("yes")
        else:
            print("no")     //Output: Yes
            
        //Get number of elements
        mytuple = tuple(["String1", 10, "String2"])
        print(len(mytuple))     //Output: 3
            
        //Count the tuples
        mytuple = ('a', 'b', 'b', 'b', 'c', 'd')
        print(mytuple.count('b'))   //Output: 3
        
        //Find index number
        mytuple = ('a', 'b', 'b', 'b', 'c', 'd')
        print(mytuple.index('d')) //Output: 5
        
        //Convert tuple into a list and vice versa for reverse
        mytuple = ('a', 'b', 'b', 'b', 'c', 'd')
        mylist = list(mytuple)
        print(mylist)  //Output: ['a', 'b', 'b', 'b', 'c', 'd']
        
        //Slicing with tuple - All slicing methods used in list are similar for tuples
        mytuple = ('a', 'b', 'b', 'b', 'c', 'd')
        slicedTuple = mytuple[2:5]
        print(slicedTuple)      //Output: b, b, c where index 5 is not included (similar to list)
        
        //Unpacking tuples
        mytuple = ("Max", 28, "City")
        name, age, city = mytuple
        print(name) //Output: Max
        
        //Unpacking tuples using stars
        mytuple = ("Max", 28, 29, 30, "Dog", "City")
        i1, *i2, i3 = mytuple
        print(i1)
        print(i2)   //Output: [28, 29, 39, Dog] //Note tuples converted to list
        print(i3)   //Output: City
        
        //List is larger than tuples
        import sys
        mylist = [0, 1, 2, 3, "String", True]
        mytuple = (0, 1, 2, 3, "String", True)
        print(sys.getsizeof(mylist), "bytes")
        print(sys.getsizeof(mytuple), "bytes")
        
        //Faster to process tuples than list
        import timeit
        print(timeit.timeit(stmt="[0, 1, 2, 3, 4, 5, 6]", number=1000000))
        print(timeit.timeit(stmt="(0, 1, 2, 3, 4, 5, 6)", number=1000000))
        
     //Using for, if, while statements
        friends = ["Friend01", "Friend02", "Friend03", 20, "Friend04"]
        
        //For Loop
            for hello in friends
                print(hello)    //Outputs elements on every line
            
        //If Statement - check if listElement is in the list
            if "Friend01" in friends:
                print("yes")
            else:
                print("no")
            
    //Check number of elements in the list
        print(len(friends))
        
    //List multiplication by itself
        mylist = [1, 2, 3, 4, 5, 6]
        b = [i*i for i in mylist]
        print(b)       //Output: [1, 4, 9, 16, 25, 36]

////////////////////////////////////////////////////////////////////////
06. Functions (Similar to Class)
    //Program Structure
        def sayHi():
            print("Hello")        
        sayHi()

    //Program with Parameters
        def sayHi(name, age):
            print("Hello " + name + " and you are " + str(age) + " years old")   
            //Remember that numbers can't share with string within a sentence therefore needs to convert to string hende str(age)
        sayHi("Mike", 23)   //Output: Hello Mike and you are 23 years old        

////////////////////////////////////////////////////////////////////////
07. Return Statement
    //Program
        def cube(num):
            return num*num*num          //Without "return", it prints out none or null
            print("Hello")                        //All codes that are below the return keyword, it wont run (the return keyword breaks the function)
        result = cube(4)
        print(result)                             //Output: 64

////////////////////////////////////////////////////////////////////////
08. Statements (If, While, For)
    //If Statement
        is_male = True
        is_tall = True
        
        if is_male or is_tall:                                  //You can use "or", "and", 
            print("You are male and tall or both")   //If is_male is true, then print the string
        elif is_male and not(is_tall):                      //else if statement
            print("You are a short male")
        elif not(is_male) and is_tall:
            print("You are not male but is tall")
        else:
            print("You are either  not male or not tall")
            
    //While Loop
        i = 1
        while i <= 10:
            print(i)
            i += 1
        print("Loop complete")
        
    //For Loop #1
        for letter in "Hello":
            print(letter) //Output: Prints out every single letter in each line
    
    //For Loop #2
        friends = ["Bob", "Jim", "Karen"]
        for friend in friends:
            print(friend) //Output: Prints out each item in each line
            
    //For Loop #3
        for index in range(10):
            print(index) //Output: Prints out each number (0-9) in each line
            
    //For Loop #4
        for index in range(3, 10):
            print(index) //Output: Prints out each number (3-9) in each line
            
    //For Loop #5
        friends = ["Bob", "Jim", "Karen"]
        for index in range(len(friends)):
            print(friends[index]) //Output: Prints out each name in each line
           
    //For Loop #6
        for index in range(5):
            if index == 0:
                print("First Iteration") 
            else:
                print("Not First")  //Output: Prints out not first in each line    

////////////////////////////////////////////////////////////////////////
09. Comparison Statements
    //Program ('>=', '<=', '==', '!=', '>', '<')
        def max_num(num1, num2, num3):
            if num1 >= num2 and num1 >= num3:
                return num1
            elif num2 >= num1 and num2 >= num3:
                return num2
            else:
                return num3
        
        print(max_num(3, 4, 5)) //Output: 5

////////////////////////////////////////////////////////////////////////
10. Better Calculator
    //Program
        num1 = float(input("Enter first number: ")) //turn numbers into float
        op = input("Enter operator: ")
        num2 = float(input("Enter second number: "))

        if op == "+":
            print(num1 + num2)
        elif op == "-":
            print(num1 - num2)
        elif op == "/":
            print(num1 / num2)
        elif op == "*":
            print(num1 * num2)
        else:
            print("Invalid operator")

////////////////////////////////////////////////////////////////////////
11. Dictionaries
    //A collection data type and mutable
    //To make dictionary immutable(can't be modified like in tuples), you have to build frozenset
    //Program that converts shortform Month name to longform
        monthConversions = {
            "Jan": "January",
            "Feb": "February",
            "Mar": "March",
            "Apr": "April",
            "May": "May",
            "Jun": "Jun",
            "Jul": "July",
            "Aug": "August",
            "Sep": "September",
            10: "October",
            "Nov": "November",
            12: "December",
        }

        print(mothConversions["Nov"])   //Output: November
        print(mothConversions.get("Nov"))   //Output: November
        print(mothConversions.get("Lov"))   //Output: None
        print(mothConversions.get("Lov", "Not a valid key"))   //Output: Not a valid key
        print(mothConversions.get(12))   //Output: December
        
    //Basic 
        mydict = {"name": "Max", "age": 28, "city": "New York"}
        print(mydict)       //Output: {'name': 'Max', 'age': 28, 'city': 'New York'}
        
        mydict = dict(name="Max, age=28, city="New York")
        print(mydict)       //Output: {'name': 'Max', 'age': 28, 'city': 'New York'}

    //Accessing
        value = mydict["name"]
        print(value)        //Output: Max

    //Add value to the dictionary
        mydict = {"name": "Max", "age": 28, "city": "New York"}
        mydict["email"] = "max@xyz.com"         //To rewrite, just do the same with different email address
        print(mydict)       //Output: {'name': 'Max', 'age': 28, 'city': 'New York', 'email': 'max@xyz.com'}

    //Delete Dictionary element
        mydict = {"name": "Max", "age": 28, "city": "New York", "email": "max@xyz.com"}
        del mydict["email"]
        print(mydict)       //Output: {'name': 'Max', 'age': 28, 'city': 'New York'}

        mydict.pop("email")
        print(mydict)       //Output: {'name': 'Max', 'age': 28, 'city': 'New York'}    //Same as del

        mydict.popitem()
        print(mydict)       //Output: {'name': 'Max', 'age': 28, 'city': 'New York'}    //Removes the last item (email)

    //Check Key in dictionary
        mydict = {"name": "Max", "age": 28, "city": "New York", "email": "max@xyz.com"}
        if "name" in mydict:
            print(mydict["name"])       //Output: Max

    //Check with Try Except statement
        mydict = {"name": "Max", "age": 28, "city": "New York", "email": "max@xyz.com"}
        try:
            print(mydict["name"])
        except:
            print("Error")      //Output: Max

    //Using For Loop in dictionary
        mydict = {"name": "Max", "age": 28, "city": "New York", "email": "max@xyz.com"}
        for key in mydict:
        #for key in mydict.keys():   //Same as above
            print(key)      //Output: prints name, age, city and email in every line

        for value in mydict:
        #for value in mydict.values():   //Same as above
            print(value)      //Output: prints Max, 28, New York, max@xyz.com in every line

        for key, value in mydict.items()  
            print(key, value)      

    //Copying
        mydict = {"name": "Max", "age": 28, "city": "New York"}
        mydict_copy = mydict
        print(mydict_copy)      //Note that if you modify one, you'll also modify the other

    //Copy/Duplicate
        mydict = {"name": "Max", "age": 28, "city": "New York"}
        mydict_copy = mydict.copy()
        print(mydict_copy)      //Output: Copy of mydict

        mydict_copy = dict(mydict)
        print(mydict_copy)      //Output: Copy of mydict

    //Merging
        mydict1 = {"name": "Max", "age": 28, "city": "New York"}
        mydict2 = {"name": "Max", "age": 28, "email": "max@xyz.com"}
        mydict.update(mydict2)
        print(mydict)       //Output: 'name': 'Max', 'age': 28, 'email': 'max@xyz.com', 'city': 'New York'

    //Using Keys
        mydict = {3: 9, 6: 36, 9: 81}
        value = mydict[3]
        print(value)        //Output: 9

    //Use tuples    - Cant use this method on List
        mytuple = (5, 6)
        mydict = {mytuple: 11}
        print(mydict)   //Output: {(5, 6): 11}
        
////////////////////////////////////////////////////////////////////////
12. Guessing game with While Loop
    //Program
        secret_word = "secret"  //Secret word storage
        guess = ""
        guess_count = 0
        guess_limit = 3
        out_of_guesses = False
        
        while guess != secret_word and not(out_of_guesses):
            if guess_count < guess_limit:
                guess = input("Enter secret word: ")
                guess_count += 1
            else:
                out_of_guesses = True
        if out_of_guesses:
            print("You're out of guesses")
        else:
            print("You Win!")

////////////////////////////////////////////////////////////////////////
13. Exponent Function
    //Program
        def raiseToPower(base_num, pow_num):
            result = 1
            for index in range(pow_num):
                result = result * base_num
            return result
        print(raiseToPower(2, 3)) //Output: 8
    
////////////////////////////////////////////////////////////////////////
14. 2D Lists and Nested Loops
    //2D List Program
        number_grid = [
            [1, 2, 3],
            [4, 5, 6],
            [7, 8, 9],
            [0]
        ]
        print(number_grid[0][0]) //Row, Column, Output: 1

    //Nested For Loop Program
        number_grid = [
            [1, 2, 3],
            [4, 5, 6],
            [7, 8, 9],
            [0]
        ]
        
        for row in number_grid:
            for col in row:
                print(col)      //Output: Prints out numbers in each line starting 1 to 9 to 0

////////////////////////////////////////////////////////////////////////
15. Build Translator
    //Program - Turn any vowels to letter G
        def translate(phrase):
            translation = ""
            for letter in phrase:
                if letter.lower() in "aeiou":
                    if letter.isupper():
                        translation = translation + "G"
                    else:
                        translation = translation + "g"
                else:
                    translation = translation + letter
            return translation

        print(translate(input("Enter a phrase: ")))
        
////////////////////////////////////////////////////////////////////////
16. Comments
    # Ignores a line
    
    '''
    Ignores multiple lines
    '''

////////////////////////////////////////////////////////////////////////
17. Catching Errors, Exceptions, Try-Catch Block
    //Program
        number = int(input("Enter a number: "))
            print(number)
    
    //if you enter a string, Error: invalid literal for int() base 10 and other jibberish will be thrown
    //And the entire program will breaks
    
    //Try Except Block
        try:
            value = 10/0
            number = int(input("Enter a number: "))
                print(number)
        except:
            print("Invalid Input")

    //Now if you enter a string instead of number, "Invalid Input" string will appear
    //Note that the value sting will also be tied up to this single error
    //Note that the Except block being used above is too broad

    //Catching Specific Errors
        try:
            value = 10/0
            number = int(input("Enter a number: "))
                print(number)
        except ZeroDivisionError:
            print("Divided by Zero")
        except ValueError:
            print("Invalid Input")

    //Store Errors as variables
        try:
            value = 10/0
            number = int(input("Enter a number: "))
                print(number)
        except ZeroDivisionError as error:
            print(err)
        except ValueError:
            print("Invalid Input")
            
    //Catch Exceptions
        try:
            a = 5/0 
        except Exception as e:
            print(e)        //Output: division by zero
            
    //Raise Exceptions
        x = -5
        if x < 0:
            raise Exception('x should be positive number')

    //Assert Statement
        x = -5 
        assert (x>=0), 'x is not positive
        
    //Catch ZeroDivision Error, TypeError, Else Clause (if no error occurs), and Finally Clause
        try:
            a = 5 /1 
            b = a + '10'
        except ZeroDivisionError as e:
            print(e)    //Output: Division by Zero
        except TypeError as e:
            print(e)        //Output: unsupported operand type(s) for +: 'float' and 'str'
        else:
            print('Everything is fine')
        finally:
            print('this message runs with or without errors')
            
    //Define own errors by subclassing the base exception class
        class ValueTooHighError(Exception):
            pass
        
        def test_value(x):
            if x > 100:
                raise ValueTooHighError('value too high')
        
        test_value(200) //Output: If Mmore than 100, value too high printed out

    //Define with cleaner error code
        class ValueTooHighError(Exception):
            pass
        
        def test_value(x):
            if x > 100:
                raise ValueTooHighError('value too high')
        
        try:
            test_value(200) 
        except ValueTooHighError as e:
            print(e)
    

    //Add error code
        class ValueTooHighError(Exception):
            pass
        
        class ValueTooSmall(Exception):
            def __init__(self, message, value):
                self.message = message
                self.value = value
        
        def test_value(x):
            if x > 100:
                raise ValueTooHighError('value too high')
            if x <5:
                raise ValueTooSmallError('value is too small', x)
        
        try:
            test_value(1) 
        except ValueTooHighError as e:          //Use test_value(200)
            print(e)
        except ValueTooSmallError as e:         //Use test_value(1)
            print(e.message, e.value)

////////////////////////////////////////////////////////////////////////
18. Reading Files
    //Command
        "r" = read
        "w" = write
        "a" = append, add
        "r+" = read and write
    //Reading Text Files
        open("text.txt", "r") //If the file resides within the same folder
    //Store the contents of the file into a variable
        variable_file = open("text.txt", "r")
    //Close the file
        variable_file.close()
    //Check if the file is readable, outputs true or false
        print(variable_file.readable())
        //Note: The "r" if replaced to "w", it can no longer be read, hence will output False 
    //Prints out all information in the file to the console
        print(variable_file.read())
    //Capture lines within the file and store into an array
        print(variable_file.readlines())
    //Read lines by index
        print(variable_file.readlines()[1])
    //Prints out individual line within the text file
        variable_file = open("text.txt", "r")
        for variable in variable_file.readlines():
            print(variable)
        variable_file.close()

////////////////////////////////////////////////////////////////////////
19. Writing Files
    //Command
        "r" = read
        "w" = write / create new file
        "a" = append, add
        "r+" = read and write
    //Adding line to file
        variable_file = open("text.txt", "a")
        variable_file.write("\nThis is the line to be added to the text file")  //Note the \n for the new line
        variable_file.close()                   
    //Rewrite the entire file
        variable_file = open("text.txt", "w")   //Note: The "w" will turn your file to blank and write the line below
        variable_file.write("\nThis is the line to be added to the text file") 
        variable_file.close()       
    //Advanced method - See Topic 41, Context manager
        with open('text.txt', 'w') as file:
            file.write('action statement')

////////////////////////////////////////////////////////////////////////
20. Modules and Pip
    //Modules  - Using Internal Modules
        //Extracting modules from another python file        
        //File1.py
            import random            
            feet_in_mile = 5000
            meters_in_km = 1000
            band_members = ["Vocals", "Guitarist", "Bassists", "Drummer"]
            def get_file_ext(filename):
                return filename[filename.index(".") + 1:]                
            def roll_dice(num):
                return random.randint(1, num)

        //File2.py
            import File1.py            
            print(File1.roll_dice(10))  //Output: This will roll the dice

    //Modules - Using External Modules
        //https://docs.python.org/3/py-modindex.html - Python Module Index
        //Location of external module 
            External Libraries > Python #.#.# > Lib  > 
        //Program
            import tkinter

    //Using 3rd Party Modules (Pip)
        //Installing
            Open Command prompt
            pip --version //This checks the current version of your Pip
            pip install python-module-name
        //Location of installed module 
            External Libraries > Python #.#.# > Lib  > site-packages
        //After installing, you can access the modules like how you access tkinter module
        //Removing modules
            pip uninstall python-module-name

////////////////////////////////////////////////////////////////////////
21. Classes & Objects
    //student_file.py
        class studentClass:
            def __init__(self, name, major, gpa, probation):       //__init__ is called Dunder/Magic Method. See Topic 43.
                self.name = name
                self.major = major
                self.gpa = gpa
                self.probation = probation

    //main.py
        from student_file import studentClass        //From *file* import *class*
        student1 = studentClass("Jim", "Business", 3.1, False)
        print(student1.name)    //Output: Jim

        //When you create a student, you call the init function of the class
        //self.name is the object, the attribute of the student and it's assigned to the 'name' variable
        
////////////////////////////////////////////////////////////////////////
22. Multiple Choice Quiz
    //main.py
        from question_file import Question
        
        question_prompts = [
            "What color are apples?\n(a) Red/Green\n(b) Purple\n(c) Orange\n\n",
            "What color are bananas?\n(a) Teal\n(b) Magenta\n(c) Yellow\n\n",
            "What color are strawberries?\n(a) Yellow\n(b) Red\n(c) Blue\n\n"
        ]
        
        questions = [                                            //the correct answers
            Questions(question_prompts[0], "a")
            Questions(question_prompts[1], "c")
            Questions(question_prompts[2], "b")
        ]
        
        def run_test(questions):                            //ask to the user
            score = 0
            for question in questions:                       //do something with each question object in questions array
                answer = input(question.prompt)         //input text box for user
                if answer == question.answer:           //check the answer (user input) is similar to the questions that were asked
                    score += 1                                        //increments the score by 1
            print("You got " + str(score) + "/" + str(len(questions)) + "correct")
        
        run_test(questions)
        
    //question_file.py
        class Question:
            def __init__(self, prompt, answer):
                self.prompt = prompt
                self.answer = answer        

////////////////////////////////////////////////////////////////////////
23. Object Functions
    //main.py
        from Student import Student
        
        student1 = Student("Oscar", "Accounting", 3.1)
        student1 = Student("Jack", "Business", 3.2)
        
        print(student2.on_honor_roll()) //Output: True

    //Student.py
        class Student:
            def __init__(self, name, major, gpa):
                self.name = name
                self.major = major
                self.gpa = gpa

            def on_honor_roll(self):
                if self.gpa >= 3.5:
                    return True
                else:
                    return False

////////////////////////////////////////////////////////////////////////
24. Inheritence
    //main.py
        from Chef import Chef
        from ItalianChef_file import ItalianChef
        
        myChef = Chef()
        myChef.make_special_dish()  //Output: Prints outmake bbq ribs
        
        myItalianChef = ItalianChef()
        myItalianChef.make_chicken()    //Output: Prints out makes chicken
        myItalianChef.make_chicken_parmesan()  //Output: Prints out make chicken parmesan
        myItalianChef.make_special_dish() //Output: Prints out make Pizza

    //Chef.py
        class Chef:
            def make_chicken(self):
                print("The chef makes a chicken")
                
            def make_salad(self):
                print("The chef makes a chicken")

            def make_special_dish(self):
                print("The chef makes bbq ribs")

    //ItalianChef_file.py
        from Chef import Chef
        class ItalianChef(Chef) :            

            def make_special_dish(self):
                print("The chef makes a pizza")
            
            def make_chicken_parmesan(self):
                print("The chef makes chicken parmesan")

////////////////////////////////////////////////////////////////////////
25. Interpreter
    //Type python in command prompt
    //You will see ">>>" in command prompt
    //Interpreter translates, compiler converts

////////////////////////////////////////////////////////////////////////
26. Sets
    //Functions, String, Add, Remove, Discard, Clear, Pop, For, If, 
    //Union, Intersections, Differences, Update, Superset, Subset, Disjoint, 
    //Copying, Frozenset
    
    //Unordered, mutable like list and no duplicates
    
    //Basic
        myset = {1, 2, 3, 1, 2, 4}
        print(myset)        //Output: {1, 2, 3, 4}
    
    //Set Function
        myset = set([1, 2, 3])
        print(myset)        //Output: {1, 2, 3}

    //String - Find out how many characters in a word
        myset = set("Hello")
        print(myset)        //Output: {'o', 'l', 'H', 'e'}

    //Careful between sets and dictionaries
        myset = {}
        print(type(myset))  //Output : Class 'dict'
        
    //Create Empty Set
        myset = set()
        print(type(myset))  //Output : Class 'set'

    //Add elements
        myset = set()
        myset.add(1)
        myset.add(2)
        myset.add(3)
        print(myset)  //Output : {1, 2, 3}

    //Remove Elements  - Error if you try to remove non existing element
        myset = {1, 2, 3}
        myset.remove(3)
        print(myset)  //Output : {1, 2}

    //Discard Elements - No error if you try discarding non existing element
        myset = {1, 2, 3}
        myset.discard(3)
        print(myset)  //Output : {1, 2}

    //Empty out the set
        myset.clear()
        
    //Pop
        myset = {1, 2, 3}
        print(myset.pop())      //Output: 1 
        print(myset)            //Output : {2, 3}
        
    //For Loop
        myset = {1, 2, 3}
        for i in myset:
            print(i)        //Output: Prints out element in every line

    //IF ELSE Statement
        myset = {1, 2, 3}
        if 2 in myset:
            print("Yes")
        else:
            print("No")         //Output: Yes

    //Union 
        odds = {1, 3, 5, 7, 9}
        evens = {2, 4, 6, 8}
        primes = {2, 3, 5, 7}

        Union = odds.union(evens)
        print(Union)        //Output: {1,2,3,4,5,6,7,8,9}
   
    //Intersection (Commons)
        odds = {1, 3, 5, 7, 9}
        evens = {2, 4, 6, 8}
        primes = {2, 3, 5, 7}
    
        intersection = odds.intersection(primes)
        print(intersection)     //Output: {3, 5, 7} - Returns only the commons
        
    //Differences
        setA = {1,2,3,4,5,6,7,8,9}
        setB = {1,2,3,10,11,12}
        
        diff1 = setA.difference(setB)
        print(diff1)         //Output: {4,5,6,7,8,9}

        diff2 = setB.difference(setA)
        print(diff2)         //Output: {10,11,12}

        diff3 = setB.symmetric_difference(setA)     -- Combines differences of both sets into a new set
        print(diff3)         //Output: {4,5,6,7,8,9,10,11,12}

    //Update
        setA = {1,2,3,4,5,6,7,8,9}
        setB = {1,2,3,10,11,12}
        
        setA.update(setB)       --Combines and updates without duplication
        print(setA)         //Output: {1,2,3,4,5,6,7,8,9,10,11,12}

        setA.intersection_update(setB)       --Remove the differences between both sets and updates in setA
        print(setA)         //Output: {1,2,3}

        setA.difference_update(setB)       --Remove the similarirites between both sets and updates in setA
        print(setA)         //Output: {4,5,6,7,8,9}
        
        setA.symmetric_difference_update(setB)       --Remove the similarirites between both sets and combines the differences in setA
        print(setA)         //Output: {4,5,6,7,8,9,10,11,12}

    //Superset and Subset
        setA = {1,2,3,4,5,6}
        setB = {1,2,3}
        
        #subset - Are all elements in setA inside setB? Is setA the child of setB
        print(setA.issubset(setB))  //Output: False

        #subset - Are all elements in setB inside setA? Is setB the child of setA
        print(setB.issubset(setA))  //Output: True
        
        #superset - Are all elements in setB inside setA? Is setA the parent of setB
        print(setA.issuperset(setB))  //Output: True
        
        #superset - Are all elements in setA inside setB? Is setB the parent of setA
        print(setB.issuperset(setA))  //Output: False

    //Disjoint
        setA = {1,2,3,4,5,6}
        setB = {1,2,3}
        setC = {7,8}
        
        #Is setA and setB totally different?
        print(setA.isdisjoint(setB))     //Output: False
        
        #Is setA and setC totally different?
        print(setA.isdisjoint(setC))    //Output: True
        
    //Copying - Rules from List still applies
        setA = {1,2,3,4,5,6}
        setB = set(setA)
        print(setB)     //Output: {1,2,3,4,5,6}

    //Frozenset - Cannot change or modified after creation
        a = frozenset([1, 2, 3, 4])
        print(a)        //Output: frozenset([1, 2, 3, 4])

////////////////////////////////////////////////////////////////////////
27. Collections
    //Counter, named Tuple, OrderDict, defaultdict, deque
    
    //Counter is a container for elements as dictionary keys and count the dictionary values
    //Counter
        from collections import Counter
        variable = "aaaabbbccccc"
        
        mycounter = Counter(variable)
        
        print(mycounter)        //Output: Counter({'a':4, 'b':3, 'c':5})
        print(mycounter.items())    //Output: dict_items([('a':4), ('b':,3), ('c':5)])
        print(mycounter.keys())       //Output: dict_keys(['a', 'b', 'c'])
        print(mycounter.values)       //Output: dict_keys([4, 3, 5])
        
        print(mycounter.most_common(1))       //Output: [('c':5)] -- Where 1 is the most common
        print(mycounter.most_common(2))       //Output: [('c':5), ('a':4)] -- Where 1 is the most common
        
        print(mycounter.most_common(1)[0][0])       //Output: c
        print(mycounter.most_common(1)[0][1])       //Output: 5

        print(list(mycounter.elements()))       //Output: ['a','a','a','a','b','b','b','c','c','c','c','c']
    
    //Named Tuple is an object type similar to struct
    //Named Tuple
        from collections import namedtuple
        variablePoint01 = namedtuple('variablePoint01', 'x,y')
        pt = variablePoint01(1, -4)
        print(pt)       //Output:   variablePoint01(x=1, y=-4)
        print(pt.x, pt.y)       //Output:   1 -4

    //Ordered Dictionary is the same as Normal Dictionary only that it follows the time the elements being added
    //This is ONLY for the older version of Python as Python 3.7 and above can do the same thing with Normal Dictionary
    //Ordered  Dictionary
        from collections import OrderedDict
        ordered_dict = OrderedDict()        //Replace 'OrderedDict()' with '{}' for Normal Dictionary
        ordered_dict ['c'] = 3
        ordered_dict ['b'] = 2        
        ordered_dict ['a'] = 1
        ordered_dict ['d'] = 4
        print(ordered_dict)     //Output: OrderedDict([('c',3), ('b',2), ('a', 1), ('d',4)])

    //Default Dictionary has a default value of the keys if they are not being set
    //KeyError will be triggered if its Normal Dictionary being used
    //Default Dictionary
        from collections import defaultdict
        //Replace 'defaultdict()' with '{}' for normal dictionary
        varA = defaultdict(int)     //Default type. 'Int' to return '0', 'float' to return '0.0', 'list' to return '[]'
        varA['a'] = 1
        varA['b'] = 2
        print(varA)         //Output: defaultdict(<class 'int'>, {'a':1, 'b':2})
        print(varA['a'])         //Output: 1
        print(varA['c'])         //Output: 0    //By default, the value is 0

    //Deque is double ended. Can remove elements from both ends.
    //Deque
        from collections import deque
        varA = deque()
        varA.append(1)
        varA.append(2)
        varA.append(3)
        print(varA)     //Output: deque([1, 2, 3])
        
        #add elements to the left
        varA.appendleft(4)      //.appendright for right side
        print(varA)     //Output: deque([4, 1, 2, 3])
        
        #remove element on the left
        varA.popleft()          //.pop() to remove element on the right
        print(varA)     //Output: deque([1, 2, 3])
        
        #remove ALL elements
        varA.clear()
        print(varA)     //Output: deque([ ])

        #extend multiple elements at a time
        varA.extend([4,5,6])      //.extendleft([ ]) to extend on the left => 6,5,4,1,2,3   //Note the reverse order
        print(varA)     //Output: deque([1, 2, 3, 4, 5, 6])
        
        #rotate deque   - move right side element to the left, and negative numbers for opposite
        varA.rotate(1)
        print(varA)     //Output: deque([6, 1, 2, 3, 4, 5])
        
        varA.rotate(2)
        print(varA)     //Output: deque([5, 6, 1, 2, 3, 4])

////////////////////////////////////////////////////////////////////////
28. Iter Tools (Product, Permutations, Combinations, Accumulate, GroupBy, Infinite Iterators)
    //Iterators are data dtypes that can be used in for loops
    
    //Products
        from itertools import product
        a = [1,2]
        b = [3,4]
        prod = product(a,b)     //Reiterate the process twice -- product(a,b, repeat=2)
        print(list(prod))   //Output: [(1, 3), (1, 4), (2, 3), (2, 4)]

    //Permutations - Basic
        from itertools import permutations
        a = [1,2,3]
        perm = permutations(a)
        print(list(perm))       //Output: [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]

    //Permutations - Sorting with Length
        from itertools import permutations
        a = [1,2,3]
        perm = permutations(a, 2)
        print(list(perm))       //Output: [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]

    //Combinations
        from itertools import combinations
        a = [1,2,3]
        comb = combinations(a, 2)
        print(list(comb))       //Output: [(1, 2), (1, 3), (2, 3)]

    //Combinations with replacement
        from itertools import combinations, combinations_with_replacement
        a = [1,2,3]
        comb_wr = combinations_with_replacement(a, 2)
        print(list(comb_wr))       //Output: [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]

    //Accumulate - Returns by adding
        from itertools import accumulate
        a = [1,2,3,4]
        acc = accumulate(a)
        print(list(acc))       //Output: [1, 3, 6, 10]

    //Accumulate - Returns by multiplication
        from itertools import accumulate
        import operator
        a = [1,2,3,4]
        acc = accumulate(a, func=operator.mul)
        print(list(acc))       //Output: [1, 2, 6, 24]

    //Accumulate - Returns by max number
        from itertools import accumulate
        a = [1,2,5,3,4,6]
        acc = accumulate(a, func=max)
        print(list(acc))       //Output: [1, 2, 5, 5, 5, 6]     //(1,1=1) (1,2=2) (2,5=5) (5,3=5) (5,4=5) (5,6=6)
        //This finds the max number between a group of 2 numbers
        
    //Groupby
        //To group together if value is smaller than 4
        from itertools import groupby
        def smallerThan4Variable(x):
            return x < 4
        
        a = [1, 2, 3, 4, 5, 6]
        group_obj = groupby(a, key=smallerThan4Variable)
        print(group_obj)        //Output1: <itertools.groupby object at 0x000000000239A288>
        
        for key, value in group_obj:
            print(key, value)   //Output2: True<Output1> && False<Output1>
            print(key, list(value))     Output3: True [1, 2, 3] && False [4, 5, 6]
            
    //Groupby VS Lambda Functions - Only shorter code than Groupby
        from itertools import groupby        
        a = [1, 2, 3, 4, 5, 6]
        group_obj = groupby(a, key=lambda x: x<4)
        print(group_obj) 
        for key, value in group_obj:
            print(key, list(value))  //Output: Similar with GroupBy
            
    //Groupby VS Lambda Functions (Extensive) - Only shorter code than Groupby
        from itertools import groupby        
        
        persons = [{'name': 'Tim', 'age': 25}, {'name': 'Dan', 'age': 25}, {'name': 'Lisa', 'age': 28}, {'name': 'Claire', 'age': 23}]
        
        group_obj = groupby(a, key=lambda x: x['age'])
        print(group_obj) 
        for key, value in group_obj:
            print(key, list(value))  
        //Output: """
            25 [{'name': 'Tim', 'age': 25}, {'name': 'Dan', 'age': 25}]
            28 [{'name': 'Lisa', 'age': 28}]
            23 [{'name': 'Claire', 'age': 23}]
        """

    //Infinite Iterators
        from itertools import count, cycle, repeat

        #count function
        for i in count(10):         //10 is the start value
            print(i)        //Output: An infinite loop that starts at 10
            if i == 15:     //This only stops the loop cycle
                break

        #cycle
        a = [1,2,3]
        for i in cycle(a)
            print(i)        //Output: Cycles 123 123 123 continuously

        #repeat
        a = [1,2,3]
        for i in repeat(1)
            print(i)        //Output: Cycles 1111111 continuously
            
        #repeat 4 times
        a = [1,2,3]
        for i in repeat(1, 4)   //4 means repeat 4 times
            print(i)        //Output: 1111

////////////////////////////////////////////////////////////////////////
29. Lambda Functions
    //A small one line anonymous function defined without a name
    //Lambda argument: expression
    //Creates a function with an argument and this will evaluate the expression to return a result
    
    //Basic
        var10 = lambda varX: varX + 10
        print(var10(5))     //Output: 15 (If varX = 5, then 5+10 = 15)

    //The basic is similar to:
        def var10_func(var20):
            return var20 + 10
        print(var10_func(5))        //Output: 15

    //Multiplication
        varA = lambda varX, varY: varX * varY   
        print(varA(5,3))        //Output: 15

    //Function that take in another function
        //Sorted - Without Lambda
            varA = [(1,2),(15,1),(5,-1),(10,4)]
            varA_sorted = sorted(varA)
            
            print(varA)
            print(varA_sorted)  
                //Outputs:
                //[(1, 2), (15, 1), (5, -1), (10, 4)]      -- varA
                //[(1, 2), (5, -1), (10, 4), (15, 1)]      -- varA_sorted

        //Sorted - Another method without Lambda
            varA = [(1,2),(15,1),(5,-1),(10,4)]
            def sort_by_A(x):
                return x[0]                 //(0 = x-index), (1=y-index)
            varA_sorted = sorted(varA, key=sort_by_A)  
            
            print(varA)
            print(varA_sorted)  
                //Outputs:
                //[(1, 2), (15, 1), (5, -1), (10, 4)]      -- varA
                //[(1, 2), (5, -1), (10, 4), (15, 1)]      -- varA_sorted
                        
        //Sorted - With Lambda by index 0
            varA = [(1,2),(15,1),(5,-1),(10,4)]
            varA_sorted = sorted(varA, key=lambda varX: varX[0])  //(0 = x-index), (1=y-index)
            
            print(varA)
            print(varA_sorted)  
                //Outputs:
                //[(1, 2), (15, 1), (5, -1), (10, 4)]      -- varA
                //[(1, 2), (5, -1), (10, 4), (15, 1)]      -- varA_sorted

        //Sorted - With Lambda by sum of index 0 and index 1
            varA = [(1,2),(15,1),(5,-1),(10,4)]
            varA_sorted = sorted(varA, key=lambda varX: varX[0] + varX[1])  //(0 = x-index), (1=y-index)
            
            print(varA)
            print(varA_sorted)  
                //Outputs:
                //[(1, 2), (15, 1), (5, -1), (10, 4)]      -- varA
                //[(1, 2), (5, -1), (10, 4), (15, 1)]      -- varA_sorted

    //Map Function
        #map(func, seq)
        //Multiply by 2 without Lambda bu twith List Comprehension
        a = [1, 2, 3, 4, 5]
        b =[x*2 for x in a]
        print(b)        
        
        //Multiply by 2 with Lambda function
        a = [1, 2, 3, 4, 5]
        b = map(lambda x: x*2, a)
        print(b)

    //Filter Function
        #filter(func, seq)
        #With
        a = [1, 2, 3, 4, 5, 6]
        b = filter(lambda x: x%2==0, a)
        print(list(b))      //Output: 2, 4, 6
        
        #Without
        a = [1, 2, 3, 4, 5]
        c = [x for x in a if x%2==0]
        print(c)

    //Reduce
        from functools import reduce
        a = [1, 2, 3, 4]
        product_a = reduce(labda x,y: x*y, a)
        print(product_a) //Output: 24  (Multiply all the numbers in the list)

////////////////////////////////////////////////////////////////////////
30. Logging - Error Messages (Ctd from Topic 17) - Logging to different levels

        //Basic Only Warning, Error and critical gets printed out
            import logging
            logging.debug('This is a debug message')
            logging.info('This is an info message')
            logging.warning('This is a warning message')
            logging.error('This is an error message')
            logging.critical('This is a critical message')

        //Printing all levels - Root Logger
                #https://docs.python.org/3/library/logging.html#logging.basicConfig
                #https://docs.python.org/3/library/logging.html#logercord-attributes
                #https://docs.python.org/3/library/logging.html#time.strftime
            import logging
            logging.basicConfig(
                level=logging.DEBUG, 
                format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', 
                datefmt='%m/%d/%Y %H:%M:%S'
            )
            logging.debug('This is a debug message')
            logging.info('This is an info message')
            logging.warning('This is a warning message')
            logging.error('This is an error message')
            logging.critical('This is a critical message')

        //Creating your own logger - But Message will show at start
            //main.py
                import logging
                logging.basicConfig(
                    level=logging.DEBUG, 
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', 
                    datefmt='%m/%d/%Y %H:%M:%S'
                )
                import logger
                
            //logger.py
                import logging
                logger = logging.getlogger(__name__)    //Where __name__ is a global variable
                logger.info('hello from logger')
            
        //Creating your own logger - Without error message being shown at start (Propagate Off)
            //main.py
                import logging
                logging.basicConfig(
                    level=logging.DEBUG, 
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s, 
                    datefmt='%m/%d/%Y %H:%M:%S'
                )
                import logger
                
            //logger.py
                import logging
                logger = logging.getlogger(__name__)    //Where __name__ is a global variable
                logger.propagate = False
                logger.info('hello from logger')
    
        //Log Handlers
            //Save messages to a log handler file (file.log)
            
            import logging
            logger = logging.getlogger(__name__)
            
            #create handler
            stream_h = logging.StreamHandler()
            file_h = logging.FileHandler('file.log')
            
            #Set level and format
            stream_h.setLevel(logging.WARNING)
            file_h.setLevel(logging.ERROR)
            
            formatterVar = logging.Formatter('%(name)s - %(levelname)s - %(message)s')
            
            #set formatter to handler
            stream_h.setFormatter(formatterVar)
            file_h.setFormatter(formatterVar)
            
            #set handler to logger
            logger.addHandler(stream_h)
            logger.addHandler(file_h)
            
            #Text
            logger.warning('this is a warning')
            logger.error('this is an error')
                
        //Using Logging Config files
            //logging.conf
                [loggers]
                keys=root,simpleExample
                
                [handlers]
                keys=consoleHandler
                
                [formatters]
                keys=simpleFormatter
                
                [logger_root]
                level=DEBUG
                handlers=consoleHandler
                
                [logger_simpleExample]
                level=DEBUG
                handlers=consoleHandler
                qualname=simpleExample
                propagate=0
                
                [handler_consoleHandler]
                class=StreamHandler
                level=DEBUG
                formatter=simpleFormatter
                args=(sys.stdout,)
                
                [formatter_simpleFormatter]
                format=%(asctime)s - %(name)s - %(levelname)s - %(message)s
            
            //main.py
                import logging
                import logging.config
                
                #Set logging.conf as the file
                logging.config.fileConfig('logging.conf')
                
                logger = logging.getlogger('simpleExample')     //Use qualname
                logger.debug('this is a debug message')
                
        //Dictionary Config
            #https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig
            #Similar to above but use .dictConfig() instead of .fileConfig()
            #follow the link for the logging.conf formatting

        //Capture StackTraces - Good for troubleshooting
            import logging
            try:
                a = [1,2,3]
                val = a[4]      //Note that the value is too large
            except IndexError as e:
                //logging.error(e)    //Output: ERROR root list index out of range
                logging.error(e, exc_info=True) //Output: Includes the stack trace in the logger

        //Capture everything in Traceback
            import logging
            import traceback
            
            try:
                a = [1,2,3]
                val = a[4]    
            except IndexError as e:
                logging.error("The error is %s", traceback.format_exc()) 

        //Rotating file handler - 
            //To recording error messages for large application with alot of preset log messages
            import logging
            from logging.handlers import RotatingFileHandler
            
            #Create Logger
            logger = logging.getLogger(__name__)
            
            #Set Log Level
            logger.setLevel(logging.INFO)

            #Create file handling system that rotates over after 2kb, 
            #Keep backup logs as app.log.1, app.log.2, etc           
            handler = RotatingFileHandler('app.log', maxBytes=2000, backupCount=5)
            
            #Add handler to Logger
            logger.addHandler(handler)
            
            for _ in range(10000)
                logger.info('Hello')

        //Time based rotating file handler
            //Similar to Rotating file handler
            import logging
            import time
            from logging.handlers import TimedRotatingFileHandler
            
            #Create Logger
            logger = logging.getLogger(__name__)
            
            #Set Log Level
            logger.setLevel(logging.INFO)

            #Create file handling system that rotates over after 2kb, 
            #Keep backup logs as app.log.1, app.log.2, etc        
            #when = '(s=seconds, m=mins, h=hours, d=day, midnight, w0=monday, w1=tuesday, wn=etc)'     
                when=s, interval=5 means every 5 seconds
            handler = TimedRotatingFileHandler('timed_test.log', when='s', interval=5, backupCount=5)
            
            #Add handler to Logger
            logger.addHandler(handler)
            
            for _ in range(6)
                logger.info('Hello')
                
                #To wait specific amount of time
                time.sleep(5)   //Sleep 5 seconds

        //JSON Logger
            https://github.com/madzak/python-json-logger

////////////////////////////////////////////////////////////////////////
31 JSON
    //Looks similar to Python Dictionay
    //Entire conversion table: https://www.python-engineer.com/learn/advancedpython11_json    
    //Conversion Python to JSON
        Python              JSON
        dict                   object
        list, tuple          array
        str                     string
        int, long, float   number
        True, False        true, false
        None                 null        
    
    //example.json
        {
            "firstName": "Jane"
            "lastName": "Doe"
            "hobbies": ["running", "swimming", "singing"],
            "age": 28,
            "hasChildren": true,
            "children": [
                {
                    "firstName": "Alex"
                    "age": 5
                },
                {
                    "firstName": "Bob"
                    "age": 7
                }
            ]
        }

    //Convert Python to JSON aka Serialization
        //main.py
            import json
            person = {
                "name": "John",
                "age": 30,
                "city": "New York",
                "hasChildren": False,
                "titles": ["engineer", "programmer"]
            }
            personJSONVariable = json.dumps(person) //dumps = string, dump = save
            print(personJSONVariable)

            #For better view layout
            personJSONVariable = json.dumps(person, indent=4)

            #To replace the seperators in JSON
            personJSONVariable = json.dumps(person, indent=4, separators=('; ', '= '))

            #Sort alphabetically
            personJSONVariable = json.dumps(person, indent=4, separators=('; ', '= '), sort_keys=True)

            #Save into a file,  dumps = string, dump = save
            with open('person.json', 'w') as file:
                json.dump(person, file, indent=4)

    //Convert JSON to Python aka Deserialization, via Variable
        //main.py
            import json
            person = {
                "name": "John",
                "age": 30,
                "city": "New York",
                "hasChildren": False,
                "titles": ["engineer", "programmer"]
            }
            personJSONVariable = json.dumps(person) //dumps = string, dump = save
            #print(personJSONVariable)

            person = json.loads(personJSON)
            print(person)

    //Convert JSON to Python, via JSON File
        //person.json
            #file have to be available in the folder
            
        //main.py
            import json
            person = {
                "name": "John",
                "age": 30,
                "city": "New York",
                "hasChildren": False,
                "titles": ["engineer", "programmer"]
            }
            personJSONVariable = json.dumps(person)
            #print(personJSONVariable)
            
            with open('person.json', 'r') as file:
                person = json.load(file)
                print(person)

    //Working with dictionary - Encode (Dict to JSON) and Decode (JSON to Dict)
        //main.py   - This will cause Type Error
            import json
            class User:
                def __init__(self, name, age):
                    self.name = name
                    self.age = age
            user = User('Max', 27)
            userJSON = json.dumps(user)

        //main.py   - Solution #1
            import json
            class User:
                def __init__(self, name, age):
                    self.name = name
                    self.age = age
            user = User('Max', 27)
            
            def encode_user(o):
                if isinstance(o, User):
                    return {'name': o.name, 'age': o.age, o.__class__.__name__: True}
                else:
                    raise TypeError('Object of type User is not JSON serializable')
            userJSON = json.dumps(user, default=encode_user)
            print(userJSON)
    
        //main.py   - Solution #2
            import json
            class User:
                def __init__(self, name, age):
                    self.name = name
                    self.age = age
            user = User('Max', 27)
            
            //Encoding
            def encode_user(o):
                if isinstance(o, User):
                    return {'name': o.name, 'age': o.age, o.__class__.__name__: True}
                else:
                    raise TypeError('Object of type User is not JSON serializable')

            from json import JSONEncoder
            class UserEncoder(JSONEncoder):
                def default(self, o):
                    if isinstance(o, User):
                        return {'name': o.name, 'age': o.age, o.__class__.__name__: True}
                    return JSONEncoder.default(self, o)
            
            userJSON = json.dumps(user, cls=UserEncoder)
            #Alternative, userJSON = UserEncoder().encode(user)
            print(userJSON)
            
            //Decoding            
            def decode_user(dct):
                if User.__name__ in dct:
                    return User(name=dct['name'], age=dct['age'])
                return dct
                
            #user = json.loads(userJSON)
            user = json.loads(userJSON, object_hook=decode_user)
            print(user.name)

////////////////////////////////////////////////////////////////////////
32 Random Numbers
    //main.py - Random
        import random
        
        #random float in the range of 0 to 1
            a = random.random()

        #uniform float in specific range, upper range not included
            a = random.uniform(1, 10)   //Float range 1 to 10 and 10 is not included
        
        #Random integers - exclude upper range
            a = random.randrange(1, 10)

        #Random integers - includes upper range
            a = random.randint(1, 10) 

        #Normal Variate (mu, sigma) - for statistics, float number
            a = random.normalvariate(0, 1)

        #random choice
            mylist = list("ABCDEFGH")
            a = random.choice(mylist)

        #More choices
            mylist = list("ABCDEFGH")
            a = random.sample(mylist, 3)    //picks 3 elements

        #For elements to be picked multiple times
            mylist = list("ABCDEFGH")
            a = random.choices(mylist, k=3) 

        #Random shuffle
            mylist = list("ABCDEFGH")
            random.shuffle(mylist)
            print(mylist)

            #Reusing the same random number 
            random.seed(1)
            print(random.random())
            print(random.randint(1,10))
            
            random.seed(2)
            print(random.random())
            print(random.randint(1,10))
            
            random.seed(1)
            print(random.random())
            print(random.randint(1,10))
            
            random.seed(2)
            print(random.random())
            print(random.randint(1,10))

    //main.py - Secrets
        //Random number with security (passwords, authentication, tokens)
        import secrets
        
        #Random Below - Excludes upper range
        a = secrets.randbelow(10)

        #Random Bits
        a = secrets.randbits(4) //4 bits, 0000(0) to 1111(15)

        #Secret Choice
        mylist = list("ABCDEFGH")
        a = secrets.choice(mylist)

    //main.py - Secrets with Numpy
        import numpy as np

        #array with random floats
        a = np.random.rand(3)    //3 elements(columns) with 1 dimension(row)
        a = np.random.rand(3, 3) //3 columns, 3 rows

        #array with random int
        a = np.random.randint(0, 10, 3) //Where 3 is the column
        
        #array with random int (tuple)
        a = np.random.randint(0, 10, (3,4)) //Where 3 is column and 4 is number in each column

        #random shuffle with secrets and numpy
        arr = np.array([[1,2,3], [4,5,6], [7,8,9]])
        print(arr)      //Before shuffle
        np.random.shuffle(arr)
        print(arr)      //After shuffle

        #numpy seed function
        np.random.seed(1)
        print(np.random.rand(3,3)) 
        np.random.seed(1)
        print(np.random.rand(3,3)) 


////////////////////////////////////////////////////////////////////////
33. Decorators  - Basic, Arguments, Function Identities, Repeating, Nested, Class, Decorator with Timer
    //Inner function within inner function
    
    //No Decorator
        def startEndDecorator(func):
            def wrapper():
                print('Start')
                func()
                print('End')
            return wrapper
        
        def printName1():
            print('Alex')
        
        printName = startEndDecorator(printName1)
        printName()     //Output: Prints Start, Alex and End
        printName1()     //Output: Prints Alex

    //Basic Decorator
        def startEndDecorator(func):
            def wrapper():
                print('Start')
                func()
                print('End')
            return wrapper
        
        @startEndDecorator
        def printName1():
            print('Alex')
        
        printName1()     //Output: Prints Start, Alex and End

    //Decorator with argument initialization
        //wrapper nd function needs the argument initialization
        
        def startEndDecorator(func):
            def wrapper(*args, **kwargs):
                print('Start')
                result = func(*args, **kwargs)
                print('End')
                return result
            return wrapper
        
        @startEndDecorator
        def add5(x):
            return x + 5
        
        result1 = add5(10)
        print(result1)

    //Decorators without Function Identities
        def startEndDecorator(func):
            def wrapper(*args, **kwargs):
                print('Start')
                result = func(*args, **kwargs)
                print('End')
                return result
            return wrapper
        
        @startEndDecorator
        def add5(x):
            return x + 5
        
        print(help(add5))
        print(add5.__name__)    //Outputs the wrapper function

    //Decorators with Function Identities
        import functools                
        def startEndDecorator(func):            
            @functools.wraps(func)
            def wrapper(*args, **kwargs):
                print('Start')
                result = func(*args, **kwargs)
                print('End')
                return result
            return wrapper
        
        @startEndDecorator
        def add5(x):
            return x + 5
        
        print(help(add5))
        print(add5.__name__)    //Outputs the add5 function

    //Repeating decorators
        import functools
        def repeat(numTimes):
            def repeatingDecorator(func):
                @functools.wraps(func)
                def wrapper(*args, **kwargs):
                    for _ in range(numTimes):
                        result = func(*args, **kwargs)
                    return result
                return wrapper
            return repeatingDecorator
            
        @repeat(numTimes=3)
        def greet(name):
            print(f'Hello {name}')
        greet('Izaat')

    //Nested Decorators
        //Stack decorators on top of each other
        //Executes in the order they were listed
        
        import functools
        
        def startEndDecorator(func):            
            @functools.wraps(func)
            def wrapper(*args, **kwargs):
                print('startEndDecorator - Start')
                result = func(*args, **kwargs)
                print('startEndDecorator - End')
                return result
            return wrapper
        
        def debug(func):
            #extracts the name, arguments and keyword arguments
            #prints the calling function
            #executes the function
            #prints out the return information
            @functools.wraps(func)                            
            def wrapper(*args, **kwargs):   
                args_repr = [repr(a) for a in args]
                kwargs_repr = [f"{k}={v!r}" for k, v in kwargs.items()]
                signature = ", ".join(args_repr + kwargs_repr)
                print(f"Calling {func.__name__}({signature})")      #Prints out Calling sayHello('Izaat')
                result = func(*args, **kwargs)
                print(f"{func.__name__!r} returned {result!r}")     #Prints out 'sayHello returned Izaat'
                return result                
            return wrapper
        
        @debug
        @startEndDecorator
        def sayHello(name):
            greeting = f'Hello {name}'
            print(greeting)
            return greeting
        sayHello('Izaat')

    //Class Decorators
        //Keep track of how many times its being executed
        //Basic Structure
            class CountCalls:
                def __init__(self, func):
                    self.func = func
                    self.num_calls = 0
                    
                def __call__(self, *args, **kwargs):
                    print('Hi there')
                
            cc = CountCalls(None)
            cc()

            @CountCalls
            def sayHello():
                print('Hello')

        //Updating the state
            class CountCalls:
                def __init__(self, func):
                    self.func = func
                    self.num_calls = 0
                    
                def __call__(self, *args, **kwargs):
                    self.num_calls += 1
                    print(f'This is executed {self.num_calls} times')
                    return self.func(*args, **kwargs)
                
            @CountCalls
            def sayHello():
                print('Hello')

            sayHello()  //Output: This is executed 1 time
            sayHello()  //Output: This is executed 2 times
          
    //Decorator with Timer (Debugging tool to check time)
        import time
        def timer(func):
            def wrapper(*args, **kwargs):
                start = time.time()
                rv = func()
                total = time.time() - start
                print("Time:", total)
                return rv
            return wrapper
        
        @timer          //you can just paste this line into any function without modifying the code
        def test():
            for _ in range(1000):
                pass
        test()

////////////////////////////////////////////////////////////////////////
34. Generators
    //Memory efficient when you work with large data
    
    //Basic
        def mygen():
            yield 1
            yield 2
            yield 3
        g = mygen()
        
        #get all values
        for i in g:
            print(i)
            
        #get one value at a time
        value = next(g)
        print(value)    //Output: 1
        
        value = next(g)
        print(value)    //Output: 2

    //Iterations - Basics
        def mygen():
            yield 1
            yield 2
            yield 3
        g = mygen()
        
        #Calculation
        print(sum(g))
        
        #Sorting
        print(sorted(g))

    //Iterations - Counting down
        def countdown(num):
            print('Start')  #note that this line will not be printed
            while num > 0:
                yield num
                num -= 1
        cd = countdown(4)
        value = next(cd)
        print(value)            #Output: 4

        #activates the loop
        print(next(cd))         #Output: 3
        print(next(cd))         #Output: 2

    //Working with data - Without Generator
        import sys
        def firstn(n):
            numList = []
            numInt = 0
            while numInt < n:
                numList.append(numInt)
                numInt += 1
            return numList

        print(firstn(10))               #Print numbers 0 to 9 in a list
        print(sum(firstn(10)))      #Print 45
        print(sys.getsizeof(firstn(1000000)))    #Output: 8,697,464 bytes

    //Working with data - With Generator
        //numList not included
        //numList not being used here to save memory
        import sys
        def firstn_generator(n):
            numInt = 0
            while numInt < n:
                yield numInt
                numInt += 1

        print(firstn_generator(10))               #Print numbers 0 to 9 in a list
        print(sum(firstn_generator(10)))      #Print 45
        print(sys.getsizeof(firstn_generator(1000000))) #Output: 120 bytes

    //Fibonacci Sequence
        #Adding up all numbers in ascending order
        def fibonacci(limit):            
            
            #Storage
            a, b = 0, 1
            
            while a < limit:
                yield a
                a, b = b, a+b
                    #Sequence
                    #a becomes b, b becomes a+b

        fib = fibonacci(30)
            #30 is the limit
        
        for i in fib:
            print(i)


    //Generator Expression
        //Works like list comprehension but with parentheses instead of square brackets
        
        #List version
        import sys
        mylist = [i for i in range(10) if i % 2 == 0]
        print(mylist)
        print(sys.getsizeof(mylist))  #Change range to 100,000 to get 406496 bytes
        
        #Generator version
        import sys
        mygen = (i for i in range(10) if i % 2 == 0)
        print(mygen)
        print(sys.getsizeof(mygen))   #Change range to 100,000 to get 120 bytes

        #Convert Generator to List
        mygen = (i for i in range(10) if i % 2 == 0)
        print(list(mygen))


////////////////////////////////////////////////////////////////////////
35. Threading & Processing
    //Run codes in parallel to speed up code
        #Process:
            #Python Interpreter
            #+Takes advantage of multiple CPU and cores
            #+Memory is not shared between processes
            #+Processes can start independently from other processes
            #+Processes are interruptable/killable
            #+Avoids the GIL Limitations
            #-Starting a process is slower than starting a thread
            #-Inter Process Communication (sharing memory between processes) is complicated
            #-Despite seperate memory, it requires alot of memory collectively            

        #Threads:
            #+An entity or entities within a process that can be scheduled
            #+All threads within a process share the same memory
            #+Starting a thread is faster than starting a process
            #+Good for I/O bound task - Communicating with hardware drivers and other devices
            #-Not interruptable/killable
            #-The GIL Limits one thread at a time

    //Processing
        from multiprocessing import Process
        import os
        import time
        
        #Dummy function
        def square_numbers():
            for i in range(100):
                i * i
                time.sleep(0.1)
        
        processesList = []    #Place to store the processes
        processesVar =  os.cpu_count()         #Number of CPUs in your machine

        #Create processes
        for i in range(processesVar):
            p = Process(target=square_numbers)      #target is for the function            
            processesList.append(p)

        #Start the process
        for p in processesList:
            p.start()

        #Join the process. 
        for p in processesList:
            p.join()            #This will wait for the processes to finish. And while waiting, it will block the main thread
        print('end main')

        #Before running the code, check task manager and look for 'python' to see the current activity
            #There will be 2 Python process running, each with different Process ID (PID)
        #Run the code and check the task manager again
            #There will be about extra 5 processes with single thread running after execution

    //Threading
        from threading import Thread
        import os
        import time
        
        #Dummy function
        def square_numbers():
            for i in range(100):
                i * i
                time.sleep(0.1)
        
        threadsList = []    #Place to store the threads
        threadsVar =  10 

        #Create processes
        for i in range(threadsVar):
            t = Thread(target=square_numbers)      #target is for the function            
            threadsList.append(t)

        #Start the process
        for t in threadsList:
            t.start()

        #Join the process. 
        for t in threadsList:
            t.join()            #This will wait for the processes to finish. And while waiting, it will block the main thread
        print('end main')

        #Before running the code, check task manager and look for 'python' to see the current activity
            #There will be 2 Python process running, each with different Process ID (PID)
        #Run the code and check the task manager again
            #There will be about extra 1 process with 11 threads running after execution

////////////////////////////////////////////////////////////////////////
36. Multithreading - Sharing, Locking, Queueing
    //Basic
        from threading import Thread
        import os        
        
        #Dummy function
        def square_numbers():
            for i in range(100):
                i * i                
        
        if __name__ == "__main__":
            threadsList = []    #Place to store the threads
            threadsVar =  10 

            #Create threads
            for i in range(threadsVar):
                t = Thread(target=square_numbers)      #target is for the function            
                threadsList.append(t)

            #Start the threads
            for t in threadsList:
                t.start()

            #Join the thread 
            for t in threadsList:
                t.join()            #This will wait for the threads to finish. And while waiting, it will block the main thread
                
            print('end main')

    //Sharing Data between threads WITHOUT Lock object
        from threading import Thread
        import time
        
        #Define a global variable to simulate a database
        database_value = 0
        
        #Increase method
        def increase():
            global database_value
            
            #Dummy code to simulate database access
            #Get value from database and store into a local copy
            local_copy = database_value
            
            #Processing
            local_copy += 1
            
            #Time to wait
            time.sleep(0.1)     //This switches the process to another thread
            
            #Write value back to the database
            database_value = local_copy

        if __name__ == "__main__":
            print('start value', database_value)
            
            #Create Thread #1
            thread1 = Thread(target=increase)
            
            #Create Thread #2
            thread2 = Thread(target=increase)
            
            #Start the thread
            thread1.start()
            thread2.start()
            
            #Join the thread
            thread1.join()
            thread2.join()
            
            print('end value', database_value)
            print('end main')

        //Output: start = 0, end = 1
            #The end value is 1 because it writes the second thread as 1 instead of 2 
            #The both threads, with value of 1 writes to the database as '1'

    //Sharing Data between threads WITH Lock object
        from threading import Thread, Lock
        import time
        
        #Define a global variable to simulate a database
        database_value = 0
        
        #Increase method with a lock
        def increase(lock):
            global database_value
            
            #To prevent access with the lock
            lock.acquire()
            
            #Dummy code to simulate database access
            #Get value from database and store into a local copy
            local_copy = database_value
            
            #Processing
            local_copy += 1
            
            #Time to wait
            time.sleep(0.1)     //This switches the process to another thread
            
            #Write value back to the database
            database_value = local_copy
            
            #Release Lock
            lock.release()

        if __name__ == "__main__":
            #Create a lock
            lock = Lock()
        
            print('start value', database_value)
            
            #Create Thread #1
            thread1 = Thread(target=increase, args=(lock,)) #Comma to let python know it is a tuple
            
            #Create Thread #2
            thread2 = Thread(target=increase, args=(lock,))
            
            #Start the thread
            thread1.start()
            thread2.start()
            
            #Join the thread
            thread1.join()
            thread2.join()
            
            print('end value', database_value)
            print('end main')

        //Output: start = 0, end = 2
            #The end value is 2 because when the code reaches the shifting to thread2, the code state is locked 
            #This enables the new database to be written as 1, preventing thread2 to retrieve value 0
            #Once database value is set to 1, the lock is released, enabling thread2 to retrieve the new updated value 1
            
    //Sharing Data between threads WITH Lock object - BETTER WAY TO LOCK
        from threading import Thread, Lock
        import time

        database_value = 0
        
        def increase(lock):
            global database_value
            with lock:                                  //Use this as better way to lock codes
                local_copy = database_value
                local_copy += 1
                time.sleep(0.1)
                database_value = local_copy

        if __name__ == "__main__":
            lock = Lock()
        
            print('start value', database_value)
            thread1 = Thread(target=increase, args=(lock,))
            thread2 = Thread(target=increase, args=(lock,))
            thread1.start()
            thread2.start()
            thread1.join()
            thread2.join()
            
            print('end value', database_value)
            print('end main')

    //Queueing
        //Basics
            from threading import Thread, Lock
            from queue import Queue
            import time

            if __name__ == "__main__":
                
                #Create queue
                q = Queue()
                
                #Adding objects into the queue
                #It adds from the left, pushing the existing to the right
                q.put(1)
                q.put(2)
                q.put(3)
                
                #Retrieve queue - This retrieves object from the right
                #3, 2, 1 Direction --> 
                first = q.get()     //This has similarities with *.pop(), by removing the value
                Print(first)        //Output: 1.     //Now the Queue contains 2 and 3                

                print('End Main')

        //Others
            #Check if queue is empty
            q.empty()   -   returns true or false
        
            #End task - To be used in threading environment
            q.task_done()
                
            #Join method - Blocks and wait for elements to complete
            q.join()
            
            #Daemon
            #Daemon will run in the background 
            #It will stop when after the main thread stops running
            #Applicable to kill infinite loops
            #Similar to having a 'break' within a function
            thread.daemon = True                

        //Example - Structure with Locks
            from threading import Thread, Lock, current_thread
            from queue import Queue
            import time
            
            #Define function
            def worker(q, lock):
                while True:
                    value = q.get()
                    
                    with lock:
                        #processing - print the value
                        print(f'in {current_thread().name} got {value}')
                    
                    #Ends the task
                    q.task_done()

            if __name__ == "__main__":
                
                q = Queue()
                
                lock = Lock()
                
                #Define threads
                threadsVar = 10
                for i in range(threadsVar):
                    thread = Thread(target=worker, args=(q, lock))  #target = function
                    thread.daemon = True
                    thread.start()                

                #Fill queue with objects, number 1 to 20
                for i in range(1, 21):
                    q.put(i)
                    
                #block and wait
                q.join()

                print('end main')


////////////////////////////////////////////////////////////////////////
37. Multiprocessing - Sharing, Locking, Queueing, Process Pool
    //Basic
        from multiprocessing import Process
        import os        
        
        #Dummy function
        def square_numbers():
            for i in range(100):
                i * i                
        
        if __name__ == "__main__":
            processesList = []    #Place to store the processes
            processesVar =  os.cpu_count() 

            #Create processes
            for i in range(processesVar):
                p = Process(target=square_numbers)      #target is for the function            
                processesList.append(t)

            #Start the processes
            for p in processesList:
                p.start()

            #Join the processes
            for p in processesList:
                p.join()            #This will wait for the processes to finish while blocking the program to continue. 
                
            print('end main')

    //Share data between processes WITHOUT LOCK
        from multiprocessing import Process, Value, Array
        import time   
        
        #Dummy function
        def add_100(number):
            for i in range(100):
                time.sleep(0.01)
                number.value += 1           
        
        if __name__ == "__main__":
            #Shared memory
            shared_number = Value('i', 0)
            print('Number at the beginning is ', shared_number.value)
            
            p1 = Process(target=add_100, args=(shared_number,))
            p2 = Process(target=add_100, args=(shared_number,))
            
            p1.start()
            p2.start()
            
            p1.join()
            p2.join()
            
            print('number at the end in ', shared_number.value)               
            print('end main')

    //Share data between processes WITH LOCK
        from multiprocessing import Process, Value, Array, Lock
        import time   
        
        #Dummy function
        def add_100(number, lock):
            for i in range(100):
                time.sleep(0.01)
                with lock:                    
                    number.value += 1                          
        
        if __name__ == "__main__":
        
            #Create lock object
            lock = Lock()
        
            #Shared memory
            shared_number = Value('i', 0)
            print('Number at the beginning is ', shared_number.value)
            
            p1 = Process(target=add_100, args=(shared_number, lock))
            p2 = Process(target=add_100, args=(shared_number, lock))
            
            p1.start()
            p2.start()
            
            p1.join()
            p2.join()
            
            print('number at the end in ', shared_number.value)               
            print('end main')

    //Share and ARRAY of data between processes WITH LOCK
        from multiprocessing import Process, Value, Array, Lock
        import time   
        
        #Dummy function
        def add_100(numbers, lock):
            for i in range(100):
                time.sleep(0.01)
                for i in range(len(numbers)):
                    with lock:
                        numbers[i] += 1
        
        if __name__ == "__main__":
        
            #Create lock object
            lock = Lock()
        
            #Shared memory
            shared_array = Array('d', [0.0, 100.0, 200.0])
            print('Array at the beginning is ', shared_array[:])
            
            p1 = Process(target=add_100, args=(shared_array, lock))
            p2 = Process(target=add_100, args=(shared_array, lock))
            
            p1.start()
            p2.start()
            
            p1.join()
            p2.join()
            
            print('Array at the end is ', shared_array[:])           
            print('end main')

    //Queue
        from multiprocessing import Process, Value, Array, Lock, Queue
        import time   
        
        #Dummy function
        def square(numbers, queue):
            for i in numbers:
                queue.put(i*i)
                
        def make_negative(numbers, queue):
            for i in numbers:
                queue.put(-1*i)
        
        if __name__ == "__main__":
            
            numbers = range(1, 6)
            q = Queue()
            
            p1 = Process(target=square, args=(numbers, q))
            p2 = Process(target=make_negative, args=(numbers, q))

            p1.start()
            p2.start()
            
            p1.join()
            p2.join()

            #there is no such thing as q.join
            while not q.empty():
                print(q.get())

    //Process Pool
        #Can be used to manage multiple processes
        #Can split large data into smaller chunks and then be processed in parallel processes
        #METHODS: map, apply, join, close
        
        from multiprocessing import Pool

        #Dummy function
        def cube(number):
            return number * number * number                
        
        if __name__ == "__main__":
            numbers = range(10)
            pool = Pool()
            
            #Map - This allocates and creates the max number of processes, then, split numbers into equal sized chunks 
            #Then it will send the chunks to the function. Function is running in parallel in multiple processes
            result = pool.map(cube, numbers)
            
            #Close the pool
            pool.close()
            
            #Join
            pool.join()
            
            print(result)       //Output: [0, 1, 8, 27, 64, 125, 216, 343, 512, 729]

////////////////////////////////////////////////////////////////////////
38. Function Arguments (Args, Kwargs, Unpacking, Local, Global, Mutable, Immutable)
    #Differences between arguments and parameters, 
    #Positional and keywords arguments, 
    #Default arguments
    #Variable length arguments
    #Forced keyword arguments
    #Forced keyword parameters
    #Container unpacking into function arguments  - List
    #Container unpacking into function arguments  - Tuple
    #Container unpacking into function arguments - Dictionary
    #Local and Global variables
    #Parameter passing (by value or by reference)
    
    
    //Difference between arguments and parameters
        def print_name(name)
            print(name) #name is the parameter
        print_name('Izaat') #Izaat is the argument   

    //Positional and keyword arguments
        def foo(a, b, c)
            print(a, b, c)
        foo(1, 2, 3)                //1,2,3 are the positional arguments
        foo(c=3, a=1, b=2)          //a,b,c are the keyword arguments, position doesn't matter
        //Note: You can mix the two arguments but you cant put positional (3) after keyword (b) as shown below
        //Example: (1, b=2, 3)
    
    //Default Arguments
        def foo(a, b, c, d=4)   //d=4 is the default value
            print(a, b, c, d)
        print(1, 2, 3)  //Output: 1 2 3 4
        print(1,2,3,7)  //Output: 1 2 3 7 - This reassigns d=4 to d=7
        //Note: Default arguments must be at the end of the parameters
        
    //Variable length arguments (*args and **kwargs)
        //Note: * => you can pass any positional argument to the function
        //Note: ** => you can pass any keyword argument to the function
        //Note: You can also name them *izaat for *args and **hello for **kwargs
        foo(a, b, *args, **kwargs): 
            print(a, b)                                 //Tuple
            for arg in args:
                print(arg)
            for key in kwargs:                          //Dictionary entry
                print(key, kwargs[key])
        foo(1, 2, 3, 4, 5, six=6, seven=7) 
        //Note: Where "3,4,5" are args and "six" and "seven" are kwargs
        //Note: Every args and kwargs element will be printed on a new line except "1,2" (positional)
        //Note: you can also use positional arguments for args and kwargs
        
    //Forced keyword argument
        def foo(a, b, *, c, d):     //Every argument after the star must be keyword argument
            print(a, b, c, d)
        foo(1, 2, 3, 4)             //This will produce error
        foo(1, 2, c=3, d=4)     //Do this instead  
    
    //Forced keyword parameters
        def foo(*args, last):
            for arg in args:
                print(arg)
            print(last)
        foo(1,2,3)                    //This will only recognize 1,2,3 as args and missing 1 keyword argument 'last'
        foo(1,2,3, last=100)    //Do this instead
        
    //Container unpacking into function arguments - List
        def foo(a, b, c):
            print(a, b, c)
        mylist = [1, 2, 3]
        foo(*mylist)        //This line will unpack mylist and pass 1 to a, 2 to b, and 3 to c
    
    //Container unpacking into function arguments - Tuple
        def foo(a, b, c):
            print(a, b, c)
        mytuple = (1, 2, 3)
        foo(*mytuple)        //This line will unpack mytuple and pass 1 to a, 2 to b, and 3 to c
        
    //Container unpacking into function arguments - Dictionary
        def foo(a, b, c):
            print(a, b, c)
        mydict = {'a': 1, 'b': 2, 'c': 3}
        foo(**mydict)        //This line will unpack mydict and pass 1 to a, 2 to b, and 3 to c
    
    //Local and Global variables
        def foo():
            global number   //this must be called in the function to modify the 'number' variable (global variable)
            number = 3
        number = 0  
        foo()
        print (number)  //Output: 3

        //NOTE: Local variable and global variable may share the same name but has nothing to do with each other
        def foo():
            number = 3      //This number(local) variable only lives within this function and has nothing to do with number (global)
        number = 0          //This is the global variable
        foo()
        print(number)   //Output: 0
    
    //Parameter passing (by value or by reference)
        #Immutable objects can't be modified
        #Mutable objects can be modified
        #Mutable objects can rebind into immutable object 
        
        //Immutable
            def foo(x):
                x = 5
            var = 10    //Immutable 
            foo(var)
            print(var)  //Output:10

        //Mutable
            def foo(a_list):
                a_list.append(4)
                a_list[0] = -100
            my_list = [1, 2, 3]
            foo(my_list)
            print(my_list)  //Output:[-100, 2, 3, 4]

        //Immutable - Rebind
            def foo(a_list):
                a_list = [100, 200, 300]    //Adding this line turns my_list immutable as a_list becomes a local variable
                a_list.append(4)
                a_list[0] = -100
            my_list = [1, 2, 3]
            foo(my_list)
            print(my_list)  //Output:[1, 2, 3]

        //Mutable
            def foo(a_list):
                a_list += [100, 200, 300]
            my_list = [1, 2, 3]
            foo(my_list)
            print(my_list)  //Output:[1, 2, 3, 100, 200, 300]

        //Immutable - Rebind
            def foo(a_list):
                a_list = a_list + [100, 200, 300]
            my_list = [1, 2, 3]
            foo(my_list)
            print(my_list)  //Output:[1, 2, 3]

////////////////////////////////////////////////////////////////////////
39. Asterisk (*) Operator
    //Multiplication
        result = 2 * 4
        print(result)   //Output: 8

    //Power
        result = 2 ** 4
        print(result)   //Output: 16
    
    //Create List, Tuples and Strings with *
        //Substitute [] with () for Tuples
        //Substitute [] with " "" for Strings
        //List with 5 elements
            zeros = [0] * 6
            print(zeros)    //Output:   [0, 0, 0, 0, 0, 0]

        //List with pattern elements
            zeros = [0, 1] * 6
            print(zeros)    //Output:   [0, 1, 0, 1, 0, 1]

    //Args and Kwargs
        #See Topic 38. Function Arguments

    //Packing-Unpacking
        numbers = [1, 2, 3, 4, 5, 6] 
            #using tuples, (1, 2, 3, 4, 5, 6) will return the same result
        
        *beginning, last = numbers  //This will create beginning list and exclude the last number into the new list
            #beginning, *last = numbers //This will create last list and exclude the first number into the new list
            #beginning, *middle, last = numbers //This will create middle list and exclude the first and last number into the new list
            #beginning, *middle, secondlast, last = numbers //This will create middle list and exclude the first, secondlast and last number into the new list
            
        print(beginning)
        #print(middle)
        #print(secondlast)
        print(last)
        //NOTE: If the numbers variable is a tuple, the beginning output will still be a list

    //Merging into a list
        mytuple = (1,2,3)
        mylist = [4,5,6]
        myset = {7,8,9}
        
        newList = [*mytuple, *mylist, *myset]
        print(newList)      //Output: [1,2,3,4,5,6,7,8,9]

    //Merging dictionaries
        dictA = {'a': 1, 'b': 2, 'c': 3}
        dictB = {'d': 4, 'e': 5, 'f': 6}
        myDict = {**dictA, **dictB}
        print(myDict)       //Output: {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}

////////////////////////////////////////////////////////////////////////
40. Shallow & Deep Copying
    #Copying mutable elements with built in module
    #Difference between shallow and deep copies
        #Shallow: one level deep, only references of child object
        #Deep: Full independent copy
    #Create copies of custom objects

    //Referencing - Not copies
        //Modifying copyVar will also modify originVar
        
        #Example with numbers
        originVar = 5
        copyVar = originVar //This only points copyVar to originVar and doesn't do anything
        copyVar = 6             //This only creates another variable independent from the one linked to originVar
        print(originVar)    //Output: 5
        print(copyVar)      //Output: 6
        
        #Example with list
        originVar = [1, 2, 3, 4, 5]
        copyVar = originVar
        copyVar[0] = -10
        print(originVar)        //Output: [-10, 2, 3, 4, 5]
        print(copyVar)          //Output: [-10, 2, 3, 4, 5]

    //Shallow copy
        #Only works with single level list
        import copy
        originVar = [1, 2, 3, 4, 5] //One level deep list
        
        copyVar = copy.copy(originVar)
            #Alternatives - produces same result
            #copyVar = originVar.copy()
            #copyVar = list(originVar)
            #copyVar = originVar[:] //Slicing
            
        copyVar[0] = -10
            
        print(originVar)        //Output: [1, 2, 3, 4, 5]
        print(copyVar)          //Output: [-10, 2, 3, 4, 5]

    //Deep Copy
        #Can be applied to tuples and dictionaries
        import copy
        originVar = [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]] //Two levels deep list
        
        copyVar = copy.deepcopy(originVar)
            
        copyVar[0] [1] = -10
        print(originVar)        //Output: [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]
        print(copyVar)          //Output: [[0, -10, 2, 3, 4], [5, 6, 7, 8, 9]]

    //Copy custom objects - Shallow structure
        import copy
        class Person:
            def __init__(self, name, age):
                self.name = name
                self.age = age
                
        p1 = Person('Ahmad', 25)
        p2 = copy.copy(p1)        
        p2.age = 28
        
        print(p1.age)   //Output: 25
        print(p2.age)   //Output: 28
        
    //Copy custom objects - Deep structure
        import copy
        
        class Person:
            def __init__(self, name, age):
                self.name = name
                self.age = age
                
        class Company:
            def __init__(self, boss, employee):
                self.boss = boss
                self.employee = employee
                
        p1 = Person('Ahmad', 55)    //Boss
        p2 = Person('Ali', 25)          //Employee
        
        companyVar1 = Company(p1, p2)
        companyVar2 = copy.deepcopy(companyVar1)
        
        companyVar2.boss.age = 56
        
        print(companyVar1.boss.age)   //Output: 55
        print(companyVar2.boss.age)   //Output: 56


////////////////////////////////////////////////////////////////////////
41. Context Managers
    #Great tool for resource management
    #Allows allocate and release resources precisely when you want to
    
    //////////////////////
    //Writing
        #Example code
        with open('notes.txt', 'w') as file:
            file.write('Action')
        
        #The example code is similar to this full code
        file = open('text.txt', 'w')
        try:
            file.write('Action Statement')
        finally:
            file.close()

    //////////////////////
    //Lock
        from threading import Lock
        lock = Lock()
        
        with lock:
            #....code

    //////////////////////
    //Basic Context Manager
        #Using class as Context Manager
        class ManagedFile:
            #Initialize
            def __init__(self, filename):
                self.filename = filename
            
            #Open File
            def __enter__(self):
                print('enter')
                self.file = open(self.filename, 'w')
                return self.file
            
            #Close File
            def __exit__(self, exc_type, exc_value, exc_traceback):
                if self.file:
                    self.file.close()
                print('exit')

        with ManagedFile('notes.txt') as file:
            print('Action statement')
            file.write('Write a string')
    
    //////////////////////
    //Context Manager with Exception Error
        #Simulating the error
        
        #Using class as Context Manager
        class ManagedFile:
            #Initialize
            def __init__(self, filename):
                self.filename = filename
            
            #Open File
            def __enter__(self):
                print('enter')
                self.file = open(self.filename, 'w')
                return self.file
            
            #Close File
            def __exit__(self, exc_type, exc_value, exc_traceback):
                if self.file:
                    self.file.close()
                print('exc:', exc_type, exc_value)  #exc: None None
                print('exit')

        with ManagedFile('notes.txt') as file:
            print('Action statement')
            file.write('Write a string')
            file.somemethod()   #This will simulate error trigger
        print('Continue...')
        
        #NOTE: Despite the program closes, it  didnt print out continue

    //////////////////////
    //Context Manager with Exception Handler
        #To make sure the file still closes and exits the program when there is an error
        
        #Using class as Context Manager
        class ManagedFile:
            #Initialize
            def __init__(self, filename):
                self.filename = filename
            
            #Open File
            def __enter__(self):
                print('enter')
                self.file = open(self.filename, 'w')
                return self.file
            
            #Close File
            def __exit__(self, exc_type, exc_value, exc_traceback):
                if self.file:
                    self.file.close()
                if exc_type is not None:
                    print('Exception has been handled')
                #print('exc:', exc_type, exc_value)  #exc: None None
                print('exit')
                return True

        with ManagedFile('notes.txt') as file:
            print('Action statement')
            file.write('Write a string')
            file.somemethod()   #This will simulate error trigger
        print('Continue...')
        
        #NOTE: By handling the exception, the Continue gets printed out

    //////////////////////
    //Context Manager Library
        from contextlib import contextmanager
        
        #Decorator
        @contextmanager
        
        #Create Generator
        def open_managed_file(filename):
            fileVar = open(filename, 'w')
            try:
                yield fileVar   #This suspends the execution temporarily to write into the file
                #Exception handlers can be inserted here...
            finally:
                f.close()

        with open_managed_file('notes.txt') as fileVar:
            fileVar.write('Write a string')


////////////////////////////////////////////////////////////////////////
42. Python Unique Features
        
    /////////////////////
    //Class in functions
        def makeClass(x):
            class Dog:
                def __init__(self, name):
                    self.name  = name
                
                def printValue(self):
                    print(x)
            return Dog
        
        cls = makeClass(10)
        print(cls)                              //Output: <class '__main__.makeClass.<locals>.Dog'>
        
        d = cls("Izaat")
        print(d.name)
        d.printValue()
    
    /////////////////////
    //Function in For Loops
        for i in range(10):
            def show():     //You can have multiple functions in for loop
                print(i*2)
            show()          //Output: Numbers in multiplication of 2 - (0,2,4,6... ...16,18)
        //NOTE: if show() being called outside of the function, it outputs 18
    
    /////////////////////
    //Functions in a statement under a function
        def func(x):
            if x == 1:
                def rv():
                    print("X is equal to 1")
            else:
                def rv():
                    print("X is not 1")
            return rv
        
        new_func() = func() 
            #OR new_func() = func(2)
        
       new_func()
       
       #shows memory address
       print(id(new_func))

    /////////////////////
    //Inspect Module
    
        #getmembers() and getsource()
            import inspect    
            def func(x):
                if x == 1:
                    def rv():
                        print("X is equal to 1")
                else:
                    def rv():
                        print("X is not 1")
                return rv        
            new_func() = func()         
           print(inspect.getmembers(new_func))
           print(inspect.getsource(new_func))       //Shows source code
           
        #Queue
            import inspect    
            from queue import Queue
            print(inspect.getsource(Queue))         //Shows object list

////////////////////////////////////////////////////////////////////////
43. Dunder/Magic/DataModel Methods
    https://docs.python.org/3/reference/datamodel.html
    // __init__, or Double UNDERscore, D-UNDER
    //It's a built in behaviour to save time
    //Inventing our dunder is highly discouraged, it might cause collisions
    //The syntax affecting List datatypes i.e + - * / can be used on Dunder Methods
    
    //Structure
        class Person:
            def __init__(self, name):
                self.name = name
                
            #def __repr__(self):
            #    return f"Person({self.name})"
                
        p = Person("String")
        print(p)    
        //Prints out memory address location because p has not been assigned on what to do
        //To assign, add in __repr__ object

    //Using Math Operators
        class Person:
            def __init__(self, name):
                self.name = name
                
            def __repr__(self):
                return f"Person({self.name})"
                
            def __mul__(self, x):            //Assume x is int datatype
                if type(x) is not int:
                    raise Exception("Invalid argument, must be int")
                self.name = self.name * x
                
        p = Person("String")
        p * 4
        print(p)                             //Output: Person(StringStringStringString)

    //Using Brackets to call a function
        class Person:
            def __init__(self, name):
                self.name = name
                
            def __call__(self, y):
                print("Called this function", y)
                
        p = Person("String")
        p(4) 

    //Using length
        class Person:
            def __init__(self, name):
                self.name = name
        
            def __len__(self):
                return len(self.name)

        p = Person("String")
        print(len(p))

    //Inspect object source code for Queue Class
        from queue import Queue
        import inspect

        q = Queue()     #Queue doesn't need __repr__
        print(q)            #Output: Memory address

        #inspect Queue object
        print(inspect.getsource(Queue))        //This will show the Queue Class
        
        #In the source code, _qsize is defined as follows:
        #def _qsize(self):
        #    return len(self.queue)

    //Check length of Queue Class
        from queue import Queue as q
        import inspect
        
        class Queue(q):
            def __repr__(self):
                return f"Queue({self._qsize()})"
                
        qu = Queue()
        print(qu)              //Output: Queue(0)

    //Add object length to the Queue Class source code
        from queue import Queue as q
        import inspect
        
        class Queue(q):
            def __repr__(self):
                return f"Queue({self._qsize()})"
                
            def __add__ (self, item):
                self.put(item)

        qu = Queue()
        qu + 9 
        qu + 8
        print(qu)   //Output: Queue(2)

    //Subtract object length to the Queue Class source code
        from queue import Queue as q
        import inspect
        
        class Queue(q):
            def __repr__(self):
                return f"Queue({self._qsize()})"
                
            def __add__ (self, item):
                self.put(item)
                
            def __sub__ (self, item):
                self.get(item)

        qu = Queue()
        qu + 9 
        qu + 8
        qu - 1            //Note: Should be an int or None. Null and other characters wont work
        print(qu)         //Output: Queue(2)

////////////////////////////////////////////////////////////////////////
44. Metaclasses - Exploiting Python's backend 'type' method to create customized classes
    //Metaclasses can be highly complex and sometimes can be a bad practice
    //It defines the rule for the class
    
    //Basic idea and structure of the class used in metaclass
        def hello():
            class Hi:       //In python, classes are objects
                pass
            return Hi
    
    //Types of Python backend constructors
        class ClassVar:
            pass
        
        def func():
            pass        
        
        print(ClassVar)                 //Output: <class '__main__.ClassVar'>
        print(ClassVar())              //Output: Memory location
        print(type(ClassVar()))        //Output: <class '__main__.ClassVar'>
        print(type(2))                 //Output: <class 'int'> 
        print(type(func))              //Output: <class 'function'>          
        print(type(ClassVar))          //Output: <class 'type'> 
            //All of the above are typed as objects
            //"Int constructor" being called to create integers, "function constructor" to create functions, etc
            //NOTE: Classes are classified as 'type'
            //When we create a class, it calls on the 'type constructor'.

    //Using "type constructor" to create classes
        //Normal structure
            class Test:
                print('Hello')
            Test()
        
        //Alternative structure
            //type(name, bases, attributes)
            //Test = type('Test', (), {})
            
            #String
            Test = type('Test', (), {'a':'hello'})
            t = Test()
            print(t.a)      //Output: Hello
            
            #Integer
            Test = type('Test', (), {'a':5})
            t = Test()
            print(t.a)      //Output: 5

            #Combined
            Test = type('Test', (), {'a':5})
            t = Test()
            t.wy = "hello"
            print(t.a)      //Output: 5
            print(t.wy)      //Output: Hello

    //Using type constructor to Inherit a function
        class Foo:
            def show(self):
                print("hi")
        Test = type('Test', (Foo,), {})
        t = Test()
        t.show()

    //Using Type constructor to add a function
        class Foo:
            def show(self):
                print("hi")
                
        def add_attr(self):
            self.z = 9
        
        Test = type('Test', (Foo,), {"x":5, "add_attr": add_attr})
        t = Test()
        print(t.x)          //Output: 5
        t.show()            //Output: hi
        print(t.add_attr)   //Output: <bound method add_attr ... >
        t.add_attr()
        print(t.z)          //Output: 9
    
    //In summary, the structure of 'types'
        type(name, bases, attributes)
    
    //Create own Metaclass by inheriting from 'Type'
        class Meta(type):        //Without adding 'type', it won't be a Metaclass
            def __new__(self, class_name, bases, attrs):
                print(attrs)    //This is just to see what it looks like by calling Cat class
                return type(class_name, bases, attrs)
        
        class Cat(metaclass=Meta):
            x = 5
            y = 2
            def hello(self)
                print("hi")
        //Output: {'__module__': '__main__', '__qualname__': 'Cat', 'x': 5, 'y': 2, 'hello': <function ...>}    
        //Note: The output value is in dictionary format
    
    //Using Metaclass to make item name and function name change to capital letters
        class Meta(type): 
            def __new__(self, class_name, bases, attrs):
                print(attrs)  
                
                a = {}          //This makes a blank dictionary for the attributes
                for name, val in attrs.items():           //Loop through attrs to get name and value. The "name" is the attrs name
                    if name.startswith("__"):             //if name starts with __, then add the value back in
                        a[name] = val                     //"a[item]" being assigned to "a={}"
                    else:
                        a[name.upper()] = val             //if no double underscore, add uppercase
                
                #print(a)                                 //Output: Add this line to see if x, y and hello are now in uppercases 
                #return type(class_name, bases, attrs)    //modified attrs to "a" in "a={}"
                return type(class_name, bases, a)
        
        class Cat(metaclass=Meta):
            x = 5
            y = 2
            def hello(self):
                print("hi")
                
        # Output:
        # {'__module__': '__main__', '__qualname__': 'Cat', 'X': 5, 'Y': 2, 'HELLO': <function ... >}

        c = Cat()
        #print(c.x)     //Invalid as x is now X
        #print(c.hello) //Invalid since hello is now HELLO
        #print(c.X)
        #print(c.HELLO)

    //SUMMARY
        class Meta(type): 
            def __new__(self, class_name, bases, attrs):
                
                a = {}
                for name, val in attrs.items(): 
                    if name.startswith("__"):  
                        a[name] = val   
                    else:
                        a[name.upper()] = val  
                return type(class_name, bases, a)
        
        class Cat(metaclass=Meta):
            x = 5
            y = 2
            def hello(self):
                print("hi")

        c = Cat()
        #print(c.x)     //Invalid as x is now X
        #print(c.hello) //Invalid since hello is now HELLO
        #print(c.X)
        #print(c.HELLO)








