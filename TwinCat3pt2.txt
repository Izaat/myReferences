TIPS: When in doubt about the naming conventions or spellings, press CTRL + Spacebar
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CONTENTS
01. Connecting to the PLC
02. TwinCAT - Connecting
03. Testing part 1
04. Testing part 2
05. EtherCAT
06. Numeric Control
07. PLCOpen Standards
08. MC_Power, MC_Reset, MC_Jog
09. MC_Velocity
10. Using throttle to control motor speed
11. Configuring a Stepper Motor
12. Axis Homing
13. MC_Absolute & MC_Relative

01. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CONNECTING TO PLC
            Connecting to the PLC
                ControlPanel > NetworkInternet > NetworkConnections > LocalAreaNetwork > RightClick > Properties
                NetworkTab > TCP/IPv4 > Properties > Advanced > IPSettingsTab > Add
                IP Address: 192.168.1.254
                Subnet: 255.255.255.0
                Now you network card has 2 IP addresses
                Open Angry IP Scanner > Just press Play nad it'll do a ping sweep
                PLC will pop up as 192.168.1.130
                WindowsStartButon > Run > "mstst"
                Remote Desktop Connection wll appear, set IP as PLC
                Click on "Connect" and Windows Security window will pop up
                Default Beckoff Administrator Password: 1
                This will lead you into the window embedded operating system in Beckoff PLC
                
            Connecting to Twincat
                Your PC's Windows > VisualStudio > File > New > Project
                Entire list of files will appear in Solution Explorer
                Select System and click on "Choose target" button
                Click on "Search (Ethernet)" > Type in the PLC's IP address on "Enter Hos Name" input box and click the button
                Remember the AMS NetId : 5.32.241.178.1.1
                RouteName(Target) = Host Name
                Make sure "hostname" check box is ticked and target route is "static"
                    Click on "Add Route" button
                                If it fails, try ping the Hostname/Routename example c:\ping CX-20F1B2
                If connecting via "hostname" fails, then check "IPaddress" checkbox and try again.
                     Username: Administrator
                     Password: 1
                Under connection column, there should be "X" which means it is connected
                Click on "Close" button
                You may start new plc project from now onwards 
                
            Testing out connection
                //MAIN(PRG) - Main
                    VAR
                        heartbeat : DINT;
                    END_VAR
                //MAIN(PRG) - Sub
                    heartbeat =:= heartbeat + 1;
                    
            Run program and heartbeat value will increase by increments of 1

END OF CONNECTING TO PLC


02. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TWINCAT - Connecting
        Under SolutionExplorer, Open up I/O folder and RightClick on Devices, the Insert Device 
            In Insert Device window, Dropdown EtherCAT and select EtherCAT Master
            A device will be added to TwinCat Project > I/O > Devices > Device 1 (EtherCAT)
            Select the device and go to the Adapter Tab
            Under NetworkAdapter > OS (NDIS), click on Search button and a list of devices will be listed down in a popup window 
            Select "Local Area Connection (TwinCAT-Intel PCI Ethernet Adapter (Gigabit))"
            Click on "Restart TwinCAT Config Mode", the blue icon button located above the the solution explorer under the menu (File, Edit, Etc) 
            Select Load I/O device in the prompt
            Rename "Device 1 (EtherCAT)" to "Local NIC (EtherCAT)"
            After renaming, the devices will expand and "Term 1 (EK1100)" will appear
            This includes all the input/output modules connected to the terminals 
            "WCState" is helpful when you're debugging as well as the Input and Output folders above the "InfoData" folder
            Save and activate the configuration by clicking on the "blue steps" icon located above the solution explorer
            A warning message will appear  "Device 'Local NIC" needs sync master (at least on variable lined to a task variable) - click ok
                Warning appears because there is no program being assigned
            You may "Login" to test the PLC

03. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TWINCAT - Testing part 1
        //Program_Main - Main
            VAR
                heartbeat : BYTE;
                one AT %Q* : BOOL;  //%Q* is the memory address where Q is the output and * means map handling, nowadays you don't have to add the * anymore
                two AT %Q* : BOOL;
                three AT %Q* : BOOL;
                four AT %Q* : BOOL;
                
                prox AT %I* : BOOL; //Input
            END_VAR

        //Program_Main - Sub
            heartbeat := heartbeat + 1;
            one := heartbeat MOD 2 = 0;         //This just means the system will take heartbeats, and modular divides it and check if the value equals to 0 , if yes, then the bit is ON
            two := heartbeat MOD 4 = 0;             //Basically it blinks n a sequence
            three := heartbeat MOD 8 = 0;
            four := heartbeat MOD 16 = 0;
            
        //Now go to Menu > Build > BuildSolution
        //Ignore the warning
        //RightClick on SolutionExplorer > Project > Term1 > Term4 > Channel1 > Output and select "ChangeLink", An "Attach Variable Output" window will appear
        //Untitled1 is the PLC runtime program
        //Expand the Instance and select MAIN.one > QB772192.0.BOOL[1,0]
        //Do the same for Channel 2 and assign its output to variable "MAIN.two"
        
        //Now go to SolutionExplorer > Project > Term1 > Term3 > Channel5 > Input and assign to "MAIN.prox"
        //Activate Configuration        //This should be click whenever you reassign the I/O address
        //Login and run
        //Select SolutionExplorer > Project > Term1 > Term4 > Channel1 > Output and open the "Online" tab to see the i/o graph

04. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TWINCAT - Testing part 2
        //Program_Main - Main
            VAR
                heartbeat : BYTE;
                one AT %Q* : BOOL; 
                two AT %Q* : BOOL;
                three AT %Q* : BOOL;
                four AT %Q* : BOOL;
                
                prox AT %I* : BOOL; //Input
            END_VAR

        //Program_Main - Sub
            heartbeat := heartbeat + 1;
            IF prox = TRUE THEN
                one := heartbeat MOD 2 = 0; 
                two := heartbeat MOD 4 = 0; 
                three := heartbeat MOD 8 = 0;
                four := heartbeat MOD 16 = 0;
            ELSE
                one := FALSE; 
                two := FALSE; 
                three := FALSE; 
                four := FALSE; 
            END_IF
            
        //Now test this by activating the sensor connected to Input 5
        //Once activated, the output will blink in sequence

05. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
EtherCAT
    //TopLeft port is input. The BottomLeft port and RightHand port is output
    //Layout
        PLC > EK1100 I/Os > Devices
    //OSI Layer             - EtherCAT
        7. Application     - Cyclic Data Exchange and Mailbox Acyclic Data Access
        6. Presentation   -  N/A      
        5. Session           -  N/A   
        4. Transport        -  N/A   
        3. Network          -  N/A   
        2. DataLink         - Process Data Mapping, AutoForwarder, Ethernet MAC
        1. Physical          - 100BASE-TX/FX
    
    //Determinism in fieldbuses- Time alignment between multiple layers irregardless of how fast
    //Real-time signal - how fast the port is listening to signals, the higher the hertrate, the higher the realtime performance.
    //EtherCAT is real-time deterministic fieldbus
    //CANopen protocol over EtherCAT (CoE) - application profiles for valves and controllers
    //Servodrive-Profile over EtherCAT (SoE) - comms interface for motion control applications


06. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Numerical Control - 
    //Adding a drive
            //Restart to Config mode and don't activate free run
            //Under I/O > Devices > RightClick on NIC(EtherCAT) > Scan
            //Then you can add or remove any devices you want 
            //Once done, Activate configuration, Run mode, login and run
            //Click on I/O > Devices > NIC (EtherCAT) and head to the center panel and open up "Online" tab
            //Add: 1, Name: Drive7 (AX52##), State: ERR PREOP INIT_ERR, CRC: 0.0 
            //Select "Op" in Actual State to see the send frames and other data to check the condition
            //Click on SlnExplorer > I/O > Devices > NIC(EtherCAT) > Drive and open the Drive manager tab in the center panel
            //You can see the error codes at the table under "Diagnostic Code" column
                //After making changes, click on "download" located below the list of tabs in the Drive Manager tab
                //Then click on "Activate configuration" from the menu
            //Under ChannelA, open the "Motor and Feedback"
            //Open the dropdown menu under "Feedback 1 connector" and select 14 X14(One cable feedback)
            //Click on "Scan feedback 1 / motor" and everything will be configured automatically
            //Make sure the DCLinkOk columns are green
            //Click on "Set NC Parameters" button and then click on "Activate Configuration" at the main menu
            //Restart TwinCat in runMode => OK            
    //Linking to NC
            //RightClick on SolutionExplorer > Project > Motion, then Add New Item and select NC/PTP Configuration (PTP = Point to Point)
            //A new dropdown (NC-Task) item will be added to the Motion subfolder
            //RightClick on NC-Task > Axes and add new item (ContinuousAxis, EncoderAxis, TimeGenerator, 2SpeedDiscreteAxis, LowCostStepperAxis)
            //Select ContinuousAxis and "Axis1" will appear under NC-Task > Axes
            //Under Axis1, go to the settings tab and click on "LinkToI/O" button
            //Change the setting, save and click on "Activate Configuration" again
            //Under Axis1, go to the Online tab. The number with the largest font size is the current position
            //Click on F8 to reset
            //To activate the limit switches, under "Enabling" section, click on set button and tick on Controller, FeedFw, FeedBw. Then F8(Reset) button
            //F5 to enable
    //Now you can jog the motor with F1 to F4

07. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
PLCOpen Standards
    Programming standards and libraries
    https://www.plcopen.org
    Adding Library
        RightClick on SolutionExplorer > Project > PLC > Project > Project > References, and click on AddLibrary
        Open Motion > PTP and add in Tc2_MC2 and Tc2_NC
    Add in "AxisA : AXIS_REF;" into the Program Main
    Add in "AxisA.ReadStatus();" into the Program Main - Sub
    Then go to Solution Explorer > TwinCAT > Motion > NC_Task > Axes > Axis 1 and open up settings tab
    Click on "Link to PLC" button and select Main.AxisA(Untitled Instance)
    Save and "Acitvate Configuration"
    Once on Run mode tab, open up AxisA tree
    //Example
        //Program_Main - Main
            VAR
                heartbeat : BYTE;
                one AT %Q* : BOOL; 
                two AT %Q* : BOOL;
                three AT %Q* : BOOL;
                four AT %Q* : BOOL;
                
                prox AT %I* : BOOL; //Input
                
                AxisA : AXIS_REF;
            END_VAR

        //Program_Main - Sub
            heartbeat := heartbeat + 1;
            IF prox = TRUE THEN
                one := heartbeat MOD 2 = 0; 
                two := heartbeat MOD 4 = 0; 
                three := heartbeat MOD 8 = 0;
                four := heartbeat MOD 16 = 0;
            ELSE
                one := FALSE; 
                two := FALSE; 
                three := FALSE; 
                four := FALSE; 
            END_IF    
            AxisA.ReadStatus();


08. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MC_Power, MC_Reset, MC_Jog
    //Program_Main - Main
            VAR
                heartbeat : BYTE;
                one AT %Q* : BOOL; 
                two AT %Q* : BOOL;
                three AT %Q* : BOOL;
                four AT %Q* : BOOL;
                
                prox AT %I* : BOOL; //Input
                
                AxisA : AXIS_REF;
                
                McPower : MC_Power;
                McReset : MC_Reset;
                McJogging : MC_Jog;
            END_VAR

        //Program_Main - Sub
            heartbeat := heartbeat + 1;
            AxisA.ReadStatus();
    
    //Under MAIN(Online) Tab, open up the McPower Tree
        Earlier, we activated these 3 manually. Now we have to activate them using PLC
            Enable, Enable_Position, Enable_Negative = Controller, FeedFw, FeedBw
        Override = Speed of axis

    //Program_Main - Main
            VAR
                heartbeat : BYTE;
                one AT %Q* : BOOL; 
                two AT %Q* : BOOL;
                three AT %Q* : BOOL;
                four AT %Q* : BOOL;
                prox AT %I* : BOOL; //Input
                AxisA : AXIS_REF;
                
                McPower : MC_Power;
                McReset : MC_Reset;
                McJogging : MC_Jog;
                iState : DINT;
            END_VAR

        //Program_Main - Sub
            heartbeat := heartbeat + 1;
            AxisA.ReadStatus();
            
            //McPower(Axis:=AxisA);
            McPower(Axis:=AxisA, Enable:=TRUE, Enable_Positive:=TRUE, Enable_Negative:=TRUE);      //Powering up the drive for Case State 20
            McReset(Axis:=AxisA);
            McJogging(Axis:=AxisA);
            
            CASE iState OF
                0: //Initialize
                    iState := 10;
                
                10: //Start Drive Reset
                    McReset(Axis:=AxisA, Execute:=TRUE);
                    IF McReset.Done THEN
                        iState := 20;
                    ELSE IF McReset.Error THEN
                        iState := 999;
                    END_IF
                    
                20: //Wait for Drive to reset
                    IF McPower.Status THEN             //This needs to be True. But in order to make it true, parameters (Enable, Enable_Positive, Enable_Negative)  
                        iState := 30;                  //need to be added into the McPower. See Above (//Powering up the drive)
                    END_IF
                
                30:  //Wait for drive command
                    McJogging(Axis:=AxisA, JogForward:=prox);               //The jogging is tied to the Digital input of the PLC
                    
                999: //Error handling
            END_CASE

        //At this point, you may save and run the program
        //Motor will rotate when you activate the proximity sensor

09. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MC_Velocity     == 11 points

    //Program_Main - Main
            VAR
                heartbeat : BYTE;
                one AT %Q* : BOOL; 
                two AT %Q* : BOOL;
                three AT %Q* : BOOL;
                four AT %Q* : BOOL;
                prox AT %I* : BOOL; //Input
                AxisA : AXIS_REF;
                
                McPower : MC_Power;
                McReset : MC_Reset;
                McJogging : MC_Jog;
                
                McVelocity : MC_MoveVelocity;
                McStop : MC_Stop;
                CurrentVelocityCmd : DINT;                        //01. Use for checking output and testing, 
                                                                  //no scale installed so we do not know the unit being used (mm/s or rpm) therefore the existence of this line
                iState : DINT;
                
            END_VAR
            
            
    //Program_Main - Sub
            heartbeat := heartbeat + 1;
            currentVelocityCmd := 1000;                           //02. Giving the value since we don't have the unit yet
            AxisA.ReadStatus();
            
            //McPower(Axis:=AxisA);
            McPower(Axis:=AxisA, Enable:=TRUE, Enable_Positive:=TRUE, Enable_Negative:=TRUE);  
            McReset(Axis:=AxisA);
            McJogging(Axis:=AxisA);
            
            CASE iState OF
                0: //Initialize
                    iState := 10;
                
                10: //Start Drive Reset
                    McReset(Axis:=AxisA, Execute:=TRUE);
                    IF McReset.Done THEN
                        iState := 20;
                    ELSE IF McReset.Error THEN
                        iState := 999;
                    END_IF
                    
                20: //Wait for Drive to reset
                    IF McPower.Status THEN           
                        iState := 40;                                 //04. To replace "Goto Case 30" with "Case 40"
                    END_IF
                
                30:  //Wait for drive JOG command                     //03. This will be assigned as Jogging command
                    McJogging(Axis:=AxisA, JogForward:=prox);    
                    
                40: //Wait for velocity command                       //05. To add thisline to make way for MC_Velocity command
                    MCVelocity(
                        Axis:=AxisA,
                        Velocity:=CurrentVelocityCmd,
                        Acceleration:=10000,                           //06. Value to be obtained through trial and error
                        Deceleration:=10000,
                        Jerk:=1000000,                                  //07. Change of acceleration limitation, and this value means no limit.
                        Direction:=MC_Direction.MC_Positive_Direction,
                        Execute:=prox                                   //08. This will execute on the rising edge of prox sensor. But this wont stop the motor hence we require a IF command to stop the motor
                    );
                    
                    IF NOT prox THEN
                        McVelocity(Axis:=AxisA, Execute:=FALSE);        //09. This stops the motor when proximity sensor is not activated
                        iState:=900;                                    //10. this will jump to case 900
                    END_IF
                    
                900: //Stop Servo                                       //11. This Will be the Stop function and will jump back to case 40
                    McStop(Axis:=AxisA, Execute:=TRUE);
                    IF prox THEN
                        McStop(Axis:=AxisA, Execute:=FALSE);                
                        iState := 40;
                    END_IF
                    
                999: //Error handling
            END_CASE



10. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Using a throttle to control motor speed == 7 points
    
    //02. Add Functions MAP (FUN)
    //PLC > Project > Project > POU > Functions
    //FUN - MAP - Main
            FUNCTION MAP : DINT
            VAR_INPUT
                x : DINT;
                in_min : DINT;
                in_max: DINT;
                out_min: DINT;
                out_max: DINT;
            END_VAR
    //FUN - MAP - Sub
            IF ((in_max - in_min) + out_min) <> 0 THEN
                MAP := DINT_TO_INT((x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min);
            ELSE
                MAP := 0;
            END_IF
            RETURN;
    
    //Program_Main - Main
            VAR
                heartbeat : BYTE;
                one AT %Q* : BOOL; 
                two AT %Q* : BOOL;
                three AT %Q* : BOOL;
                four AT %Q* : BOOL;
                
                prox AT %I* : BOOL; //Input
                
                //Dynamic throttling
                Throttle AT %I* : INT;                                               
                LastThrottle :INT;                                                                      

                //01. For the game throttle. In order to know if its INT, go to SlnExplorer >> Term1 (EK1100)> Term2 (EL3255) 
                    //Where the throttle is connected> AI Standard Ch 1 > Value  > Open Online Tab
                    //under Value textbox, the number is in "counts" and the number in <9.09> represents the voltage //voltage and counts drops as soon as you crank the throttle
                    //under Variable tab, see "Type:". "Size:" is in bytes.
                    //Go to Menu > Build > BuildSolution 
                    // Once completed, RightClick on SlnExplorer >> Term2 > AI Standard Ch1 > Value, and select "ChangeLink"
                    //DoubleClick on "MAIN.Throttle", save file and click on "Activate Configuration"
                    //LogIn and Run the PLC
       
                AxisA : AXIS_REF;                                                                      
                //                                                                                              
                McPower : MC_Power;                                                             
                McReset : MC_Reset;                                                              
                McJogging : MC_Jog;
                
                McVelocity : MC_MoveVelocity;
                McStop : MC_Stop;
                CurrentVelocityCmd : DINT;  
                
                iState : DINT;
                
            END_VAR           
            
    //Program_Main - Sub
            heartbeat := heartbeat + 1;
            //currentVelocityCmd := 1000;                                         //03. Remove this line and add the followings
                CurrentVelocityCmd := MAP(Throttle,29800, 22600, 0, 2800);        //04. MAP(Input, No throttle, Max throttle, min speed of motor, max speed of motor )
                IF CurrentVelocityCmd < 50 THEN
                    CurrentVelocityCmd := 0;                                      //07. Adding the biting point to the throttle. Therefore throttle needs to crank more then 50 then motor will start
                END_IF
            AxisA.ReadStatus();
            
            //McPower(Axis:=AxisA);
            McPower(Axis:=AxisA, Enable:=TRUE, Enable_Positive:=TRUE, Enable_Negative:=TRUE);  
            McReset(Axis:=AxisA);
            McJogging(Axis:=AxisA);
            
            CASE iState OF
                0: //Initialize
                    iState := 10;
                
                10: //Start Drive Reset
                    McReset(Axis:=AxisA, Execute:=TRUE);
                    IF McReset.Done THEN
                        iState := 20;
                    ELSE IF McReset.Error THEN
                        iState := 999;
                    END_IF
                    
                20: //Wait for Drive to reset
                    IF McPower.Status THEN           
                        iState := 40;                                     
                    END_IF
                
                30:  //Wait for drive JOG command                         
                    McJogging(Axis:=AxisA, JogForward:=prox);    
                    
                40: //Wait for velocity command                        
                    MCVelocity(
                        Axis:=AxisA,
                        Velocity:=CurrentVelocityCmd,
                        Acceleration:=10000,                                      
                        Deceleration:=10000,
                        Jerk:=1000000,                                                   
                        Direction:=MC_Direction.MC_Positive_Direction,
                        Execute:=prox   AND (LastThrottle<>Throttle)                 //05. Adding LastThrottle not equals to throttle
                    );
                    
                    IF NOT prox THEN
                        McVelocity(Axis:=AxisA, Execute:=FALSE);       
                        iState:=900;                                                       
                    END_IF
                    
                    LastThrottle := Throttle;                                        //06. Changing the max every scan cycle
                    
                900: //Stop Servo                                               
                    McStop(Axis:=AxisA, Execute:=TRUE);
                    IF prox THEN
                        McStop(Axis:=AxisA, Execute:=FALSE);                
                        iState := 40;
                    END_IF
                    
                999: //Error handling
            END_CASE


11. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Configuring a stepper Motor
Running Stepper Motor with Beckoff EL4071 Slice

    Restart TwinCAT System in Config Mode
                Load Devices: Yes
                Free Run Mode: No
    Adding new Device and Configurations
        RightClick on Solution Explorer > I/O > Devices
            Add New Item
            Select EtherCAT > EtherCAT Master 
            Device 2 will appear
        Highlight Device 2
            Open up Adapter Tab
            Search > Select PCI Bus/Slot 3/0 Slot 7
        In SolutionExplorer, RightClick on Device2 and Scan
            Scan Motors? : Yes
            Append linked axis to: NC-Configuration
        In SolutionExplorer
            Open I/O > Device2 > Term1
                Inside will be the list of all the new devices found
                Take note of the names
            Open Motion > NC-Task1 > Axes
                Find stepper's interface, the name will appear in the Settings tab > Link To I/O textbox
            Disable the unwanted axis
    Activate Configuration
        In SolutionExplorer            
                Open Online Tab                
                    Check all boxes in Enabling section and click set
                    Reset(F8)
                    Switch drive ON (F5)
                    Jog (F1-F4)
                        Error: TCNC (500): error 6.187082 exceeds limit of 5.00 // 17744 (0x4550)
                        This is under controller error Error(Hex) Column 4550
                        Lag Distance: How for current distance is from your commanded distance
                            This can happen if you motor's overloaded or stalled
                            Otherwise, motor not configured properly
        In SolutionExplorer
            Open Motion > NC-Task1 > Axes > Axis
                Set Encoder
                    Open "Enc" and open NC-Encoder Tab
                    Under Type:
                        Select Simulation encoder since there is no encodeer for the stepper motor
                        This method bypass the physical encoder by linking the input command directly to the encoder input of PLC        
    Activate Configuration                    
        Reset, SwitchON and Jog
        Notice in the Online tab, the current position is out of the position but it can still run
    Stepper Motor
        Stepping
            1.8 degree/Step
            360 / 1.8 = 200 steps per revolution
        Microstepping
            Using PWM to increase the resolution by 64
            1.8/64 = 0.028125 degrees per microstep
            64*200 = 12800 steps per revolution
        Application
            Motor attached to a gear with 24 teeth. Pitch of belt tooth = 3mm
            24*3 = 72mm per rev, this will be the 'Feed Constant'
            72/12800 = 0.005625mm per step
    In SolutionExplorer
        Open Motion > NC-Task1 > Axes > Axis > Enc
            Open Parameter Tab
                Scaling Factor Numerator: Change 0.0001 to 0.005625
                Click on 'Download' and 'Save Now' to save into registry
                Scaling Factor Denominator
                    This is for the system to automatically calculate and adjust itself if a weird number like 0.0066666666666666666667 is set to the 'ScalingFactorNumerator' 
                    Because if without this being set, your conveyor will be out of position by half a meter the next day
                    Leave it at defauly 1.0
                Maximum Dynamics   
                    Use 'Stepper Calculation Tool' software
                        Input values and set base Frequency to 2000 fullsteps/sec
                            The higher the value, the faster it goes, but decreases the accuracy
                        Reference Velocity = 720 mm/sec
                    Input number 
                        Reference Velocity: 720
                        Maximum Velocity: 720
                Default Dynamics:
                    Default Acceleration: 167.0 (So it won't skip steps during acceleration)
                Download and Save        
        Open Motion > NC-Task1 > Axes > Axis
            Open Online Tab
                Target Velocity: 200 mm/s
                Reset(F8), Switch ON(F5) and Jog
                
    Inverting the motor rotation CW/CCW
        In SolutionExplorer
            Open Motion > NC-Task1 > Axes > Axis > Drive
                Open Parameter Tab
                    Output Settings 
                        Invert Motor Polarity: TRUE || FALSE
                        Make sure the change the counting direction as well
            Open Motion > NC-Task1 > Axes > Axis > Enc
                Open Parameter Tab
                    Encoder Evaluation 
                        Invert Encoder Counting Direction: TRUE || FALSE
                        
    Jogging with the Functions Tab                   
        In SolutionExplorer
            Open Motion > NC-Task1 > Axes > Axis
                Open Functions Tab
                    Target position: -10
                    Target Velocity: 100        
                Click Start button
                You can change Absolute or Relative



12. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    
Axis Homing (Using Stepper Motor) - 8 points
https://infosys.beckhoff.com/english.php?content=../content/1033/ax5000_usermanual/html/ax5000_homing.htm&id=
    Incremental encoders: 2 chanels(A, B)
    Absolute encoders: 7 channels Grey code
    https://www.phidgets.com/docs/Encoder_Primer
    
    NOTE: The Drive and Encoder parameters right now were inverted to TRUE
    Calibration Cam Search was also inverted
        NC-Task > Axes > Axis > Enc > Parameter Tab
            Homing: 
                Invert Direction for Calibration Cam Search: TRUE //The direction of travel to find home sensor
                Invert Direction for Sync Impulse Search: FALSE //The direction of travel to find sync pulse during homing
    In Program Main, change link for AxisA : AXIS_REF;
        SolutionExplorer > PLC > Project > Instance > PlcTaskInputs > MAIN.AxisA
            RightClick and click on Clear Link
            RightClink and then click on Change Link
                In dialog box,
                    Select Mtion > NC-Task1 > Axes > Axis > ToPlc > QB336.0, MC.NCTOPLC_AXIS_REF[256.0]
                    In NC, system doesn't care if it's a servo or stepper. This makes it easier to upgrade or downgrade the motor 

            //FUN - MAP - Main
                    FUNCTION MAP : DINT
                    VAR_INPUT
                        x : DINT;
                        in_min : DINT;
                        in_max: DINT;
                        out_min: DINT;
                        out_max: DINT;
                    END_VAR
            //FUN - MAP - Sub
                    IF ((in_max - in_min) + out_min) <> 0 THEN
                        MAP := DINT_TO_INT((x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min);
                    ELSE
                        MAP := 0;
                    END_IF
                    RETURN;
            
            //Program_Main - Main
                    VAR
                        heartbeat : BYTE;
                        one AT %Q* : BOOL; 
                        two AT %Q* : BOOL;
                        three AT %Q* : BOOL;
                        four AT %Q* : BOOL;
                        
                        prox AT %I* : BOOL; //Input
                        
                        //Dynamic throttling
                        Throttle AT %I* : INT;                                               
                        LastThrottle :INT;                                                                      
               
                        AxisA : AXIS_REF;                                                                      
               
                        McPower : MC_Power;                                                             
                        McReset : MC_Reset;                                                              
                        McJogging : MC_Jog;
                        
                        McVelocity : MC_MoveVelocity;
                        McStop : MC_Stop;
                        McHome : MC_HOME;                                                  //01. Add this
                        CurrentVelocityCmd : DINT;  
                        
                        iState : DINT;
                        
                    END_VAR           
                    
            //Program_Main - Sub
                    heartbeat := heartbeat + 1;                                                     
                    CurrentVelocityCmd := MAP(Throttle,29800, 22600, 0, 2800);    
                    IF CurrentVelocityCmd < 50 THEN
                        CurrentVelocityCmd := 0;                                                               
                    END_IF
                    AxisA.ReadStatus();
                    
                    McPower(Axis:=AxisA, Enable:=TRUE, Enable_Positive:=TRUE, Enable_Negative:=TRUE);  
                    McReset(Axis:=AxisA);
                    McJogging(Axis:=AxisA);
                    McHome (Axis := AxisA, bCalibrationCam := prox);      //02. Add this line, this assigns the proximity sensor to be the home switch under bCalibrationCam
                    
                    CASE iState OF
                        0: //Initialize
                            iState := 10;
                        
                        10: //Start Drive Reset
                            McHome (Axis := AxisA, Execute := FALSE);                           //03. Resetting
                            McReset(Axis:=AxisA, Execute:=TRUE);
                            IF McReset.Done THEN
                                iState := 20;
                            ELSIF McReset.Error THEN
                                iState := 999;
                            END_IF
                            
                        20: //Wait for Drive to reset
                            //IF McPower.Status THEN                                             //04. Remove
                            IF McPower.Status AND CurrentVelocityCmd > 1000 THEN        //05. Add this line. If the throttle (CurrentVelocityCmd) is more than 1000 (activated)
                                iState := 40;                                     
                            END_IF
                        
                        30:  //Wait for drive JOG command                         
                            McJogging(Axis:=AxisA, JogForward:=prox);    
                            
                        40: //Wait for velocity command                        
                            MCVelocity(
                                Axis:=AxisA,
                                Velocity:=CurrentVelocityCmd,
                                Acceleration:=10000,                                      
                                Deceleration:=10000,
                                Jerk:=1000000,                                                   
                                Direction:=MC_Direction.MC_Positive_Direction,
                                Execute:=prox   AND (LastThrottle<>Throttle)                
                            );
                            
                            IF NOT prox THEN
                                McVelocity(Axis:=AxisA, Execute:=FALSE);       
                                iState:=900;                                                       
                            END_IF
                            
                            LastThrottle := Throttle;                                             
                        
                        100:  //Start Homing Process                                               //06. Add Case 100, 110 and 200
                            //HomingMode := MC_homingMode.                             //07. Add this optional line to McHome bracket below for more options on homing
                            //Position :=                                      //08. Home Positioning options. In case you home to sensor but actual position is out by few mm. 
                            //                                                              //Use this line to fine tune so you don't end up with negative values
                            
                            McHome(Axis := AxisA, bCalibrationCam := prox, Execute := TRUE);
                            IF McHome.Busy THEN
                                iState := 110;
                            END_IF
                            
                        110:   //Homing running, wait for homing to complete.
                            IF McHome.Done AND NOT McHome.Error THEN
                                McHome(Axis := AxisA, Execute := FALSE);
                                iState := 200;
                            ELSIF McHome.Error THEN
                                McHome(Axis := AxisA, Execute := FALSE);
                                iState := 999;
                            END_IF

                        200:  //Homing Complete. Ready to Run
                            IF CurrentVelocityCmd > 1000 THEN
                                iState := 100;
                            END_IF
                        
                        900: //Stop Servo                                               
                            McStop(Axis:=AxisA, Execute:=TRUE);
                            IF prox THEN
                                McStop(Axis:=AxisA, Execute:=FALSE);                
                                iState := 40;
                            END_IF
                            
                        999: //Error handling
                    END_CASE

    Activate Configuration and Run to test

13. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MC_Absolute & MC_Relative - 7 points
How the motor will move
    1. Hit throttle, motor will move to prox, readjust and stop. This will be the home 0. Now you'll be in state 200
    2. Hit throttle again, motor will proceed with absolute move first to another position, then do relative move back and forth, and then abs return to 0
    3. Will repeat step 2 whenever throttle being activated

            //FUN - MAP - Main
                    FUNCTION MAP : DINT
                    VAR_INPUT
                        x : DINT;
                        in_min : DINT;
                        in_max: DINT;
                        out_min: DINT;
                        out_max: DINT;
                    END_VAR
            //FUN - MAP - Sub
                    IF ((in_max - in_min) + out_min) <> 0 THEN
                        MAP := DINT_TO_INT((x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min);
                    ELSE
                        MAP := 0;
                    END_IF
                    RETURN;
            
            //Program_Main - Main
                    VAR
                        heartbeat : BYTE;
                        one AT %Q* : BOOL; 
                        two AT %Q* : BOOL;
                        three AT %Q* : BOOL;
                        four AT %Q* : BOOL;
                        
                        prox AT %I* : BOOL; //Input
                        
                        //Dynamic throttling
                        Throttle AT %I* : INT;                                               
                        LastThrottle :INT;                                                                      
               
                        AxisA : AXIS_REF;                                                                      
               
                        McPower : MC_Power;                                                             
                        McReset : MC_Reset;                                                              
                        McJogging : MC_Jog;
                        
                        McVelocity : MC_MoveVelocity;
                        McStop : MC_Stop;
                        McHome : MC_HOME;                                                   
                        CurrentVelocityCmd : DINT;  
                        
                        iState : DINT;
                        
                        McMoveAbs : MC_MoveAbsolute;                            //01. Add this entire paragraph
                        McMoveRel : MC_MoveRelative;
                        iNumMoves : DINT := 5;
                        iCurrMove : DINT;
                        fMoveDistEachTime : REAL := 10;
                        fRelMoveDist : REAL;
                        
                    END_VAR           
                    
            //Program_Main - Sub
                    heartbeat := heartbeat + 1;                                                     
                    CurrentVelocityCmd := MAP(Throttle,29800, 22600, 0, 2800);    
                    IF CurrentVelocityCmd < 50 THEN
                        CurrentVelocityCmd := 0;                                                               
                    END_IF
                    
                    AxisA.ReadStatus();
                    
                    McPower(Axis:=AxisA, Enable:=TRUE, Enable_Positive:=TRUE, Enable_Negative:=TRUE);  
                    McReset(Axis:=AxisA);
                    McJogging(Axis:=AxisA);
                    McHome (Axis := AxisA, bCalibrationCam := prox);            
                    
                    McMoveAbs (Axis:=AxisA);                                        //02. Add thsese two lines
                    McMoveRel (Axis:=AxisA);
                    
                    CASE iState OF
                        0: //Initialize
                            iState := 10;
                        
                        10: //Start Drive Reset
                            McHome (Axis := AxisA, Execute := FALSE);           
                            McReset(Axis:=AxisA, Execute:=TRUE);
                            IF McReset.Done THEN
                                iState := 20;
                            ELSIF McReset.Error THEN
                                iState := 999;
                            END_IF
                            
                        20: //Wait for Drive to reset
                            //IF McPower.Status THEN                                                                  
                            IF McPower.Status AND CurrentVelocityCmd > 1000 THEN               
                                iState := 40;                                     
                            END_IF
                        
                        30:  //Wait for drive JOG command                         
                            McJogging(Axis:=AxisA, JogForward:=prox);    
                            
                        40: //Wait for velocity command                        
                            MCVelocity(
                                Axis:=AxisA,
                                Velocity:=CurrentVelocityCmd,
                                Acceleration:=10000,                                      
                                Deceleration:=10000,
                                Jerk:=1000000,                                                   
                                Direction:=MC_Direction.MC_Positive_Direction,
                                Execute:=prox   AND (LastThrottle<>Throttle)                
                            );
                            
                            IF NOT prox THEN
                                McVelocity(Axis:=AxisA, Execute:=FALSE);       
                                iState:=900;                                                       
                            END_IF
                            
                            LastThrottle := Throttle;                                             
                        
                        100:  //Start Homing Process                                                          
                            McHome(Axis := AxisA, bCalibrationCam := prox, Execute := TRUE);
                            IF McHome.Busy THEN
                                iState := 110;
                            END_IF
                            
                        110:   //Homing running, wait for homing to complete.
                            IF McHome.Done AND NOT McHome.Error THEN
                                McHome(Axis := AxisA, Execute := FALSE);
                                iState := 200;
                            ELSIF McHome.Error THEN
                                McHome(Axis := AxisA, Execute := FALSE);
                                iState := 999;
                            END_IF

                        200:  //Homing Complete. Ready to Run
                            IF CurrentVelocityCmd > 1000 THEN
                                iState := 300;                                                  //03. Change iState from 100 to 300
                            END_IF
                            
                        300: //Start ABS Move to center to prep for processing part             //04. Add in Cases from 300 to 510
                            McMoveAbs (                                                         //05. values will be in mm or mm/s
                                Axis := AxisA,
                                Position := 100,
                                Velocity := 100,                                               //06. max speed (vmax), 
                                Acceleration := 500,                                           //read up about triangle move where the two points of acc and dec point meets
                                Deceleration := 500,
                                Jerk := 100000,                                               //07. The second derivative of velocity,  derivative of acceleration
                                Execute := TRUE                                             //Jerk is for easing the motor from acceleration to vmax and to deceleration,
                            );                                                              //smoothening out the motion. The lower the number of Jerk, the smoother it is
                            iState := 310;
                        
                        310:    //Wait for abs move to complete
                            IF McMoveAbs.Done AND NOT McMoveAbs.Error THEN
                                McMoveAbs (Axis := AxisA, Execute := FALSE);
                                iCurrMove := 1;
                                iState := 400;
                            ELSIF McMoveAbs.Error THEN
                                McMoveAbs (Axis := AxisA, Execute := FALSE);
                                iState := 999;
                            END_IF
                        
                        400:    //Start Rel Move
                            //Do we have more to do? activated by case 460 as loop
                            IF iCurrMove < iNumMove THEN
                                //increment movecountrer for next time.
                                iCurrMove := iCurrMove + 1;
                                //Calculate Distance
                                fRelMoveDist := DINT_TO_REAL(iCurrMove) * fMoveDistEachTime;
                                iState := 410;
                            ELSE
                                //Nothing to do
                                iState := 500;
                            END_IF
                        
                        410: //Start rel move in pos direction
                            McMoveRel (
                                Axis := AxisA,
                                Distance := fRelMoveDist,
                                Velocity := 720,
                                Acceleration := 2000,
                                Deceleration := 2000,
                                Jerk := 1000000,
                                Execute := TRUE
                            );
                            iState := 420;
                        
                        420: //Wait on rel move to complete
                            IF McMoveRel.Done AND NOT McMoveRel.Error THEN
                                McMoveRel (Axis := AxisA, Execute := FALSE);
                                iState := 450;
                            ELSIF McMoveRel.Error THEN
                                McMoveRel (Axis := AxisA, Execute := FALSE);
                                iState := 999;
                            END_IF
                        
                        450: //Move negative rel back to start position
                            McMoveRel (
                                Axis := AxisA,
                                Distance := -fRelMoveDist,
                                Velocity := 720,
                                Acceleration := 2000,
                                Deceleration := 2000,
                                Jerk := 1000000,
                                Execute := TRUE
                            );
                            iState := 460;
                        
                        460: //Wait on rel move to complete
                            IF McMoveRel.Done AND NOT McMoveRel.Error THEN
                                McMoveRel (Axis := AxisA, Execute := FALSE);
                                iState := 400;
                            ELSIF McMoveRel.Error THEN
                                McMoveRel (Axis := AxisA, Execute := FALSE);
                                iState := 999;
                            END_IF
                        
                        500: //Start ABS Move Back to Home position 0
                            McMoveAbs (
                                Axis := AxisA,
                                Position := 0,
                                Velocity := 100,
                                Acceleration := 100,
                                Deceleration := 100,
                                Jerk := 100000,
                                Execute := TRUE
                            );
                            
                            iState := 510;
                            
                        510: //Wait for abs move to complete
                            IF McMoveAbs.Done AND NOT McMoveAbs.Error THEN
                                McMoveAbs (Axis := AxisA, Execute := FALSE);
                                iCurrMove := 1;
                                iState := 200;
                            ELSIF McMoveAbs.Error THEN
                                McMoveAbs (Axis := AxisA, Execute := FALSE);
                                iState := 999;
                            END_IF
                        
                        900: //Stop Servo                                               
                            McStop(Axis:=AxisA, Execute:=TRUE);
                            IF prox THEN
                                McStop(Axis:=AxisA, Execute:=FALSE);                
                                iState := 40;
                            END_IF
                            
                        999: //Error handling
                    END_CASE








