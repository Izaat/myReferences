TIPS: When in doubt about the naming conventions or spellings, press CTRL + Spacebar
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CONTENTS
01. Connecting to the PLC
02. TwinCAT - Connecting
03. Testing part 1
04. Testing part 2
05. EtherCAT
06. Numeric Control
07. PLCOpen Standards
08. MC_Power, MC_Reset, MC_Jog
09. MC_Velocity
10. Using game throttle to control motor speed

01. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CONNECTING TO PLC
            Connecting to the PLC
                ControlPanel > NetworkInternet > NetworkConnections > LocalAreaNetwork > RightClick > Properties
                NetworkTab > TCP/IPv4 > Properties > Advanced > IPSettingsTab > Add
                IP Address: 192.168.1.254
                Subnet: 255.255.255.0
                Now you network card has 2 IP addresses
                Open Angry IP Scanner > Just press Play nad it'll do a ping sweep
                PLC will pop up as 192.168.1.130
                WindowsStartButon > Run > "mstst"
                Remote Desktop Connection wll appear, set IP as PLC
                Click on "Connect" and Windows Security window will pop up
                Default Beckoff Administrator Password: 1
                This will lead you into the window embedded operating system in Beckoff PLC
                
            Connecting to Twincat
                Your PC's Windows > VisualStudio > File > New > Project
                Entire list of files will appear in Solution Explorer
                Select System and click on "Choose target" button
                Click on "Search (Ethernet)" > Type in the PLC's IP address on "Enter Hos Name" input box and click the button
                Remember the AMS NetId : 5.32.241.178.1.1
                RouteName(Target) = Host Name
                Make sure "hostname" check box is ticked and target route is "static"
                    Click on "Add Route" button
                                If it fails, try ping the Hostname/Routename example c:\ping CX-20F1B2
                If connecting via "hostname" fails, then check "IPaddress" checkbox and try again.
                     Username: Administrator
                     Password: 1
                Under connection column, there should be "X" which means it is connected
                Click on "Close" button
                You may start new plc project from now onwards 
                
            Testing out connection
                //MAIN(PRG) - Main
                    VAR
                        heartbeat : DINT;
                    END_VAR
                //MAIN(PRG) - Sub
                    heartbeat =:= heartbeat + 1;
                    
            Run program and heartbeat value will increase by increments of 1

END OF CONNECTING TO PLC


02. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TWINCAT - Connecting
        Under SolutionExplorer, Open up I/O folder and RightClick on Devices, the Insert Device 
            In Insert Device window, Dropdown EtherCAT and select EtherCAT Master
            A device will be added to TwinCat Project > I/O > Devices > Device 1 (EtherCAT)
            Select the device and go to the Adapter Tab
            Under NetworkAdapter > OS (NDIS), click on Search button and a list of devices will be listed down in a popup window 
            Select "Local Area Connection (TwinCAT-Intel PCI Ethernet Adapter (Gigabit))"
            Click on "Restart TwinCAT Config Mode", the blue icon button located above the the solution explorer under the menu (File, Edit, Etc) 
            Select Load I/O device in the prompt
            Rename "Device 1 (EtherCAT)" to "Local NIC (EtherCAT)"
            After renaming, the devices will expand and "Term 1 (EK1100)" will appear
            This includes all the input/output modules connected to the terminals 
            "WCState" is helpful when you're debugging as well as the Input and Output folders above the "InfoData" folder
            Save and activate the configuration by clicking on the "blue steps" icon located above the solution explorer
            A warning message will appear  "Device 'Local NIC" needs sync master (at least on variable lined to a task variable) - click ok
                Warning appears because there is no program being assigned
            You may "Login" to test the PLC

03. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TWINCAT - Testing part 1
        //Program_Main - Main
            VAR
                heartbeat : BYTE;
                one AT %Q* : BOOL;  //%Q* is the memory address where Q is the output and * means map handling, nowadays you don't have to add the * anymore
                two AT %Q* : BOOL;
                three AT %Q* : BOOL;
                four AT %Q* : BOOL;
                
                prox AT %I* : BOOL; //Input
            END_VAR

        //Program_Main - Sub
            heartbeat := heartbeat + 1;
            one := heartbeat MOD 2 = 0;         //This just means the system will take heartbeats, and modular divides it and check if the value equals to 0 , if yes, then the bit is ON
            two := heartbeat MOD 4 = 0;             //Basically it blinks n a sequence
            three := heartbeat MOD 8 = 0;
            four := heartbeat MOD 16 = 0;
            
        //Now go to Menu > Build > BuildSolution
        //Ignore the warning
        //RightClick on SolutionExplorer > Project > Term1 > Term4 > Channel1 > Output and select "ChangeLink", An "Attach Variable Output" window will appear
        //Untitled1 is the PLC runtime program
        //Expand the Instance and select MAIN.one > QB772192.0.BOOL[1,0]
        //Do the same for Channel 2 and assign its output to variable "MAIN.two"
        
        //Now go to SolutionExplorer > Project > Term1 > Term3 > Channel5 > Input and assign to "MAIN.prox"
        //Activate Configuration        //This should be click whenever you reassign the I/O address
        //Login and run
        //Select SolutionExplorer > Project > Term1 > Term4 > Channel1 > Output and open the "Online" tab to see the i/o graph

04. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TWINCAT - Testing part 2
        //Program_Main - Main
            VAR
                heartbeat : BYTE;
                one AT %Q* : BOOL; 
                two AT %Q* : BOOL;
                three AT %Q* : BOOL;
                four AT %Q* : BOOL;
                
                prox AT %I* : BOOL; //Input
            END_VAR

        //Program_Main - Sub
            heartbeat := heartbeat + 1;
            IF prox = TRUE THEN
                one := heartbeat MOD 2 = 0; 
                two := heartbeat MOD 4 = 0; 
                three := heartbeat MOD 8 = 0;
                four := heartbeat MOD 16 = 0;
            ELSE
                one := FALSE; 
                two := FALSE; 
                three := FALSE; 
                four := FALSE; 
            END_IF
            
        //Now test this by activating the sensor connected to Input 5
        //Once activated, the output will blink in sequence

05. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
EtherCAT
    //TopLeft port is input. The BottomLeft port and RightHand port is output
    //Layout
        PLC > EK1100 I/Os > Devices
    //OSI Layer             - EtherCAT
        7. Application     - Cyclic Data Exchange and Mailbox Acyclic Data Access
        6. Presentation   -  N/A      
        5. Session           -  N/A   
        4. Transport        -  N/A   
        3. Network          -  N/A   
        2. DataLink         - Process Data Mapping, AutoForwarder, Ethernet MAC
        1. Physical          - 100BASE-TX/FX
    
    //Determinism in fieldbuses- Time alignment between multiple layers irregardless of how fast
    //Real-time signal - how fast the port is listening to signals, the higher the hertrate, the higher the realtime performance.
    //EtherCAT is real-time deterministic fieldbus
    //CANopen protocol over EtherCAT (CoE) - application profiles for valves and controllers
    //Servodrive-Profile over EtherCAT (SoE) - comms interface for motion control applications


06. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Numerical Control - 
    //Adding a drive
            //Restart to Config mode and don't activate free run
            //Under I/O > Devices > RightClick on NIC(EtherCAT) > Scan
            //Then you can add or remove any devices you want 
            //Once done, Activate configuration, Run mode, login and run
            //Click on I/O > Devices > NIC (EtherCAT) and head to the center panel and open up "Online" tab
            //Add: 1, Name: Drive7 (AX52##), State: ERR PREOP INIT_ERR, CRC: 0.0 
            //Select "Op" in Actual State to see the send frames and other data to check the condition
            //Click on SlnExplorer > I/O > Devices > NIC(EtherCAT) > Drive and open the Drive manager tab in the center panel
            //You can see the error codes at the table under "Diagnostic Code" column
                //After making changes, click on "download" located below the list of tabs in the Drive Manager tab
                //Then click on "Activate configuration" from the menu
            //Under ChannelA, open the "Motor and Feedback"
            //Open the dropdown menu under "Feedback 1 connector" and select 14 X14(One cable feedback)
            //Click on "Scan feedback 1 / motor" and everything will be configured automatically
            //Make sure the DCLinkOk columns are green
            //Click on "Set NC Parameters" button and then click on "Activate Configuration" at the main menu
            //Restart TwinCat in runMode => OK            
    //Linking to NC
            //RightClick on SolutionExplorer > Project > Motion, then Add New Item and select NC/PTP Configuration (PTP = Point to Point)
            //A new dropdown (NC-Task) item will be added to the Motion subfolder
            //RightClick on NC-Task > Axes and add new item (ContinuousAxis, EncoderAxis, TimeGenerator, 2SpeedDiscreteAxis, LowCostStepperAxis)
            //Select ContinuousAxis and "Axis1" will appear under NC-Task > Axes
            //Under Axis1, go to the settings tab and click on "LinkToI/O" button
            //Change the setting, save and click on "Activate Configuration" again
            //Under Axis1, go to the Online tab. The number with the largest font size is the current position
            //Click on F8 to reset
            //To activate the limit switches, under "Enabling" section, click on set button and tick on Controller, FeedFw, FeedBw. Then F8(Reset) button
            //F5 to enable
    //Now you can jog the motor with F1 to F4

07. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
PLCOpen Standards
    Programming standards and libraries
    https://www.plcopen.org
    Adding Library
        RightClick on SolutionExplorer > Project > PLC > Project > Project > References, and click on AddLibrary
        Open Motion > PTP and add in Tc2_MC2 and Tc2_NC
    Add in "AxisA : AXIS_REF;" into the Program Main
    Add in "AxisA.ReadStatus();" into the Program Main - Sub
    Then go to Solution Explorer > TwinCAT > Motion > NC_Task > Axes > Axis 1 and open up settings tab
    Click on "Link to PLC" button and select Main.AxisA(Untitled Instance)
    Save and "Acitvate Configuration"
    Once on Run mode tab, open up AxisA tree
    //Example
        //Program_Main - Main
            VAR
                heartbeat : BYTE;
                one AT %Q* : BOOL; 
                two AT %Q* : BOOL;
                three AT %Q* : BOOL;
                four AT %Q* : BOOL;
                
                prox AT %I* : BOOL; //Input
                
                AxisA : AXIS_REF;
            END_VAR

        //Program_Main - Sub
            heartbeat := heartbeat + 1;
            IF prox = TRUE THEN
                one := heartbeat MOD 2 = 0; 
                two := heartbeat MOD 4 = 0; 
                three := heartbeat MOD 8 = 0;
                four := heartbeat MOD 16 = 0;
            ELSE
                one := FALSE; 
                two := FALSE; 
                three := FALSE; 
                four := FALSE; 
            END_IF    
            AxisA.ReadStatus();


08. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MC_Power, MC_Reset, MC_Jog
    //Program_Main - Main
            VAR
                heartbeat : BYTE;
                one AT %Q* : BOOL; 
                two AT %Q* : BOOL;
                three AT %Q* : BOOL;
                four AT %Q* : BOOL;
                
                prox AT %I* : BOOL; //Input
                
                AxisA : AXIS_REF;
                
                McPower : MC_Power;
                McReset : MC_Reset;
                McJogging : MC_Jog;
            END_VAR

        //Program_Main - Sub
            heartbeat := heartbeat + 1;
            AxisA.ReadStatus();
    
    //Under MAIN(Online) Tab, open up the McPower Tree
        Earlier, we activated these 3 manually. Now we have to activate them using PLC
            Enable, Enable_Position, Enable_Negative = Controller, FeedFw, FeedBw
        Override = Speed of axis

    //Program_Main - Main
            VAR
                heartbeat : BYTE;
                one AT %Q* : BOOL; 
                two AT %Q* : BOOL;
                three AT %Q* : BOOL;
                four AT %Q* : BOOL;
                prox AT %I* : BOOL; //Input
                AxisA : AXIS_REF;
                
                McPower : MC_Power;
                McReset : MC_Reset;
                McJogging : MC_Jog;
                iState : DINT;
            END_VAR

        //Program_Main - Sub
            heartbeat := heartbeat + 1;
            AxisA.ReadStatus();
            
            //McPower(Axis:=AxisA);
            McPower(Axis:=AxisA, Enable:=TRUE, Enable_Positive:=TRUE, Enable_Negative:=TRUE);      //Powering up the drive for Case State 20
            McReset(Axis:=AxisA);
            McJogging(Axis:=AxisA);
            
            CASE iState OF
                0: //Initialize
                    iState := 10;
                
                10: //Start Drive Reset
                    McReset(Axis:=AxisA, Execute:=TRUE);
                    IF McReset.Done THEN
                        iState := 20;
                    ELSE IF McReset.Error THEN
                        iState := 999;
                    END_IF
                    
                20: //Wait for Drive to reset
                    IF McPower.Status THEN             //This needs to be True. But in order to make it true, parameters (Enable, Enable_Positive, Enable_Negative)  
                        iState := 30;                  //need to be added into the McPower. See Above (//Powering up the drive)
                    END_IF
                
                30:  //Wait for drive command
                    McJogging(Axis:=AxisA, JogForward:=prox);               //The jogging is tied to the Digital input of the PLC
                    
                999: //Error handling
            END_CASE

        //At this point, you may save and run the program
        //Motor will rotate when you activate the proximity sensor

09. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MC_Velocity     == 11 points

    //Program_Main - Main
            VAR
                heartbeat : BYTE;
                one AT %Q* : BOOL; 
                two AT %Q* : BOOL;
                three AT %Q* : BOOL;
                four AT %Q* : BOOL;
                prox AT %I* : BOOL; //Input
                AxisA : AXIS_REF;
                
                McPower : MC_Power;
                McReset : MC_Reset;
                McJogging : MC_Jog;
                
                McVelocity : MC_MoveVelocity;
                McStop : MC_Stop;
                CurrentVelocityCmd : DINT;                        //01. Use for checking output and testing, 
                                                                  //no scale installed so we do not know the unit being used (mm/s or rpm) therefore the existence of this line
                iState : DINT;
                
            END_VAR
            
            
    //Program_Main - Sub
            heartbeat := heartbeat + 1;
            currentVelocityCmd := 1000;                           //02. Giving the value since we don't have the unit yet
            AxisA.ReadStatus();
            
            //McPower(Axis:=AxisA);
            McPower(Axis:=AxisA, Enable:=TRUE, Enable_Positive:=TRUE, Enable_Negative:=TRUE);  
            McReset(Axis:=AxisA);
            McJogging(Axis:=AxisA);
            
            CASE iState OF
                0: //Initialize
                    iState := 10;
                
                10: //Start Drive Reset
                    McReset(Axis:=AxisA, Execute:=TRUE);
                    IF McReset.Done THEN
                        iState := 20;
                    ELSE IF McReset.Error THEN
                        iState := 999;
                    END_IF
                    
                20: //Wait for Drive to reset
                    IF McPower.Status THEN           
                        iState := 40;                                 //04. To replace "Goto Case 30" with "Case 40"
                    END_IF
                
                30:  //Wait for drive JOG command                     //03. This will be assigned as Jogging command
                    McJogging(Axis:=AxisA, JogForward:=prox);    
                    
                40: //Wait for velocity command                       //05. To add thisline to make way for MC_Velocity command
                    MCVelocity(
                        Axis:=AxisA,
                        Velocity:=CurrentVelocityCmd,
                        Acceleration:=10000,                           //06. Value to be obtained through trial and error
                        Deceleration:=10000,
                        Jerk:=1000000,                                  //07. Change of acceleration limitation, and this value means no limit.
                        Direction:=MC_Direction.MC_Positive_Direction,
                        Execute:=prox                                   //08. This will execute on the rising edge of prox sensor. But this wont stop the motor hence we require a IF command to stop the motor
                    );
                    
                    IF NOT prox THEN
                        McVelocity(Axis:=AxisA, Execute:=FALSE);        //09. This stops the motor when proximity sensor is not activated
                        iState:=900;                                    //10. this will jump to case 900
                    END_IF
                    
                900: //Stop Servo                                       //11. This Will be the Stop function and will jump back to case 40
                    McStop(Axis:=AxisA, Execute:=TRUE);
                    IF prox THEN
                        McStop(Axis:=AxisA, Execute:=FALSE);                
                        iState := 40;
                    END_IF
                    
                999: //Error handling
            END_CASE



10. ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Using game throttle to control motor speed == 7 points
    
    //02. Add Functions MAP (FUN)
    //PLC > Project > Project > POU > Functions
    //FUN - MAP - Main
            FUNCTION MAP : DINT
            VAR_INPUT
                x : DINT;
                in_min : DINT;
                in_max: DINT;
                out_min: DINT;
                out_max: DINT;
            END_VAR
    //FUN - MAP - Sub
            IF ((in_max - in_min) + out_min) <> 0 THEN
                MAP := DINT_TO_INT((x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min);
            ELSE
                MAP := 0;
            END_IF
            RETURN;
    
    //Program_Main - Main
            VAR
                heartbeat : BYTE;
                one AT %Q* : BOOL; 
                two AT %Q* : BOOL;
                three AT %Q* : BOOL;
                four AT %Q* : BOOL;
                
                prox AT %I* : BOOL; //Input
                
                //Dynamic throttling
                Throttle AT %I* : INT;                                               
                LastThrottle :INT;                                                                      

                //01. For the game throttle. In order to know if its INT, go to SlnExplorer >> Term1 (EK1100)> Term2 (EL3255) 
                    //Where the throttle is connected> AI Standard Ch 1 > Value  > Open Online Tab
                    //under Value textbox, the number is in "counts" and the number in <9.09> represents the voltage //voltage and counts drops as soon as you crank the throttle
                    //under Variable tab, see "Type:". "Size:" is in bytes.
                    //Go to Menu > Build > BuildSolution 
                    // Once completed, RightClick on SlnExplorer >> Term2 > AI Standard Ch1 > Value, and select "ChangeLink"
                    //DoubleClick on "MAIN.Throttle", save file and click on "Activate Configuration"
                    //LogIn and Run the PLC
       
                AxisA : AXIS_REF;                                                                      
                //                                                                                              
                McPower : MC_Power;                                                             
                McReset : MC_Reset;                                                              
                McJogging : MC_Jog;
                
                McVelocity : MC_MoveVelocity;
                McStop : MC_Stop;
                CurrentVelocityCmd : DINT;  
                
                iState : DINT;
                
            END_VAR           
            
    //Program_Main - Sub
            heartbeat := heartbeat + 1;
            //currentVelocityCmd := 1000;                                         //03. Remove this line and add the followings
                CurrentVelocityCmd := MAP(Throttle,29800, 22600, 0, 2800);        //04. MAP(Input, No throttle, Max throttle, min speed of motor, max speed of motor )
                IF CurrentVelocityCmd < 50 THEN
                    CurrentVelocityCmd := 0;                                      //07. Adding the biting point to the throttle. Therefore throttle needs to crank more then 50 then motor will start
                END_IF
            AxisA.ReadStatus();
            
            //McPower(Axis:=AxisA);
            McPower(Axis:=AxisA, Enable:=TRUE, Enable_Positive:=TRUE, Enable_Negative:=TRUE);  
            McReset(Axis:=AxisA);
            McJogging(Axis:=AxisA);
            
            CASE iState OF
                0: //Initialize
                    iState := 10;
                
                10: //Start Drive Reset
                    McReset(Axis:=AxisA, Execute:=TRUE);
                    IF McReset.Done THEN
                        iState := 20;
                    ELSE IF McReset.Error THEN
                        iState := 999;
                    END_IF
                    
                20: //Wait for Drive to reset
                    IF McPower.Status THEN           
                        iState := 40;                                     
                    END_IF
                
                30:  //Wait for drive JOG command                         
                    McJogging(Axis:=AxisA, JogForward:=prox);    
                    
                40: //Wait for velocity command                        
                    MCVelocity(
                        Axis:=AxisA,
                        Velocity:=CurrentVelocityCmd,
                        Acceleration:=10000,                                      
                        Deceleration:=10000,
                        Jerk:=1000000,                                                   
                        Direction:=MC_Direction.MC_Positive_Direction,
                        Execute:=prox   AND (LastThrottle<>Throttle)                 //05. Adding LastThrottle not equals to throttle
                    );
                    
                    IF NOT prox THEN
                        McVelocity(Axis:=AxisA, Execute:=FALSE);       
                        iState:=900;                                                       
                    END_IF
                    
                    LastThrottle := Throttle;                                        //06. Changing the max every scan cycle
                    
                900: //Stop Servo                                               
                    McStop(Axis:=AxisA, Execute:=TRUE);
                    IF prox THEN
                        McStop(Axis:=AxisA, Execute:=FALSE);                
                        iState := 40;
                    END_IF
                    
                999: //Error handling
            END_CASE













