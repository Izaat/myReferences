Verilog Basics
//////////////////////////////////////////////////////////////////////////////////////////////////
CONTENTS
	01. Introduction
	02. Level of Abstraction
	03. Modules and Instantiation
	04. Simulation, Synthesis and Design Methodology
	05. Data Types
	06. Reg Data Types
	07. Net Data Types
	08. Vectors, Arrays, Memories, Parameters and Strings
	09. Operators
	10. Examples
	11. Gate Level Modeling
	12. Dataflow Modelling
	13. Behavioral Modeling
	14. Compiler Directive and System Tasks
	15. Task and Functions
	16. Test Bench Writing

//////////////////////////////////////////////////////////////////////////////////////////////////
01. Introduction
	
	Concurrency [Executed simultaneosly]
		Verilog and VHDL are concurrence languages
		C-Type languages are all sequential languages
		Python is not a C-Type Language, but is still is sequential
	Notion of Time
		HDLs includes notion of time
		Normal languages like C and Python do not have notion of time	
		
	C-Type Languages
		PHP, C, C++, Javascript, Dart, Swift, R
	Verilog
		Weakly Typed
		IEEE 1364-2001
		File Extension as *.v
		Describes the structure and behavior of electronic circuits
		Syntax is similar to C
		Case sensitive
		Simple Data-types
	VHDL
		Strongly typed and deterministic
			The code is longer compared to verilog
		File Extension as *.vhd
		Model the behavior and structure of digital systems at multiple abstraction levels
		Syntax based on Pascal and Ada
		Not case sensitive
		Complex data types


//////////////////////////////////////////////////////////////////////////////////////////////////
02. Level of Abstraction

	Four Levels of Abstraction
		Switch Level (Switching)
		Gate Level (Logic Gates Interconnection)
		Data Flow Level (Based on Equations)
		Behavioral Level (Based on Behavior of the Circuit)

	Switch Level
		Module Implemented in terms of switches
		Syntax: mos_name instance_name (output, data, control)
		Example:
			NMOS and PMOS are used as switches
			
			=======================
			module inverter(Q,A)
				input A;
				output Q;
				supply1 vdd;
				supplt0 vss;
				
				pmos p(Q,vdd,A);
				nmos n(Q,vss,A);
			endmodule
			=======================
			
			|  Vdd--------------+-----------
			|                   |
			|                |  |
			|              | +--+
			|         +---0| |      pmos
			|         |    | +--+
			|         |      |  |
			|  A -----+         +------ Q
			|         |      |  |
			|         |    | +--+
			|         +----| |      nmos
			|              | +--+
			|                |  |
			|                   |
			|  Vss--------------+-----------
			|
			| Notice the 2 MOSFETs
			
	Gate Level
		Syntax: Primitive_name instance_name(output, inputs)
		Example:
			
			=====================
			1. and G1(out, A, B);
			|           ____
			|    A-----|    \
			|          |     |----- out
			|    B-----|____/
			|
			=====================
			
			=====================
			2. nand G2(Y, A, B);
			|           ____
			|    A-----|    \
			|          |     |O---- Y
			|    B-----|____/
			|
			=====================

			=====================
			3. or G3(out, A, B);
			|           ___
			|    A-----\   \
			|           \   \----out 
			|           /   /
			|    B-----/___/
			|
			=====================

	Data Flow Level
		Register Transfer Level
		Module is designed by specifying data flow
		Signals are assigned by data manipulating equations
		Design is implemented using continuous assignments
		All assignments are concurent in nature
		
		Example:
			=====================
			"assign" keyword is used as variable for this example
			
			assign z = x & y;    //And
			assign p = q | r;    //Or
			assign z = ~y;       //Or
			
	Behavioral Level
		The highest level of abstraction provided by HDLs
		Describes the system by its behavior
		Elements like function, task and blocks can be used
		Two important constructs:
			Initial
			Always
		Example:
			=====================
			(2*1 mux)
			
			always@(i0, i1, sel)
			begin
				if(sel)
					out = i1;
				else
					out = i0;
			end
			=====================
		
//////////////////////////////////////////////////////////////////////////////////////////////////
03. Modules and Instantiation

	Modules
		Basic building block in Verilog
		Can be an element or a collection of lower level design blocks
		Provides required functionality to the higher level block through its port interface but hide internal implementation
		Provides flexibility to the designer to modify the module internals without affecting the rest of the design
		
		Verilog Framework
		=============================
		module module_name (x,y,z);
			input x,y;
			output z;
			statements;
			............;
			............;
		endmodule
		=============================
	
	Instantiation
		Allows the creation of hierarchy in Verilog description
		A process of creating object from a module template and the objects are called instances
		In Verilog, nesting is illegal
		One module definition cannot contain another module definition
		However, copies of other module can be incorporated by instantiating them


		Example: 4*1 mux using 2*1 mux
		=============================
		|
		|
		|               |\
		|      i0 ----> | \  2x1
		|               |  | mux
		|               |  |--------+
		|               |  |        |
		|      i1 ----> | /         |    |\
		|               |/ |     x1 +--->| \  2x1
		|                  |             |  | mux
		|                  |             |  |----> out
		|  +-------->------+     x2 +--->|  |
		|  |                        |    | /
		|  |            |\          |    |/ |
		|  |   i2 ----> | \  2x1    |       |
		|  |            |  | mux    |      /|\
		|  |            |  |--------+       |
		|  |            |  |                |
		|  |   i3 ----> | /                 |
		|  |            |/ |                |
		|  |               |                |
		|  +-------<-------+                |
		|                  |                |
		|                 /|\               |
		|                  |                |
		|                  |                |
		|                  s1               s0
		|
		|
		=============================
		
		Code
		=============================
		//2*1 mux
		module mux_2to1 (i0,i1,sel,out);
			input i0,i1,sel;
			output out;
			always@(i0,i1,sel)
			begin
				if(sel)
					out = i1;
				else
					out = i0;
			end
		endmodule
		
		//4*1 mux
		module mux_4to1 (i0, i1, i2, i3, s1, s0, out);
			input i0, i1, i2, i3, s1, s0;
			output out;
			wire x1, x2;
			
			mux_2to1 m1 (i0, i1, s1, x1);
			mux_2to1 m2 (i2, i3, s1, x2);
			mux_2to1 m3 (x1, x2, s0, out);
		endmodule
		=============================
			

	Verilog Keywords
		Case sensitive
		$, underscore, alphanumeric characters can be used
		
		Examples:
			Correct format:
				new_block
				new_block1
				new_block$
			Incorrect format:
				1new_block
				$new_block
				1_new_block

	Comments similar to C++
		Single line comments: --> //
		Multiple line comments --> /* example */



//////////////////////////////////////////////////////////////////////////////////////////////////
04. Simulation, Synthesis and Design Methodology

	Simulation
		Used for verifying the functionality of the digital design that is modeled using HDL like Verilog
		In simulation, apply different input stimulus to the design at different timing to check the RTL code behaves as intended.

		| 
		|          +-----------------+
		| Verilog  |                 |
		| Module ->|                 |
		|          |   Simulation    |--> Evaluation
		| Test     |                 |     Result
		| Bench -->|                 |
		|          +-----------------+
		|
		
	Synthesis
		A process where the design is modeled using HDL is translated into an implementation consisting of logic gates
		It makes an optimal design based on the working strategy
		It gives the consumption of resources as available
		
		| 
		|          +-----------------+
		|          |                 |
		| Verilog  |                 |--> ASIC
		| Module-->|    Synthesis    |
		|          |                 |--> FPGA
		|          |                 |
		|          +-----------------+
		|

	Design Methodologies
		Top Down
			Define the top level block and identify the sub blocks necessary to build the top level blocks
			Sub Blocks are further subdivided until it cannot be subdivided further (Leaf cells)
			Looks similar to organisation chart
		
		Bottom Up
			Identify the building blocks that are available (Leaf cells)
			Combine these building blocks to build the bigger blocks
			These cells are then used for higher level blocks
			Continue until top-level block is established
			Instead of starting from top level block, this method starts from leaf cells

//////////////////////////////////////////////////////////////////////////////////////////////////
05. Data Types

	Specifies which type of value can be assigned to a variable
	What type of mathematical operation can be applied to the data type
	2 types of data type:
		Registers
		Nets
		
	Register Data Type
		Represents data storage elements
		A variable that can hold a value
		Commonly declared by keyword "reg"
		Default value of register data type is "X"
		Register represents a class of data types such as reg, integer, real, time, etc
		
	Net Data Type
		Represents connections between hardware elements
		Must be continuously driven i.e cannot be used to store values
		Declared primarily with the keyword "wire"
		Default value of net is "Z"
		Represents a class of data types such as wire, wand, wor, tri, triand, trior, trireg
		
	Values and Signal Strength
		Verilog supports 4 value levels and 8 strength levels to model the functionality of real hardware
		
		+--------+-------------------------+
		| Value  | Condition in Hardware   |
		| Levels |       Circuits          |
		+--------+-------------------------+
		|   0    | Logic Zero, false cond  |
		|   1    | Logic One, true cond    |
		|   X    | Unknown Logic value     |
		|   Z    | High Impedance, Float   |
		+--------+-------------------------+

		+-----------+-----------+----------------+
		| Degree    | Strength  | Type           |
		|           | Level     |                |
		+-----------+-----------+----------------+
		| Strongest | supply    | Driving        |
		|    / \    | strong    | Driving        |
		|   /_|_\   | pull      | Driving        |
		|     |     | large     | Storage        |
		|     |     | weak      | Driving        |
		|     |     | medium    | Storage        |
		|     |     | small     | Storage        |
		|   Weak    | highz     | High Impedance |
		+-----------+-----------+----------------+
		
		+-----------------------------------------+
		| supply1 o--------+                      |
		|                  |-------o supply1      |
		| pull1   o--------+                      |
		+-----------------------------------------+
		If two signals of unequal strength are driven on a wire, the stronger signal prevails
		
		+-----------------------------------------+
		| strong1 o--------+                      |
		|                  |-------o X            |
		| strong0 o--------+                      |
		+-----------------------------------------+
		If two signals of equal strengths are driven on a wire, result will be unknown

	Port Assignments
		Input - internally net
		Output - internally reg or net, externally net
		Inout - only wire data type
	
		Input
		+---------------------------------------+
		|             +----------------+        |
		|             |     module     |        |
		|             |                |        |
		| reg or net  |  net           |        |
		|     ------->+---->           |        |
		|    input    |                |        |
		|             +----------------+        |
		+---------------------------------------+
		
		Output
		+---------------------------------------+
		|             +----------------+        |
		|             |     module     |        |
		|             |                |        |
		|             |     reg or net |  net   |       
		|             |         ------>+---->   |       
		|             |                | Output |       
		|             +----------------+        |
		+---------------------------------------+
		
		Inout
		+---------------------------------------+
		|             +----------------+        |
		|             |     module     |        |
		|             |                |        |
		|      net    |  net           |        |
		|     <------>+<--->           |        |
		|    inout    |                |        |
		|             +----------------+        |
		+---------------------------------------+

//////////////////////////////////////////////////////////////////////////////////////////////////
06. Register Data Types

	Represents data storage elements
	A variable that can hold a value
	Commonly declared by keyword "reg"
	Default value of register data type is "X"
	Register represents a class of data types such as reg, integer, real, time, etc
		reg: most widely used
		integer: used for loop counting
		real: used for storing float point numbers
		time: keeps track of simulation time
		
	Example:
		reg count;         //single bit register variable
		reg [7:0] bus;     //8 bit bus
		
		=================================
		reg reset;
		initial
		begin
		reset = 1'b0;         //reset to 0
		#10 reset = 1'b1;     //after 10 counts delay will be value of 1
		#10 reset = 1'b0;     //after 10 counts delay will be value of 0
		end
		=================================
	
	Integer Data Type
		A general purpose register data type
		Declared by the keyword "integer"
		Store the values as quantities eg. 0, 4, -17, -148, etc
		Used for counting
		Synthesizeable 
		Default value is "X"
		Default width is 32bits
		
		Example:
		=================================
		integer count, new_num;
		initial
		begin
		count = 4;
		new_num = -17;
		end
		=================================
		
	Real Data Type
		Declared as "real"
		Allows decimal and scientific notation eg. 0.3, 4.63, -17.5, -1.485, etc
		Not synthesizeable
		Default value is 0.0
		Rounded off to nearest integer when it is assigned to an integer
		
		Example1:
		=================================
		real count, new_num;   //2 variables
		initial 
		begin
		count = 4.76;          //assigns "4.76" to count
		new_num = -1.3;        //assigns "-1.3" to new_num
		end
		=================================
		
		Example2:
		=================================
		integer a;
		real b;
		initial
		begin
		b = -6.5;
		a = b;     //a will be assigned as -7
		end
	
	Time Data Type
		Used to store timer
		Declared as keyword "time"
		Time variables are unsigned
		Width is implementation specific but is at least 64 bits
		Not synthesizeable (Useful for testbench)
		Default value is "X"
		
		Example1:
		=================================
		time new_sim_time;
		initial
		begin
		new_sim_time = $time;  //saves the current simulation time
		end

//////////////////////////////////////////////////////////////////////////////////////////////////
07. Net Data Types

	Represents connections between hardware elements
	Must be continuously driven, and connot be used to store values
	Declared primarily with keyword "wire"
	Default value of net is "Z"
	Represents a class of data types such as wire, wand, wor, tri, triand, trior, trireg
	The term "wor" and "wand" are simpy "wire OR gate" and "wire AND gate"
	To model power supply connection, "supply0" and "supply1" will be used 
	Both "wire" and "tri" are equivalent. 
		when there are multiple drivers driving them, the terms wor, wand, trior, triand will be used
	
	Wire
		
		|
		|           ____  
		|  a ------|     \
		|          | and  |---- c
		|  b ------|____ /
		|
		|
		|          +---------+
		|          |         |
		|  a ----->| Half    |----> sum
		|          | Adder   |
		|  b ----->|         |----> carry
		|          |         |
		|          +---------+
		
		Code
		====================================
		module half_add (a, b, sum, carry);
			input a, b;
			output sum, carry;
			wire sum, carry;
			
			assign sum = a^b;
			assign carry = a&b;
		endmodule
		====================================
		
	Wire OR and AND (wor, wand)
	
		|
		|           ____  
		|  a ------|     \
		|          | and  |----|
		|  b ------|____ /     |
		|                      |  
		|                      +---- y
		|           ____       |
		|  a ------\     \     |
		|           \ or  \----+
		|           /     /
		|  b ------/____ /
		|
		|
		
		Code: Y=(A&B)&(C|D)
		====================================
		module use_of_wire (y,A,B,C,D);
			input A, B, C, D;
			output y;
			wand y;
			
			assign y = A&B;
			assign y = C|D;
		endmodule
		====================================

	Supply1 and Supply0
		====================================
		module using_wire_supply(Y,A,B,C,D);
			input A,B,C,D;
			output Y;
			
			supply1 vdd;
			supply0 gnd;
			
			or G1(x1,A,gnd);
			and G2(x2,B,vdd);
			xor G3 (Y,x1,x2);
		endmodule
		====================================

	Numbers
		Syntax: <size>'<base><number>
		
		1'b1       //logic-1(1-bit) where "b" is binary
		8'h21      //8 bit number 0010 0001 where "h" is hexadecimal, 2 is 0010 and 1 is 0001
		12'ha35    //12 bit number 1010 0011 0101 where "h" is hexadecimal, "a" is 1010 in binary, 3 is 0011 and 5 is 0101
		12'o42xx   //12 bit number 100 010 xxx xxx where "o" is octal, 4 is 100, 2 is 010, x is xxx
		4'd1       //4 bit number 0001 where "d" is decimal
		35         //signed number, in 32 bits(size not specified)

		Binary: b or B
		Octal: o or O
		Decimal: d or D
		Hexadecimal: h or H 
		
		Use of underscores to improve readability
			"32'h64_ab" can also be written as "32'b 0110_0100_1010_1011"
			
		Zero, X, Z extension/filler
			4'bX0   //XXX_0 where 0 is binary and XXX_ is just an extension/filler to make it 4 bits
			5'd1    //0000_1 where 1 is decimal and 0000_ is just an extension/filler to make it 5 bits
			16'hz6  //ZZZZ_ZZZZ_ZZZZ_0110 where 0110 is hexadecimal of 6 and ZZZZ_ZZZZ_ZZZZ_ is just an extension/filler to make it 16 bits

//////////////////////////////////////////////////////////////////////////////////////////////////
08. Vectors, Arrays, Memories, Parameters and Strings

	Data types like "nets" and "regs" can be declared as vectors (multiple bit widths)
	If bit width is not specified, default size is scalar (1 bit)
	Vectors represents buses
	Vectors are declared by specifying the range [r1:r2] 
		Where r1 is always the most significant bit (MSB) and r2 is the least significant bit (LSB)
		[MSB:LSB]

	Example:
		====================================
		wire x,y,z;         //single bit variable aka scalars
		wire [15:0] data;   //16 bit data
		wire [0:31] sum;    //32 bit data, MSB is sum[0], LSB is sum[31]
		reg clock;          //scalar register, default
		reg [7:0] d1,d2,d3; //3 buses of 8 bit width
		reg [1:40] bus;     //vector register, 40 bit bus
		====================================
	
	Arrays
		Arrays are allowed to be used on data types like reg, integer, time, real, and vector
		Multi dimensional arrays can be declared with any number of dimensions
		
		Example:
		====================================
		reg [7:0] register_bank [15:0];   //16 by 8bit registers
		reg num [31:0];                   //array of 32 by 1 bit numbers
		====================================

		Example
			reg rega [0:7];           //an array of 8x 1 bit registers   
				|0|1|2|3|4|5|6|7|
				
			reg arraya [0:1] [0:3]    //Two dimensional array of 1 bit registers, reg arraya [rows] [columns]
				   |0|1|2|3|
				0. |x|x|x|x|
				1. |x|x|x|x|
				
			wire arrayw [0:7] [0:3]   //Two dimensional array of wires
				   |0|1|2|3|
				0. |x|x|x|x|
				1. |x|x|x|x|
				2. |x|x|x|x|
				3. |x|x|x|x|
				4. |x|x|x|x|
				5. |x|x|x|x|
				6. |x|x|x|x|
				7. |x|x|x|x|
				
	Memories
		Modeled as a one dimensional array of registers
		Used to model register files ie ROMs and RAMs
		Each element of the array is known as an element or word
		Elements are addressed by a single array index
		Each element can be of one or more bits
		
		Example
			reg mem_1bit [0:1023];       //Memory mem_1bit with 1K 1-bit words
				|  0 |
				|  1 |
				|  2 |
				|  . |
				|  . |
				|  . |
				|1023|
				
			reg [7:0] membyte [0:1023];  //Memory membyte with 1K 8bit words
			         |7|6|5|4|3|2|1|0|
			   0000. |0|0|0|0|0|0|0|0|
			   0001. |0|0|0|0|0|0|0|0|
			   0002. |0|0|0|0|0|0|0|0|
			   0003. |0|0|0|0|0|0|0|0|
			   .
			   .
			   .
			   1023. |0|0|0|0|0|0|0|0|

	Parameters
		Cannot be used as variables, it is a constant value
		Values for each module instance can be overridden individually at compile time
		This allows the module instances to be customized
		
		Example
			parameter width_new = 8;       //Defines width_new as a constant value of 8
			parameter depth_new = 256;     //Defines depth_new as a constant value of 256
			
	Strings
		Can be stored in reg
		Width of reg variables must be larger, enough to hold the string
		Each string character takes up 8bits(1byte)
		Sequence of characters enclosed by double quotes(" ")
		
		Example
			reg [8*10:1] string_value;       //Declaration, 8 bits with 10 characters
			string_value = "VLSI Point";     //Assignment of string

		Special Characters
			| \n |  newline |
			| \t |  tab     |
			| \% |  %       |
			| \\ |  \       |
			| \" |  "       |

//////////////////////////////////////////////////////////////////////////////////////////////////
09. Operators

	Arithemetic
		Unary
			Operators "+" and "-". Used to specify positive and negative sign and operands
			e.g "-4" or negative 4 and "+5" or positive 5
		Binary
			They are multiply(*), addition(+), subtract(-), power(**) and modulus(%)
			Binary operators take two operands
			If any operand bit has a value of x, then the result of the entire expression is x.
			
			Examples 1
				Where A = 4'b0010 and B = 4'b0011
				A and B are register vectors
				D, E, F are integers (D=7, E=4, F=2)
				
				A*B     //Multiply A and B to get 4'b0110
				D/E     //Divide D by E to get 1. Truncates any fractional part
				A+B     //Add A and B to get 4'b0101
				B-A     //Subtract A from B to get 4'b0001
				F=E**F  //E to the power of F which is 16
			
			Example 2
				If any operand bit has a value of x, then result is x
				a = 4'b001x; b = 4'b1011;
				sum = a+b;   //sum will be 4'bx which translates to "unknown"
				
				Modulus produce the remainder from the division of two numbers
				17%4   //Answer 1
				16%4   //Answer 0
				-7%2   //Answer -1, takes sign of the first operand (Applies only if either of the number is in negative)
				7%-2   //Answer +1, takes sign of the first operand (Applies only if either of the number is in negative)
				
	Logical
		Logical "AND": &&  //Binary Operator. Number of operands is 2
		Logical "OR": ||   //Binary Operator, Number of operands is 2
		Logical "NOT": !   //Unary Operator, Negation, Number of operands is 1
		
		Logical operators always evaluate to a one bit value; 1(true), 0(false), x(ambiguous)
		
		Example1 (A=5; B=0;)
			A&&B   //Output: 0
			A||B   //Output: 1
			!A     //Output: 0
			!B     //Output: 1
			
		Example2 (A=2'b0x; B=2'b10;)
			A&&B   //Output: x

	Bitwise
		Performs a bit by bit operation on 2 operands
		It takes each bit in one operand and perform the operation with the corresponding bit in another operand
		
		Bitwise AND: &            //Number of operands: 2 
		Bitwise OR: |             //Number of operands: 2
		Bitwise Negation/NOT: ~   //Number of operands: 1
		Bitwise XOR: ^            //Number of operands: 2
		Bitwise XNOR: ^~ or ~^    //Number of operands: 2
		
		Bitwise Truth Table
			+-----+---+---+---+
			| AND | 0 | 1 | x |
			|  0  | 0 | 0 | 0 |
			|  1  | 0 | 1 | x |
			|  x  | 0 | x | x |
			+-----+---+---+---+
			
			+-----+---+---+---+
			| OR  | 0 | 1 | x |
			|  0  | 0 | 1 | x |
			|  1  | 1 | 1 | 1 |
			|  x  | x | 1 | x |
			+-----+---+---+---+
			
			+-----+---+---+---+
			| XOR | 0 | 1 | x |
			|  0  | 0 | 1 | x |
			|  1  | 1 | 0 | x |
			|  x  | x | x | x |
			+-----+---+---+---+
			
			+-----+---+---+---+
			| XNOR| 0 | 1 | x |
			|  0  | 1 | 0 | x |
			|  1  | 0 | 1 | x |
			|  x  | x | x | x |
			+-----+---+---+---+
			
			+-----+-------+
			| NOT | Result|
			|  0  |   1   |
			|  1  |   0   |
			|  x  |   x   |
			+-----+-------+
		
		Example (X=4'b1010, Y=b1101, Z=4'b10x1)
			~X    //Negation. Output: 4'b0101
			X&Y   //AND. Output: 4'b1000
			X|Y   //OR. Output: 4'b1111
			X^Y   //XOR. Output: 4'b0111
			X^~Y  //XNOR. Output: 4'b1000
			X&Z   //Output: 4'b10x0

	Equality
		Logical Equal: ==       //Number of operands: 2
		Logical Not Equal: !=   //Number of operands: 2
		Case Equal: ===         //Number of operands: 2
		Case Not Equal: !==     //Number of operands: 2
		
		Returns 1(true) or 0(false)
		Difference between logical equality operators and case equality operators
			Logical Equality Operators do not include x and z
			Case Equality Operators include x and z
		
		Example: 
			A=4, B=3
			X=4'b1010, Y=4'b1101, Z=4'b1xxz
			M=4'b1xxz, N=4'b1xxx
			
			A==B      //Output: Logical 0
			X!=Y      //Output: Logical 1
			X==Z      //Output: x
			Z===M     //Output: Logical 1 (All bits match, including x and z)
			Z===N     //Output: Logical 0 (LSB does not match)
			M!==N     //Output: Logical 1

		Example
			m=5'b10x1z ; n='b10x1z
			m==n    //Output: x, the 2 logical equal operator cant process "x" and "z" values
			m===n   //Output: 1
	
	Relational
		Greater Than: >              //Number of operands: 2
		Less Than: <                 //Number of operands: 2
		Greater than or equal: >=    //Number of operands: 2
		Less than or equal: <=       //Number of operands: 2
		
		Return logical value of 1(true) or 0(false)
		
		Example: 
			A=4, B=3
			X=4'b1010, Y=4'b1101, Z=4'b1xxx		
		
			A<=B     //Output:0
			A>B      //Output:1
			Y>=X     //Output:1
			Y<Z      //Output:x
		
	Reduction
		AND: &         //Number of operands: 1
		OR: |          //Number of operands: 1
		NAND: ~&       //Number of operands: 1
		NOR: ~|        //Number of operands: 1
		XOR: ^         //Number of operands: 1
		XNOR: ~^, ^~   //Number of operands: 1
		
		It takes only one operand.
		Reduction operator performs a bitwise operation on a single vector operand and yield 1-bit result
		
		Example (X=4'b1010)
			&X    //Equivalent to 1&0&1&0. Output: 1'b0.
			|X    //Equivalent to 1|0|1|0. Output: 1'b1.
			^X    //Equivalent to 1^0^1^0. Output: 1'b0.
			
			Reduction XOR or XNOR can be used for even or odd parity generation of a vector

	Shift
		Right Shift: >>
		Left Shift: <<
		Arithemetic Left Shift: <<<
		Arithemetic Right Shift: >>>
		
		Regular shift operators shift a vector operand to the right or the left by a specified number of bits
		When the bits are shifted, the vacant bit positions are filled with zeros
		
		Arithemetic Shift Operators use the context of the expression to determine the value with which to fill the vacated bits
		
		Example1 (X=4'b1100)
			Y=X>>1       //Y is 4'b0110. Shift right 1 bit. 0 fills in MSB
			Y=X<<1       //Y is 4'b1000. Shift left 1 bit. 0 fills in LSB
			Y=X<<2       //Y is 4'b0000. Shift left 2 bits.
			Y=X>>>1      //Y is 4'b1110. Shift left 1 bit.
			
		Example2 
			integer a, b, c (Signed data types are 32bits)
			a=0, 
			b=-10            //11111111 11111111 11111111 11110110 (32bits)
			c=a+(b>>>3)      //Result is -2 decimal, by converting 11111111 11111111 11111111 11111101 to decimal

		Example3
			If Y=1101
			a=y>>1'b1   //a:0110, 0 added to MSB
			b=y>>>1'b1  //b:1110, 1 added to MSB
		
	Concatenation
		Concatenation: {, }
		
		Provides a mechanism to append multiple operands
		Operands must be sized
		Unisized operands are not allowed due to size of each operand must be known for computation of the size of the result
		Operands can be of the followings:
			scalar nets or registers, 
			vector nets or registers, 
			bit-select, 
			part-select, 
			sized constants
		
		Example: A=1'b1, B=2'b00, C=2'b10, D=3'b110
			Y={B,C}               //Output Y is 4'b0010
			Y={A,B,C,D,3'b001}    //Output Y is 11'b10010110001
			Y={A,B[0],C[1]}       //Output Y is 3'b101 
			Y={A,2{B},3{C}}       //Output Y is 11'b10000101010

		Example
			If "p" is a vector of length 10 bit, then find the value p for this expression
			p={2'bx1, 3'b101, 2'b10, 2{1'b1}}   //p: 10'b0x11011011, 0 added to MSB to form 10 bit from 9 bit
			
	Conditional (Similar to Ternary Operator in C++)
		Conditional operator(?:) takes three operands.
		
		Usage: condition_expr ? true_expr : false_expr;
			The condition expression (condition_expr) is first evaluated
			If the result is true, then the true_expr is evaluated.
			If the result is false, then the false_expr is evaluated
			
		Conditional operations can be nested:
			assign out = (A==3) ? (control ? x:y):(control ? m:n);

			C++ Equivalent
			======================
			if (A == 3) {
				if (control) {
					out = x;
				} else {
					out = y;
				}
			} else {
				if (control) {
					out = m;
				} else {
					out = n;
				}
			}
			======================

		The action of a conditional operator is similar to a multiplexer.
		Alternatively, it can be compared to a if-else expression
			+------------------------------------+
			|                                    |
			|               +-------------+      |
			| false_expr -> |0            |      |
			|               |             |      |
			|               |   2 to 1    |      |
			|               | multiplexer |->out |
			|               |             |      |
			| true_expr  -> |1            |      |
			|               +-------------+      |
			|                    /|\             |
			|                     |              |
			|                    cond_expr       |
			+------------------------------------+

		Example
			Finding value of q from the following
			m=2'b10, n=2'b1x;
			assign q = (m<n) ? 2'b10:2'b11;
			
			Result:
				q=2'bxx   //Unknown
				Relational operator is unable to merge "x" and "z"

	Operator Precedence
		+----------------------------+-------------------+------------+
		| Operators                  | Operator Symbols  | Precedence |
		+----------------------------+-------------------+------------+
		| Unary                      | + - ! ~           | Highest    |
		| Multiply, Divide, Modulus  | * / %             |            |
		| Add, Subtract              | + -               |            |
		| Shift                      | << >>             |            |
		| Relational                 | < <= > >=         |            |
		| Equality                   | == != === !==     |            |
		+----------------------------+-------------------+------------+
		|                            | & ~&              |            |
		| Reduction                  | ^ ^~              |            |
		|                            | | ~|              |            |
		+----------------------------+-------------------+------------+
		| Logical                    | &&                |            |
		|                            | ||                |            |
		+----------------------------+-------------------+------------+
		| Conditional                | ?:                | Lowest     |
		+----------------------------+-------------------+------------+

//////////////////////////////////////////////////////////////////////////////////////////////////
10. Examples
	
	Example 1:
		Find the value q for the following
		Given a=4'b0101 and y=4'b1100
		
		reg[3:0]q,a,y;
		assign q=a|y;  <- Bitwise OR operation will be performed
		
		Bitwise operation
			a=0101
			y=1100
			q=1101
			
		Answer:
			q=4'b1101

	Example 2:
		Find output of "c" and "f" from the following
		=================
		reg[3:0]a,b,c;
		integer d,e,f;
		initial
		begin
		a=4'b0011;
		b=4'b0001;
		d=7;
		e=3;
		c=a+b;    //Addition
		f=d/e;
		end
		=================
		
		Perform Addition to get "c"
			a=0011   //Decimal 3
			b=0001   //Decimal 1
			c=0100   //Decimal 4
			
			Therefore: c=4'b0100
			
		Perform Division for "f"
			d/e = 7/3 = 2.333
			Therefore f=2, since f is an integer and answer will be a truncated value
			
//////////////////////////////////////////////////////////////////////////////////////////////////
11. Gate Level Modeling
	
	Verilog has predefined inbuilt gate primitives
	It is the lowest level of abstraction
	All logic gates can be implemented using these gates
	There are two types of gates:
		Basic Gates (AND/OR, BUF/NOT)
		Bufif/Notif Gates
	
	Basic Gates (AND/OR, BUF/NOT)
	
		AND/OR Gates	
			One scalar output and multicalar inputs
			Output of a gate is evaluated as soon as one of the input changes
			The AND/OR gates available in verilog are:
				AND 
				OR 
				NAND 
				NOR 
				XOR
				XNOR
				
				Truth Tables
				+-----+---+---+---+---+
				| AND | 0 | 1 | x | z |
				|  0  | 0 | 0 | 0 | 0 |
				|  1  | 0 | 1 | x | x |
				|  x  | 0 | x | x | x |
				|  z  | 0 | x | x | x |
				+-----+---+---+---+---+
				
				+-----+---+---+---+---+
				| OR  | 0 | 1 | x | z |
				|  0  | 0 | 1 | x | x |
				|  1  | 1 | 1 | 1 | 1 |
				|  x  | x | 1 | x | x |
				|  z  | x | 1 | x | x |
				+-----+---+---+---+---+
				
				+-----+---+---+---+---+
				| NAND| 0 | 1 | x | z |
				|  0  | 1 | 1 | 1 | 1 |
				|  1  | 1 | 0 | x | x |
				|  x  | 1 | x | x | x |
				|  z  | 1 | x | x | x |
				+-----+---+---+---+---+
				
				+-----+---+---+---+---+
				| NOR | 0 | 1 | x | z |
				|  0  | 1 | 0 | x | x |
				|  1  | 0 | 0 | 0 | 0 |
				|  x  | x | 0 | x | x |
				|  z  | x | 0 | x | x |
				+-----+---+---+---+---+
				
				+-----+---+---+---+---+
				| XOR | 0 | 1 | x | z |
				|  0  | 0 | 1 | x | x |
				|  1  | 1 | 0 | x | x |
				|  x  | x | x | x | x |
				|  z  | x | x | x | x |
				+-----+---+---+---+---+
				
				+-----+---+---+---+---+
				| XNOR| 0 | 1 | x | z |
				|  0  | 1 | 0 | x | x |
				|  1  | 0 | 1 | x | x |
				|  x  | x | x | x | x |
				|  z  | x | x | x | x |
				+-----+---+---+---+---+
		
			Syntax: Primitive_naame instance_name (output, inputs)
			Example01:
				
				=====================
				| and G1(out,A,B);
				|           ____
				|    A-----|    \
				|          |     |----- out
				|    B-----|____/
				|
				=====================
		
				=====================
				| nand G2(out,A,B);
				|           ____
				|    A-----|    \
				|          |     |O----- out
				|    B-----|____/
				|
				=====================
		
				=====================
				| or G3(out,A,B);
				|           ___
				|    A-----\   \
				|           \   \----out 
				|           /   /
				|    B-----/___/
				|
				=====================
		
			Example02:
				
				=====================
				|           ____  and_gate
				|   I1-----|    \
				|          |     |----- O1
				|   I2-----|____/
				|
				|           ___   xor_gate
				|   I3-----\\   \  
				|           \\   \----out 
				|           //   /
				|   I4-----//___/
				|
				=====================
				
				module gate_eg(O1,O2,I1,I2,I3,I4);
					input I1,I2,I3,I4;
					output O1,O2;
					
					and and_gate(O1,I1,I2);
					xor xor_gate(O2,I3,I4);
				endmodule
			
			Example03:
				
				=========================================
				|                           ___  or_gate
				|   I1---------------------\   \
				|                           \   \_____O1
				|                           /   /
				|   I2---------------------/___/
				|
				|           ____ nand_gate    O2~not
				|   I2-----|    \           |\
				|          |     |----------| \_______O2
				|   I3-----|____/           | /
				|                           |/
				|
				|           ___  nor_gate     O3~not
				|   I3-----\   \            |\
				|           \   \-----------| \_______O3
				|           /   /           | /
				|   I4-----/___/            |/
				|
				|           ___  xor_gate     O4~not
				|   I3-----\\   \           |\
				|           \\   \----------| \_______O4
				|           //   /          | /
				|   I4-----//___/           |/
				=========================================
				
				module gate_eg(O1,O2,O3,O4,I1,I2,I3,I4,I5,I6,I7,I8);
					input I1,I2,I3,I4,I5,I6,I7,I8;
					output O1,O2,O3,O4;
					
					or(O1,I1,I2);
					nand(O2,I3,I4);
					nor(O3,I5,I6);
					xnor(O4,I7,I8);
				
				endmodule
				
		BUF/NOT Gates
			These type of gates have one scalar input and one scalar output
		
			|          buf
			|         |\
			|  in ____| \_______ out
			|         | /
			|         |/
			
			|          not
			|         |\
			|  in-----| \O------ out
			|         | /
			|         |/
		
			Truth Tables
			+-----+----+-----+
			| BUF | IN | OUT |
			|     |  0 |   0 |
			|     |  1 |   1 |
			|     |  x |   x |
			|     |  z |   x |
			+-----+----+-----+
			
			+-----+----+-----+
			| NOT | IN | OUT |
			|     |  0 |   1 |
			|     |  1 |   0 |
			|     |  x |   x |
			|     |  z |   x |
			+-----+----+-----+
			
			Example:
			
				|             buf_gate
				|             |\
				|  I1 ________| \_______ O1
				|      DATAIN | / OUT0
				|             |/
				|
				|              O2~not
				|             |\
				|  I2---------| \O------ O2
				|             | /
				|             |/
				
				module gate_eg(O1,O2,I1,I2);
					input I1,I2;
					output O1,O2;
					
					buf buf_gate(O1,I1);
					not not_gate(O2,I2);
				endmodule

	Bufif/Notif Gates
		These gates have additional control signal
		They propagate if the control signal is given otherwise the output will be in high state of impedence
		
		bufif1
			+------------------------------+
			|                              |
			|             |\               |
			|  in ________| \_______ out   |
			|             | /              |
			|             |/|              |
			|               |              |
			|      ctrl-----+              |
			+------------------------------+
	
		bufif0
			+------------------------------+
			|                              |
			|             |\               |
			|  in ________| \_______ out   |
			|             | /              |
			|             |/O              |
			|               |              |
			|      ctrl-----+              |
			+------------------------------+
	
		notif1
			+------------------------------+
			|                              |
			|             |\               |
			|  in ________| \O------ out   |
			|             | /              |
			|             |/|              |
			|               |              |
			|      ctrl-----+              |
			+------------------------------+
	
		notif0
			+------------------------------+
			|                              |
			|             |\               |
			|  in ________| \O------ out   |
			|             | /              |
			|             |/O              |
			|               |              |
			|      ctrl-----+              |
			+------------------------------+
	
		Truth Table
			+--------+---+---+---+---+
			| bufif1 | 0 | 1 | x | z |
			|   0    | z | 0 | L | L |
			|   1    | 0 | 1 | H | H |
			|   x    | z | x | x | x |
			|   z    | z | x | x | x |
			+--------+---+---+---+---+
	
			+--------+---+---+---+---+
			| bufif0 | 0 | 1 | x | z |
			|   0    | 0 | z | L | L |
			|   1    | 0 | 1 | H | H |
			|   x    | x | z | x | x |
			|   z    | x | z | x | x |
			+--------+---+---+---+---+
			
			+--------+---+---+---+---+
			| notif1 | 0 | 1 | x | z |
			|   0    | z | 1 | H | H |
			|   1    | z | 0 | L | L |
			|   x    | z | x | x | x |
			|   z    | z | x | x | x |
			+--------+---+---+---+---+
	
			+--------+---+---+---+---+
			| notif0 | 0 | 1 | x | z |
			|   0    | 1 | z | H | H |
			|   1    | 0 | z | L | L |
			|   x    | x | z | x | x |
			|   z    | x | z | x | x |
			+--------+---+---+---+---+
		
		Example
			+-----------------------------------+
			|                   OE              |
			|            +-------+              |
			|            |       |              |
			|            |       | not_gate1    |
			|            |     |\|              |
			|            |     | \_______ O2    |
			|    I2------|----O| /  OUT0        |
			|            |     |/               |
			| Control ---o                      |
			|            |      OE              |
			|            o-------+              |
			|            |       | buf_gate1    |
			|            |     |\|              |
			|            |     | \_______ O1    |
			|    I1------|-----| /  OUT0        |
			|            |     |/               |
			|            |                      |
			|            |      OE              |
			|            o-------+              |
			|            |       | buf_gate2    |
			|            |     |\O              |
			|            |     | \_______ O3    |
			|    I3------|-----| /  OUT0        |
			|            |     |/               |
			|            |      OE              |
			|            +-------+              |
			|                    | not_gate2    |
			|                  |\O              |
			|                  | \_______ O4    |
			|    I4-----------O| /  OUT0        |
			|                  |/               |
			|                                   |        
			|                                   | 			
			+-----------------------------------+
			
			module gate_eg(O1,O2,O3,O4,,I1,I2,I3,I4,Control);
				input I1,I2,I3,I4,Control;
				output O1,O2,O3,O4;
				
				bufif1 buf_gate1 (O1,I1,Control);
				notif1 not_gate1 (O2,I2,Control);
				
				bufif0 buf_gate2 (O3,I3,Control);
				notif0 not_gate2 (O4,I4,Control);
			endmodule

	Gate Delays
		Three types of delays
			Rise Delay
			Fall Delay
			Turn-off Delay
			
			Rise Delay
				Slows down the transition time from 0 to 1
				+--------------------------------------------+
				|                          |_____________ 1  |
				|                         /|                 |
				|                      | / |                 |
				|  0, x or z __________|/  |                 |
				|                      |   |                 |
				|                      t_rise                |
				+--------------------------------------------+

			Fall Delay
				Opposite of Rise Delay
				+--------------------------------------------+
				|  1, x or z __________|                     |
				|                      |\                    |
				|                      | \ |                 |
				|                      |  \|__________  0    |
				|                      |   |                 |
				|                      t_fall                |
				+--------------------------------------------+

			Turn-off Delay
				When gate output changes to high impedance(z) from any other logic (0,1,x)
				If the gate output changes to unknown(x), then minimum of three delays will be considered

				Syntax:
					For all transition
					gate_name #(delay_time) a1(output, inputs)
					
					For rise and fall delay specification
					gate_name #(rise_val,fall_val) a1(output, inputs)
					
					For rise fall and turnoff delay specification
					gate_name #(rise_val,fall_vall,turnoff_value) a1(output,inputs)

		Example01:
			+---------------------------------------------+
			|                                             |
			|            ____  and_gate                   |
			|   a ------|     \                           |
			|           | #5   |--+ e                     |
			|   b ------|____ /   |                       |
			|                     |     ____  or_gate     |
			|                     +----\    \             |
			|                           \    \_____out    |
			|                           / #4 /            |
			|   c ---------------------/____/             |
			|                                             |
			+---------------------------------------------+
			
			module D(a,b,c,out);
				input a,b,c;
				output out;
				wire e;
				
				and #(5) a1(e,a,b);
				or #(4) o1(out,e,c);
			endmodule
				
		Example02:
			+----------------------------------------+
			|                                        |
			|              ____  and_gate            |
			|    a ----+-O|    \                     |
			|          |  |  a1 |----- borrow        |
			|    b --+-|--|____/                     |
			|        | |                             |
			|        | |    ____ xor_gate            |
			|        | +---\\    \                   |
			|        |      \\ x1 \--- difference    |
			|        |      //    /                  |
			|        +-----//____/                   |
			|                                        |
			+----------------------------------------+

			module half_sub(borrow,difference,a,b);
				input a,b;
				output borrow,difference;
				wire w1;
				
				xor x1(difference,a,b);
				not n1(w1,a);
				and a1(borrow,w1,b);
			endmodule
				
		Example03:
			+----------------------------------------------------------------------------+
			|                                                                            |
			|              ____  and_gate                                                |
			|    a -------|    \           w1    ____  xor_gate                          |
			|             |  a1 |---------------\\    \             ____  and_gate       |
			|    b -------|____/                 \\ x1 \___________|     \               |
			|                                    //    /  w2       |  a2  |------- f     |
			|               ____ xor_gate   +---//____/       +----|____ /               |
			|    c --------\    \           |                 |                          |
			|               \ o1 \----------+-----------------+                          |
			|               /    /                      w3                               |
			|    d --------/____/                                                        |
			|                                                                            |
			+----------------------------------------------------------------------------+

			module circuit_eg(f,a,b,c,d);
			
				input a,b,c,d;
				output f;
				wire w1,w2,w3;
				
				and a1(w1,a,b);
				xor x1(w2,w1,w3);
				or o1(w3,c,d);
				and a2(f,w2,w3);
				
			endmodule

//////////////////////////////////////////////////////////////////////////////////////////////////
12. Dataflow Modelling






