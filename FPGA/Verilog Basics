Verilog Basics
//////////////////////////////////////////////////////////////////////////////////////////////////
CONTENTS
	01. Introduction
	02. Level of Abstraction
	03. Modules and Instantiation
	04. Simulation, Synthesis and Design Methodology
	05. Data Types
	06. Reg Data Types
	07. Net Data Types
	08. Vectors, Arrays, Memories, Parameters and Strings
	09. Operators
	10. Examples
	11. Gate Level Modeling
	12. Dataflow Modelling
	13. Behavioral Modeling
	14. System Tasks and Compiler Directive
	15. Task and Functions
	16. Test Bench Writing

//////////////////////////////////////////////////////////////////////////////////////////////////
01. Introduction
	
	Concurrency [Executed simultaneosly]
		Verilog and VHDL are concurrence languages
		C-Type languages are all sequential languages
		Python is not a C-Type Language, but is still is sequential
	Notion of Time
		HDLs includes notion of time
		Normal languages like C and Python do not have notion of time	
		
	C-Type Languages
		PHP, C, C++, Javascript, Dart, Swift, R
	Verilog
		Weakly Typed
		IEEE 1364-2001
		File Extension as *.v
		Describes the structure and behavior of electronic circuits
		Syntax is similar to C
		Case sensitive
		Simple Data-types
	VHDL
		Strongly typed and deterministic
			The code is longer compared to verilog
		File Extension as *.vhd
		Model the behavior and structure of digital systems at multiple abstraction levels
		Syntax based on Pascal and Ada
		Not case sensitive
		Complex data types


//////////////////////////////////////////////////////////////////////////////////////////////////
02. Level of Abstraction

	Four Levels of Abstraction
		Switch Level (Switching)
		Gate Level (Logic Gates Interconnection)
		Data Flow Level (Based on Equations)
		Behavioral Level (Based on Behavior of the Circuit)

	Switch Level
		Module Implemented in terms of switches
		Syntax: mos_name instance_name (output, data, control)
		Example:
			NMOS and PMOS are used as switches
			
			=======================
			module inverter(Q,A)
				input A;
				output Q;
				supply1 vdd;
				supplt0 vss;
				
				pmos p(Q,vdd,A);
				nmos n(Q,vss,A);
			endmodule
			=======================
			
			|  Vdd--------------+-----------
			|                   |
			|                |  |
			|              | +--+
			|         +---0| |      pmos
			|         |    | +--+
			|         |      |  |
			|  A -----+         +------ Q
			|         |      |  |
			|         |    | +--+
			|         +----| |      nmos
			|              | +--+
			|                |  |
			|                   |
			|  Vss--------------+-----------
			|
			| Notice the 2 MOSFETs
			
	Gate Level
		Syntax: Primitive_name instance_name(output, inputs)
		Example:
			
			=====================
			1. and G1(out, A, B);
			|           ____
			|    A-----|    \
			|          |     |----- out
			|    B-----|____/
			|
			=====================
			
			=====================
			2. nand G2(Y, A, B);
			|           ____
			|    A-----|    \
			|          |     |O---- Y
			|    B-----|____/
			|
			=====================

			=====================
			3. or G3(out, A, B);
			|           ___
			|    A-----\   \
			|           \   \----out 
			|           /   /
			|    B-----/___/
			|
			=====================

	Data Flow Level
		Register Transfer Level
		Module is designed by specifying data flow
		Signals are assigned by data manipulating equations
		Design is implemented using continuous assignments
		All assignments are concurent in nature
		
		Example:
			=====================
			"assign" keyword is used as variable for this example
			
			assign z = x & y;    //And
			assign p = q | r;    //Or
			assign z = ~y;       //Or
			
	Behavioral Level
		The highest level of abstraction provided by HDLs
		Describes the system by its behavior
		Elements like function, task and blocks can be used
		Two important constructs:
			Initial
			Always
		Example:
			=====================
			(2*1 mux)
			
			always@(i0, i1, sel)
			begin
				if(sel)
					out = i1;
				else
					out = i0;
			end
			=====================
		
//////////////////////////////////////////////////////////////////////////////////////////////////
03. Modules and Instantiation

	Modules
		Basic building block in Verilog
		Can be an element or a collection of lower level design blocks
		Provides required functionality to the higher level block through its port interface but hide internal implementation
		Provides flexibility to the designer to modify the module internals without affecting the rest of the design
		
		Verilog Framework
		=============================
		module module_name (x,y,z);
			input x,y;
			output z;
			statements;
			............;
			............;
		endmodule
		=============================
	
	Instantiation
		Allows the creation of hierarchy in Verilog description
		A process of creating object from a module template and the objects are called instances
		In Verilog, nesting is illegal
		One module definition cannot contain another module definition
		However, copies of other module can be incorporated by instantiating them


		Example: 4*1 mux using 2*1 mux
		=============================
		|
		|
		|               |\
		|      i0 ----> | \  2x1
		|               |  | mux
		|               |  |--------+
		|               |  |        |
		|      i1 ----> | /         |    |\
		|               |/ |     x1 +--->| \  2x1
		|                  |             |  | mux
		|                  |             |  |----> out
		|  +-------->------+     x2 +--->|  |
		|  |                        |    | /
		|  |            |\          |    |/ |
		|  |   i2 ----> | \  2x1    |       |
		|  |            |  | mux    |      /|\
		|  |            |  |--------+       |
		|  |            |  |                |
		|  |   i3 ----> | /                 |
		|  |            |/ |                |
		|  |               |                |
		|  +-------<-------+                |
		|                  |                |
		|                 /|\               |
		|                  |                |
		|                  |                |
		|                  s1               s0
		|
		|
		=============================
		
		Code
		=============================
		//2*1 mux
		module mux_2to1 (i0,i1,sel,out);
			input i0,i1,sel;
			output out;
			always@(i0,i1,sel)
			begin
				if(sel)
					out = i1;
				else
					out = i0;
			end
		endmodule
		
		//4*1 mux
		module mux_4to1 (i0, i1, i2, i3, s1, s0, out);
			input i0, i1, i2, i3, s1, s0;
			output out;
			wire x1, x2;
			
			mux_2to1 m1 (i0, i1, s1, x1);
			mux_2to1 m2 (i2, i3, s1, x2);
			mux_2to1 m3 (x1, x2, s0, out);
		endmodule
		=============================
			

	Verilog Keywords
		Case sensitive
		$, underscore, alphanumeric characters can be used
		
		Examples:
			Correct format:
				new_block
				new_block1
				new_block$
			Incorrect format:
				1new_block
				$new_block
				1_new_block

	Comments similar to C++
		Single line comments: --> //
		Multiple line comments --> /* example */



//////////////////////////////////////////////////////////////////////////////////////////////////
04. Simulation, Synthesis and Design Methodology

	Simulation
		Used for verifying the functionality of the digital design that is modeled using HDL like Verilog
		In simulation, apply different input stimulus to the design at different timing to check the RTL code behaves as intended.

		| 
		|          +-----------------+
		| Verilog  |                 |
		| Module ->|                 |
		|          |   Simulation    |--> Evaluation
		| Test     |                 |     Result
		| Bench -->|                 |
		|          +-----------------+
		|
		
	Synthesis
		A process where the design is modeled using HDL is translated into an implementation consisting of logic gates
		It makes an optimal design based on the working strategy
		It gives the consumption of resources as available
		
		| 
		|          +-----------------+
		|          |                 |
		| Verilog  |                 |--> ASIC
		| Module-->|    Synthesis    |
		|          |                 |--> FPGA
		|          |                 |
		|          +-----------------+
		|

	Design Methodologies
		Top Down
			Define the top level block and identify the sub blocks necessary to build the top level blocks
			Sub Blocks are further subdivided until it cannot be subdivided further (Leaf cells)
			Looks similar to organisation chart
		
		Bottom Up
			Identify the building blocks that are available (Leaf cells)
			Combine these building blocks to build the bigger blocks
			These cells are then used for higher level blocks
			Continue until top-level block is established
			Instead of starting from top level block, this method starts from leaf cells

//////////////////////////////////////////////////////////////////////////////////////////////////
05. Data Types

	Specifies which type of value can be assigned to a variable
	What type of mathematical operation can be applied to the data type
	2 types of data type:
		Registers
		Nets
		
	Register Data Type
		Represents data storage elements
		A variable that can hold a value
		Commonly declared by keyword "reg"
		Default value of register data type is "X"
		Register represents a class of data types such as reg, integer, real, time, etc
		
	Net Data Type
		Represents connections between hardware elements
		Must be continuously driven i.e cannot be used to store values
		Declared primarily with the keyword "wire"
		Default value of net is "Z"
		Represents a class of data types such as wire, wand, wor, tri, triand, trior, trireg
		
	Values and Signal Strength
		Verilog supports 4 value levels and 8 strength levels to model the functionality of real hardware
		
		+--------+-------------------------+
		| Value  | Condition in Hardware   |
		| Levels |       Circuits          |
		+--------+-------------------------+
		|   0    | Logic Zero, false cond  |
		|   1    | Logic One, true cond    |
		|   X    | Unknown Logic value     |
		|   Z    | High Impedance, Float   |
		+--------+-------------------------+

		+-----------+-----------+----------------+
		| Degree    | Strength  | Type           |
		|           | Level     |                |
		+-----------+-----------+----------------+
		| Strongest | supply    | Driving        |
		|    / \    | strong    | Driving        |
		|   /_|_\   | pull      | Driving        |
		|     |     | large     | Storage        |
		|     |     | weak      | Driving        |
		|     |     | medium    | Storage        |
		|     |     | small     | Storage        |
		|   Weak    | highz     | High Impedance |
		+-----------+-----------+----------------+
		
		+-----------------------------------------+
		| supply1 o--------+                      |
		|                  |-------o supply1      |
		| pull1   o--------+                      |
		+-----------------------------------------+
		If two signals of unequal strength are driven on a wire, the stronger signal prevails
		
		+-----------------------------------------+
		| strong1 o--------+                      |
		|                  |-------o X            |
		| strong0 o--------+                      |
		+-----------------------------------------+
		If two signals of equal strengths are driven on a wire, result will be unknown

	Port Assignments
		Input - internally net
		Output - internally reg or net, externally net
		Inout - only wire data type
	
		Input
		+---------------------------------------+
		|             +----------------+        |
		|             |     module     |        |
		|             |                |        |
		| reg or net  |  net           |        |
		|     ------->+---->           |        |
		|    input    |                |        |
		|             +----------------+        |
		+---------------------------------------+
		
		Output
		+---------------------------------------+
		|             +----------------+        |
		|             |     module     |        |
		|             |                |        |
		|             |     reg or net |  net   |       
		|             |         ------>+---->   |       
		|             |                | Output |       
		|             +----------------+        |
		+---------------------------------------+
		
		Inout
		+---------------------------------------+
		|             +----------------+        |
		|             |     module     |        |
		|             |                |        |
		|      net    |  net           |        |
		|     <------>+<--->           |        |
		|    inout    |                |        |
		|             +----------------+        |
		+---------------------------------------+

//////////////////////////////////////////////////////////////////////////////////////////////////
06. Register Data Types

	Represents data storage elements
	A variable that can hold a value
	Commonly declared by keyword "reg"
	Default value of register data type is "X"
	Register represents a class of data types such as reg, integer, real, time, etc
		reg: most widely used
		integer: used for loop counting
		real: used for storing float point numbers
		time: keeps track of simulation time
		
	Example:
		reg count;         //single bit register variable
		reg [7:0] bus;     //8 bit bus
		
		=================================
		reg reset;
		initial
		begin
		reset = 1'b0;         //reset to 0
		#10 reset = 1'b1;     //after 10 counts delay will be value of 1
		#10 reset = 1'b0;     //after 10 counts delay will be value of 0
		end
		=================================
	
	Integer Data Type
		A general purpose register data type
		Declared by the keyword "integer"
		Store the values as quantities eg. 0, 4, -17, -148, etc
		Used for counting
		Synthesizeable 
		Default value is "X"
		Default width is 32bits
		
		Example:
		=================================
		integer count, new_num;
		initial
		begin
		count = 4;
		new_num = -17;
		end
		=================================
		
	Real Data Type
		Declared as "real"
		Allows decimal and scientific notation eg. 0.3, 4.63, -17.5, -1.485, etc
		Not synthesizeable
		Default value is 0.0
		Rounded off to nearest integer when it is assigned to an integer
		
		Example1:
		=================================
		real count, new_num;   //2 variables
		initial 
		begin
		count = 4.76;          //assigns "4.76" to count
		new_num = -1.3;        //assigns "-1.3" to new_num
		end
		=================================
		
		Example2:
		=================================
		integer a;
		real b;
		initial
		begin
		b = -6.5;
		a = b;     //a will be assigned as -7
		end
	
	Time Data Type
		Used to store timer
		Declared as keyword "time"
		Time variables are unsigned
		Width is implementation specific but is at least 64 bits
		Not synthesizeable (Useful for testbench)
		Default value is "X"
		
		Example1:
		=================================
		time new_sim_time;
		initial
		begin
		new_sim_time = $time;  //saves the current simulation time
		end

//////////////////////////////////////////////////////////////////////////////////////////////////
07. Net Data Types

	Represents connections between hardware elements
	Must be continuously driven, and connot be used to store values
	Declared primarily with keyword "wire"
	Default value of net is "Z"
	Represents a class of data types such as wire, wand, wor, tri, triand, trior, trireg
	The term "wor" and "wand" are simpy "wire OR gate" and "wire AND gate"
	To model power supply connection, "supply0" and "supply1" will be used 
	Both "wire" and "tri" are equivalent. 
		when there are multiple drivers driving them, the terms wor, wand, trior, triand will be used
	
	Wire
		
		|
		|           ____  
		|  a ------|     \
		|          | and  |---- c
		|  b ------|____ /
		|
		|
		|          +---------+
		|          |         |
		|  a ----->| Half    |----> sum
		|          | Adder   |
		|  b ----->|         |----> carry
		|          |         |
		|          +---------+
		
		Code
		====================================
		module half_add (a, b, sum, carry);
			input a, b;
			output sum, carry;
			wire sum, carry;
			
			assign sum = a^b;
			assign carry = a&b;
		endmodule
		====================================
		
	Wire OR and AND (wor, wand)
	
		|
		|           ____  
		|  a ------|     \
		|          | and  |----|
		|  b ------|____ /     |
		|                      |  
		|                      +---- y
		|           ____       |
		|  a ------\     \     |
		|           \ or  \----+
		|           /     /
		|  b ------/____ /
		|
		|
		
		Code: Y=(A&B)&(C|D)
		====================================
		module use_of_wire (y,A,B,C,D);
			input A, B, C, D;
			output y;
			wand y;
			
			assign y = A&B;
			assign y = C|D;
		endmodule
		====================================

	Supply1 and Supply0
		====================================
		module using_wire_supply(Y,A,B,C,D);
			input A,B,C,D;
			output Y;
			
			supply1 vdd;
			supply0 gnd;
			
			or G1(x1,A,gnd);
			and G2(x2,B,vdd);
			xor G3 (Y,x1,x2);
		endmodule
		====================================

	Numbers
		Syntax: <size>'<base><number>
		
		1'b1       //logic-1(1-bit) where "b" is binary
		8'h21      //8 bit number 0010 0001 where "h" is hexadecimal, 2 is 0010 and 1 is 0001
		12'ha35    //12 bit number 1010 0011 0101 where "h" is hexadecimal, "a" is 1010 in binary, 3 is 0011 and 5 is 0101
		12'o42xx   //12 bit number 100 010 xxx xxx where "o" is octal, 4 is 100, 2 is 010, x is xxx
		4'd1       //4 bit number 0001 where "d" is decimal
		35         //signed number, in 32 bits(size not specified)

		Binary: b or B
		Octal: o or O
		Decimal: d or D
		Hexadecimal: h or H 
		
		Use of underscores to improve readability
			"32'h64_ab" can also be written as "32'b 0110_0100_1010_1011"
			
		Zero, X, Z extension/filler
			4'bX0   //XXX_0 where 0 is binary and XXX_ is just an extension/filler to make it 4 bits
			5'd1    //0000_1 where 1 is decimal and 0000_ is just an extension/filler to make it 5 bits
			16'hz6  //ZZZZ_ZZZZ_ZZZZ_0110 where 0110 is hexadecimal of 6 and ZZZZ_ZZZZ_ZZZZ_ is just an extension/filler to make it 16 bits

//////////////////////////////////////////////////////////////////////////////////////////////////
08. Vectors, Arrays, Memories, Parameters and Strings

	Data types like "nets" and "regs" can be declared as vectors (multiple bit widths)
	If bit width is not specified, default size is scalar (1 bit)
	Vectors represents buses
	Vectors are declared by specifying the range [r1:r2] 
		Where r1 is always the most significant bit (MSB) and r2 is the least significant bit (LSB)
		[MSB:LSB]

	Example:
		====================================
		wire x,y,z;         //single bit variable aka scalars
		wire [15:0] data;   //16 bit data
		wire [0:31] sum;    //32 bit data, MSB is sum[0], LSB is sum[31]
		reg clock;          //scalar register, default
		reg [7:0] d1,d2,d3; //3 buses of 8 bit width
		reg [1:40] bus;     //vector register, 40 bit bus
		====================================
	
	Arrays
		Arrays are allowed to be used on data types like reg, integer, time, real, and vector
		Multi dimensional arrays can be declared with any number of dimensions
		
		Example:
		====================================
		reg [7:0] register_bank [15:0];   //16 by 8bit registers
		reg num [31:0];                   //array of 32 by 1 bit numbers
		====================================

		Example
			reg rega [0:7];           //an array of 8x 1 bit registers   
				|0|1|2|3|4|5|6|7|
				
			reg arraya [0:1] [0:3]    //Two dimensional array of 1 bit registers, reg arraya [rows] [columns]
				   |0|1|2|3|
				0. |x|x|x|x|
				1. |x|x|x|x|
				
			wire arrayw [0:7] [0:3]   //Two dimensional array of wires
				   |0|1|2|3|
				0. |x|x|x|x|
				1. |x|x|x|x|
				2. |x|x|x|x|
				3. |x|x|x|x|
				4. |x|x|x|x|
				5. |x|x|x|x|
				6. |x|x|x|x|
				7. |x|x|x|x|
				
	Memories
		Modeled as a one dimensional array of registers
		Used to model register files ie ROMs and RAMs
		Each element of the array is known as an element or word
		Elements are addressed by a single array index
		Each element can be of one or more bits
		
		Example
			reg mem_1bit [0:1023];       //Memory mem_1bit with 1K 1-bit words
				|  0 |
				|  1 |
				|  2 |
				|  . |
				|  . |
				|  . |
				|1023|
				
			reg [7:0] membyte [0:1023];  //Memory membyte with 1K 8bit words
			         |7|6|5|4|3|2|1|0|
			   0000. |0|0|0|0|0|0|0|0|
			   0001. |0|0|0|0|0|0|0|0|
			   0002. |0|0|0|0|0|0|0|0|
			   0003. |0|0|0|0|0|0|0|0|
			   .
			   .
			   .
			   1023. |0|0|0|0|0|0|0|0|

	Parameters
		Cannot be used as variables, it is a constant value
		Values for each module instance can be overridden individually at compile time
		This allows the module instances to be customized
		
		Example
			parameter width_new = 8;       //Defines width_new as a constant value of 8
			parameter depth_new = 256;     //Defines depth_new as a constant value of 256
			
	Strings
		Can be stored in reg
		Width of reg variables must be larger, enough to hold the string
		Each string character takes up 8bits(1byte)
		Sequence of characters enclosed by double quotes(" ")
		
		Example
			reg [8*10:1] string_value;       //Declaration, 8 bits with 10 characters
			string_value = "VLSI Point";     //Assignment of string

		Special Characters
			| \n |  newline |
			| \t |  tab     |
			| \% |  %       |
			| \\ |  \       |
			| \" |  "       |

//////////////////////////////////////////////////////////////////////////////////////////////////
09. Operators

	Arithemetic
		Unary
			Operators "+" and "-". Used to specify positive and negative sign and operands
			e.g "-4" or negative 4 and "+5" or positive 5
		Binary
			They are multiply(*), addition(+), subtract(-), power(**) and modulus(%)
			Binary operators take two operands
			If any operand bit has a value of x, then the result of the entire expression is x.
			
			Examples 1
				Where A = 4'b0010 and B = 4'b0011
				A and B are register vectors
				D, E, F are integers (D=7, E=4, F=2)
				
				A*B     //Multiply A and B to get 4'b0110
				D/E     //Divide D by E to get 1. Truncates any fractional part
				A+B     //Add A and B to get 4'b0101
				B-A     //Subtract A from B to get 4'b0001
				F=E**F  //E to the power of F which is 16
			
			Example 2
				If any operand bit has a value of x, then result is x
				a = 4'b001x; b = 4'b1011;
				sum = a+b;   //sum will be 4'bx which translates to "unknown"
				
				Modulus produce the remainder from the division of two numbers
				17%4   //Answer 1
				16%4   //Answer 0
				-7%2   //Answer -1, takes sign of the first operand (Applies only if either of the number is in negative)
				7%-2   //Answer +1, takes sign of the first operand (Applies only if either of the number is in negative)
				
	Logical
		Logical "AND": &&  //Binary Operator. Number of operands is 2
		Logical "OR": ||   //Binary Operator, Number of operands is 2
		Logical "NOT": !   //Unary Operator, Negation, Number of operands is 1
		
		Logical operators always evaluate to a one bit value; 1(true), 0(false), x(ambiguous)
		
		Example1 (A=5; B=0;)
			A&&B   //Output: 0
			A||B   //Output: 1
			!A     //Output: 0
			!B     //Output: 1
			
		Example2 (A=2'b0x; B=2'b10;)
			A&&B   //Output: x

	Bitwise
		Performs a bit by bit operation on 2 operands
		It takes each bit in one operand and perform the operation with the corresponding bit in another operand
		
		Bitwise AND: &            //Number of operands: 2 
		Bitwise OR: |             //Number of operands: 2
		Bitwise Negation/NOT: ~   //Number of operands: 1
		Bitwise XOR: ^            //Number of operands: 2
		Bitwise XNOR: ^~ or ~^    //Number of operands: 2
		
		Bitwise Truth Table
			+-----+---+---+---+
			| AND | 0 | 1 | x |
			|  0  | 0 | 0 | 0 |
			|  1  | 0 | 1 | x |
			|  x  | 0 | x | x |
			+-----+---+---+---+
			
			+-----+---+---+---+
			| OR  | 0 | 1 | x |
			|  0  | 0 | 1 | x |
			|  1  | 1 | 1 | 1 |
			|  x  | x | 1 | x |
			+-----+---+---+---+
			
			+-----+---+---+---+
			| XOR | 0 | 1 | x |
			|  0  | 0 | 1 | x |
			|  1  | 1 | 0 | x |
			|  x  | x | x | x |
			+-----+---+---+---+
			
			+-----+---+---+---+
			| XNOR| 0 | 1 | x |
			|  0  | 1 | 0 | x |
			|  1  | 0 | 1 | x |
			|  x  | x | x | x |
			+-----+---+---+---+
			
			+-----+-------+
			| NOT | Result|
			|  0  |   1   |
			|  1  |   0   |
			|  x  |   x   |
			+-----+-------+
		
		Example (X=4'b1010, Y=b1101, Z=4'b10x1)
			~X    //Negation. Output: 4'b0101
			X&Y   //AND. Output: 4'b1000
			X|Y   //OR. Output: 4'b1111
			X^Y   //XOR. Output: 4'b0111
			X^~Y  //XNOR. Output: 4'b1000
			X&Z   //Output: 4'b10x0

	Equality
		Logical Equal: ==       //Number of operands: 2
		Logical Not Equal: !=   //Number of operands: 2
		Case Equal: ===         //Number of operands: 2
		Case Not Equal: !==     //Number of operands: 2
		
		Returns 1(true) or 0(false)
		Difference between logical equality operators and case equality operators
			Logical Equality Operators do not include x and z
			Case Equality Operators include x and z
		
		Example: 
			A=4, B=3
			X=4'b1010, Y=4'b1101, Z=4'b1xxz
			M=4'b1xxz, N=4'b1xxx
			
			A==B      //Output: Logical 0
			X!=Y      //Output: Logical 1
			X==Z      //Output: x
			Z===M     //Output: Logical 1 (All bits match, including x and z)
			Z===N     //Output: Logical 0 (LSB does not match)
			M!==N     //Output: Logical 1

		Example
			m=5'b10x1z ; n='b10x1z
			m==n    //Output: x, the 2 logical equal operator cant process "x" and "z" values
			m===n   //Output: 1
	
	Relational
		Greater Than: >              //Number of operands: 2
		Less Than: <                 //Number of operands: 2
		Greater than or equal: >=    //Number of operands: 2
		Less than or equal: <=       //Number of operands: 2
		
		Return logical value of 1(true) or 0(false)
		
		Example: 
			A=4, B=3
			X=4'b1010, Y=4'b1101, Z=4'b1xxx		
		
			A<=B     //Output:0
			A>B      //Output:1
			Y>=X     //Output:1
			Y<Z      //Output:x
		
	Reduction
		AND: &         //Number of operands: 1
		OR: |          //Number of operands: 1
		NAND: ~&       //Number of operands: 1
		NOR: ~|        //Number of operands: 1
		XOR: ^         //Number of operands: 1
		XNOR: ~^, ^~   //Number of operands: 1
		
		It takes only one operand.
		Reduction operator performs a bitwise operation on a single vector operand and yield 1-bit result
		
		Example (X=4'b1010)
			&X    //Equivalent to 1&0&1&0. Output: 1'b0.
			|X    //Equivalent to 1|0|1|0. Output: 1'b1.
			^X    //Equivalent to 1^0^1^0. Output: 1'b0.
			
			Reduction XOR or XNOR can be used for even or odd parity generation of a vector

	Shift
		Right Shift: >>
		Left Shift: <<
		Arithemetic Left Shift: <<<
		Arithemetic Right Shift: >>>
		
		Regular shift operators shift a vector operand to the right or the left by a specified number of bits
		When the bits are shifted, the vacant bit positions are filled with zeros
		
		Arithemetic Shift Operators use the context of the expression to determine the value with which to fill the vacated bits
		
		Example1 (X=4'b1100)
			Y=X>>1       //Y is 4'b0110. Shift right 1 bit. 0 fills in MSB
			Y=X<<1       //Y is 4'b1000. Shift left 1 bit. 0 fills in LSB
			Y=X<<2       //Y is 4'b0000. Shift left 2 bits.
			Y=X>>>1      //Y is 4'b1110. Shift left 1 bit.
			
		Example2 
			integer a, b, c (Signed data types are 32bits)
			a=0, 
			b=-10            //11111111 11111111 11111111 11110110 (32bits)
			c=a+(b>>>3)      //Result is -2 decimal, by converting 11111111 11111111 11111111 11111101 to decimal

		Example3
			If Y=1101
			a=y>>1'b1   //a:0110, 0 added to MSB
			b=y>>>1'b1  //b:1110, 1 added to MSB
		
	Concatenation
		Concatenation: {, }
		
		Provides a mechanism to append multiple operands
		Operands must be sized
		Unisized operands are not allowed due to size of each operand must be known for computation of the size of the result
		Operands can be of the followings:
			scalar nets or registers, 
			vector nets or registers, 
			bit-select, 
			part-select, 
			sized constants
		
		Example: A=1'b1, B=2'b00, C=2'b10, D=3'b110
			Y={B,C}               //Output Y is 4'b0010
			Y={A,B,C,D,3'b001}    //Output Y is 11'b10010110001
			Y={A,B[0],C[1]}       //Output Y is 3'b101 
			Y={A,2{B},3{C}}       //Output Y is 11'b10000101010

		Example
			If "p" is a vector of length 10 bit, then find the value p for this expression
			p={2'bx1, 3'b101, 2'b10, 2{1'b1}}   //p: 10'b0x11011011, 0 added to MSB to form 10 bit from 9 bit
			
	Conditional (Similar to Ternary Operator in C++)
		Conditional operator(?:) takes three operands.
		
		Usage: condition_expr ? true_expr : false_expr;
			The condition expression (condition_expr) is first evaluated
			If the result is true, then the true_expr is evaluated.
			If the result is false, then the false_expr is evaluated
			
		Conditional operations can be nested:
			assign out = (A==3) ? (control ? x:y):(control ? m:n);

			C++ Equivalent
			======================
			if (A == 3) {
				if (control) {
					out = x;
				} else {
					out = y;
				}
			} else {
				if (control) {
					out = m;
				} else {
					out = n;
				}
			}
			======================

		The action of a conditional operator is similar to a multiplexer.
		Alternatively, it can be compared to a if-else expression
			+------------------------------------+
			|                                    |
			|               +-------------+      |
			| false_expr -> |0            |      |
			|               |             |      |
			|               |   2 to 1    |      |
			|               | multiplexer |->out |
			|               |             |      |
			| true_expr  -> |1            |      |
			|               +-------------+      |
			|                    /|\             |
			|                     |              |
			|                    cond_expr       |
			+------------------------------------+

		Example
			Finding value of q from the following
			m=2'b10, n=2'b1x;
			assign q = (m<n) ? 2'b10:2'b11;
			
			Result:
				q=2'bxx   //Unknown
				Relational operator is unable to merge "x" and "z"

	Operator Precedence
		+----------------------------+-------------------+------------+
		| Operators                  | Operator Symbols  | Precedence |
		+----------------------------+-------------------+------------+
		| Unary                      | + - ! ~           | Highest    |
		| Multiply, Divide, Modulus  | * / %             |            |
		| Add, Subtract              | + -               |            |
		| Shift                      | << >>             |            |
		| Relational                 | < <= > >=         |            |
		| Equality                   | == != === !==     |            |
		+----------------------------+-------------------+------------+
		|                            | & ~&              |            |
		| Reduction                  | ^ ^~              |            |
		|                            | | ~|              |            |
		+----------------------------+-------------------+------------+
		| Logical                    | &&                |            |
		|                            | ||                |            |
		+----------------------------+-------------------+------------+
		| Conditional                | ?:                | Lowest     |
		+----------------------------+-------------------+------------+

//////////////////////////////////////////////////////////////////////////////////////////////////
10. Examples
	
	Example 1:
		Find the value q for the following
		Given a=4'b0101 and y=4'b1100
		
		reg[3:0]q,a,y;
		assign q=a|y;  <- Bitwise OR operation will be performed
		
		Bitwise operation
			a=0101
			y=1100
			q=1101
			
		Answer:
			q=4'b1101

	Example 2:
		Find output of "c" and "f" from the following
		=================
		reg[3:0]a,b,c;
		integer d,e,f;
		initial
		begin
		a=4'b0011;
		b=4'b0001;
		d=7;
		e=3;
		c=a+b;    //Addition
		f=d/e;
		end
		=================
		
		Perform Addition to get "c"
			a=0011   //Decimal 3
			b=0001   //Decimal 1
			c=0100   //Decimal 4
			
			Therefore: c=4'b0100
			
		Perform Division for "f"
			d/e = 7/3 = 2.333
			Therefore f=2, since f is an integer and answer will be a truncated value
			
//////////////////////////////////////////////////////////////////////////////////////////////////
11. Gate Level Modeling
	
	Verilog has predefined inbuilt gate primitives
	It is the lowest level of abstraction
	All logic gates can be implemented using these gates
	There are two types of gates:
		Basic Gates (AND/OR, BUF/NOT)
		Bufif/Notif Gates
	
	Basic Gates (AND/OR, BUF/NOT)
	
		AND/OR Gates	
			One scalar output and multicalar inputs
			Output of a gate is evaluated as soon as one of the input changes
			The AND/OR gates available in verilog are:
				AND 
				OR 
				NAND 
				NOR 
				XOR
				XNOR
				
				Truth Tables
				+-----+---+---+---+---+
				| AND | 0 | 1 | x | z |
				|  0  | 0 | 0 | 0 | 0 |
				|  1  | 0 | 1 | x | x |
				|  x  | 0 | x | x | x |
				|  z  | 0 | x | x | x |
				+-----+---+---+---+---+
				
				+-----+---+---+---+---+
				| OR  | 0 | 1 | x | z |
				|  0  | 0 | 1 | x | x |
				|  1  | 1 | 1 | 1 | 1 |
				|  x  | x | 1 | x | x |
				|  z  | x | 1 | x | x |
				+-----+---+---+---+---+
				
				+-----+---+---+---+---+
				| NAND| 0 | 1 | x | z |
				|  0  | 1 | 1 | 1 | 1 |
				|  1  | 1 | 0 | x | x |
				|  x  | 1 | x | x | x |
				|  z  | 1 | x | x | x |
				+-----+---+---+---+---+
				
				+-----+---+---+---+---+
				| NOR | 0 | 1 | x | z |
				|  0  | 1 | 0 | x | x |
				|  1  | 0 | 0 | 0 | 0 |
				|  x  | x | 0 | x | x |
				|  z  | x | 0 | x | x |
				+-----+---+---+---+---+
				
				+-----+---+---+---+---+
				| XOR | 0 | 1 | x | z |
				|  0  | 0 | 1 | x | x |
				|  1  | 1 | 0 | x | x |
				|  x  | x | x | x | x |
				|  z  | x | x | x | x |
				+-----+---+---+---+---+
				
				+-----+---+---+---+---+
				| XNOR| 0 | 1 | x | z |
				|  0  | 1 | 0 | x | x |
				|  1  | 0 | 1 | x | x |
				|  x  | x | x | x | x |
				|  z  | x | x | x | x |
				+-----+---+---+---+---+
		
			Syntax: Primitive_naame instance_name (output, inputs)
			Example01:
				
				=====================
				| and G1(out,A,B);
				|           ____
				|    A-----|    \
				|          |     |----- out
				|    B-----|____/
				|
				=====================
		
				=====================
				| nand G2(out,A,B);
				|           ____
				|    A-----|    \
				|          |     |O----- out
				|    B-----|____/
				|
				=====================
		
				=====================
				| or G3(out,A,B);
				|           ___
				|    A-----\   \
				|           \   \----out 
				|           /   /
				|    B-----/___/
				|
				=====================
		
			Example02:
				
				=====================
				|           ____  and_gate
				|   I1-----|    \
				|          |     |----- O1
				|   I2-----|____/
				|
				|           ___   xor_gate
				|   I3-----\\   \  
				|           \\   \----out 
				|           //   /
				|   I4-----//___/
				|
				=====================
				
				module gate_eg(O1,O2,I1,I2,I3,I4);
					input I1,I2,I3,I4;
					output O1,O2;
					
					and and_gate(O1,I1,I2);
					xor xor_gate(O2,I3,I4);
				endmodule
			
			Example03:
				
				=========================================
				|                           ___  or_gate
				|   I1---------------------\   \
				|                           \   \_____O1
				|                           /   /
				|   I2---------------------/___/
				|
				|           ____ nand_gate    O2~not
				|   I2-----|    \           |\
				|          |     |----------| \_______O2
				|   I3-----|____/           | /
				|                           |/
				|
				|           ___  nor_gate     O3~not
				|   I3-----\   \            |\
				|           \   \-----------| \_______O3
				|           /   /           | /
				|   I4-----/___/            |/
				|
				|           ___  xor_gate     O4~not
				|   I3-----\\   \           |\
				|           \\   \----------| \_______O4
				|           //   /          | /
				|   I4-----//___/           |/
				=========================================
				
				module gate_eg(O1,O2,O3,O4,I1,I2,I3,I4,I5,I6,I7,I8);
					input I1,I2,I3,I4,I5,I6,I7,I8;
					output O1,O2,O3,O4;
					
					or(O1,I1,I2);
					nand(O2,I3,I4);
					nor(O3,I5,I6);
					xnor(O4,I7,I8);
				
				endmodule
				
		BUF/NOT Gates
			These type of gates have one scalar input and one scalar output
		
			|          buf
			|         |\
			|  in ____| \_______ out
			|         | /
			|         |/
			
			|          not
			|         |\
			|  in-----| \O------ out
			|         | /
			|         |/
		
			Truth Tables
			+-----+----+-----+
			| BUF | IN | OUT |
			|     |  0 |   0 |
			|     |  1 |   1 |
			|     |  x |   x |
			|     |  z |   x |
			+-----+----+-----+
			
			+-----+----+-----+
			| NOT | IN | OUT |
			|     |  0 |   1 |
			|     |  1 |   0 |
			|     |  x |   x |
			|     |  z |   x |
			+-----+----+-----+
			
			Example:
			
				|             buf_gate
				|             |\
				|  I1 ________| \_______ O1
				|      DATAIN | / OUT0
				|             |/
				|
				|              O2~not
				|             |\
				|  I2---------| \O------ O2
				|             | /
				|             |/
				
				module gate_eg(O1,O2,I1,I2);
					input I1,I2;
					output O1,O2;
					
					buf buf_gate(O1,I1);
					not not_gate(O2,I2);
				endmodule

	Bufif/Notif Gates
		These gates have additional control signal
		They propagate if the control signal is given otherwise the output will be in high state of impedence
		
		bufif1
			+------------------------------+
			|                              |
			|             |\               |
			|  in ________| \_______ out   |
			|             | /              |
			|             |/|              |
			|               |              |
			|      ctrl-----+              |
			+------------------------------+
	
		bufif0
			+------------------------------+
			|                              |
			|             |\               |
			|  in ________| \_______ out   |
			|             | /              |
			|             |/O              |
			|               |              |
			|      ctrl-----+              |
			+------------------------------+
	
		notif1
			+------------------------------+
			|                              |
			|             |\               |
			|  in ________| \O------ out   |
			|             | /              |
			|             |/|              |
			|               |              |
			|      ctrl-----+              |
			+------------------------------+
	
		notif0
			+------------------------------+
			|                              |
			|             |\               |
			|  in ________| \O------ out   |
			|             | /              |
			|             |/O              |
			|               |              |
			|      ctrl-----+              |
			+------------------------------+
	
		Truth Table
			+--------+---+---+---+---+
			| bufif1 | 0 | 1 | x | z |
			|   0    | z | 0 | L | L |
			|   1    | 0 | 1 | H | H |
			|   x    | z | x | x | x |
			|   z    | z | x | x | x |
			+--------+---+---+---+---+
	
			+--------+---+---+---+---+
			| bufif0 | 0 | 1 | x | z |
			|   0    | 0 | z | L | L |
			|   1    | 0 | 1 | H | H |
			|   x    | x | z | x | x |
			|   z    | x | z | x | x |
			+--------+---+---+---+---+
			
			+--------+---+---+---+---+
			| notif1 | 0 | 1 | x | z |
			|   0    | z | 1 | H | H |
			|   1    | z | 0 | L | L |
			|   x    | z | x | x | x |
			|   z    | z | x | x | x |
			+--------+---+---+---+---+
	
			+--------+---+---+---+---+
			| notif0 | 0 | 1 | x | z |
			|   0    | 1 | z | H | H |
			|   1    | 0 | z | L | L |
			|   x    | x | z | x | x |
			|   z    | x | z | x | x |
			+--------+---+---+---+---+
		
		Example
			+-----------------------------------+
			|                   OE              |
			|            +-------+              |
			|            |       |              |
			|            |       | not_gate1    |
			|            |     |\|              |
			|            |     | \_______ O2    |
			|    I2------|----O| /  OUT0        |
			|            |     |/               |
			| Control ---o                      |
			|            |      OE              |
			|            o-------+              |
			|            |       | buf_gate1    |
			|            |     |\|              |
			|            |     | \_______ O1    |
			|    I1------|-----| /  OUT0        |
			|            |     |/               |
			|            |                      |
			|            |      OE              |
			|            o-------+              |
			|            |       | buf_gate2    |
			|            |     |\O              |
			|            |     | \_______ O3    |
			|    I3------|-----| /  OUT0        |
			|            |     |/               |
			|            |      OE              |
			|            +-------+              |
			|                    | not_gate2    |
			|                  |\O              |
			|                  | \_______ O4    |
			|    I4-----------O| /  OUT0        |
			|                  |/               |
			|                                   |        
			|                                   | 			
			+-----------------------------------+
			
			module gate_eg(O1,O2,O3,O4,,I1,I2,I3,I4,Control);
				input I1,I2,I3,I4,Control;
				output O1,O2,O3,O4;
				
				bufif1 buf_gate1 (O1,I1,Control);
				notif1 not_gate1 (O2,I2,Control);
				
				bufif0 buf_gate2 (O3,I3,Control);
				notif0 not_gate2 (O4,I4,Control);
			endmodule

	Gate Delays
		Three types of delays
			Rise Delay
			Fall Delay
			Turn-off Delay
			
			Rise Delay
				Slows down the transition time from 0 to 1
				+--------------------------------------------+
				|                          |_____________ 1  |
				|                         /|                 |
				|                      | / |                 |
				|  0, x or z __________|/  |                 |
				|                      |   |                 |
				|                      t_rise                |
				+--------------------------------------------+

			Fall Delay
				Opposite of Rise Delay
				+--------------------------------------------+
				|  1, x or z __________|                     |
				|                      |\                    |
				|                      | \ |                 |
				|                      |  \|__________  0    |
				|                      |   |                 |
				|                      t_fall                |
				+--------------------------------------------+

			Turn-off Delay
				When gate output changes to high impedance(z) from any other logic (0,1,x)
				If the gate output changes to unknown(x), then minimum of three delays will be considered

				Syntax:
					For all transition
					gate_name #(delay_time) a1(output, inputs)
					
					For rise and fall delay specification
					gate_name #(rise_val,fall_val) a1(output, inputs)
					
					For rise fall and turnoff delay specification
					gate_name #(rise_val,fall_vall,turnoff_value) a1(output,inputs)

		Example01:
			+---------------------------------------------+
			|                                             |
			|            ____  and_gate                   |
			|   a ------|     \                           |
			|           | #5   |--+ e                     |
			|   b ------|____ /   |                       |
			|                     |     ____  or_gate     |
			|                     +----\    \             |
			|                           \    \_____out    |
			|                           / #4 /            |
			|   c ---------------------/____/             |
			|                                             |
			+---------------------------------------------+
			
			module D(a,b,c,out);
				input a,b,c;
				output out;
				wire e;
				
				and #(5) a1(e,a,b);
				or #(4) o1(out,e,c);
			endmodule
				
		Example02:
			+----------------------------------------+
			|                                        |
			|              ____  and_gate            |
			|    a ----+-O|    \                     |
			|          |  |  a1 |----- borrow        |
			|    b --+-|--|____/                     |
			|        | |                             |
			|        | |    ____ xor_gate            |
			|        | +---\\    \                   |
			|        |      \\ x1 \--- difference    |
			|        |      //    /                  |
			|        +-----//____/                   |
			|                                        |
			+----------------------------------------+

			module half_sub(borrow,difference,a,b);
				input a,b;
				output borrow,difference;
				wire w1;
				
				xor x1(difference,a,b);
				not n1(w1,a);
				and a1(borrow,w1,b);
			endmodule
				
		Example03:
			+----------------------------------------------------------------------------+
			|                                                                            |
			|              ____  and_gate                                                |
			|    a -------|    \           w1    ____  xor_gate                          |
			|             |  a1 |---------------\\    \             ____  and_gate       |
			|    b -------|____/                 \\ x1 \___________|     \               |
			|                                    //    /  w2       |  a2  |------- f     |
			|               ____ xor_gate   +---//____/       +----|____ /               |
			|    c --------\    \           |                 |                          |
			|               \ o1 \----------+-----------------+                          |
			|               /    /                      w3                               |
			|    d --------/____/                                                        |
			|                                                                            |
			+----------------------------------------------------------------------------+

			module circuit_eg(f,a,b,c,d);
			
				input a,b,c,d;
				output f;
				wire w1,w2,w3;
				
				and a1(w1,a,b);
				xor x1(w2,w1,w3);
				or o1(w3,c,d);
				and a2(f,w2,w3);
				
			endmodule

//////////////////////////////////////////////////////////////////////////////////////////////////
12. Dataflow Modelling

	Continuous assignment (assign) statement, restriction on assign statement, implicit continuous statement
	Delays - assignment delay, implicit assignment delay, net delay
	Examples: Circuit in verilog using dataflow modelling
	
	Continuous assignment
		Used to derive a value onto a net. 
		Replaces gates in the description of the circuit 
		Describes the circuit at a higher level of abstraction
		Continuous assignment statement starts with the word "assign"
		
		Characteristics
			Left hand side of an assignment must always be a net type. Right hand side can be a reg or net
			Continuous assignment are always active
			Delay values can be specified for assignments in terms of time units
			
			Example 1 : Continuous assign
				assign out = in1 & in2;   //Out is a net. Both in1 and in2 are reg
				
			Example 2 : Concatenation
				assign {c_out, sum[3:0]} = a[3:0] + b[3:01] + c_in;   //Left is a concat of a scalar net (c_out) and a vector net (sum)

	Implicit continuous assignment
		Continuous assignment can be placed on a net when it is declared
		There can be only one implicit declaration assignment per net because a net is declared only once
		Instead of using two lines, single line can be used
		
		Example: Difference between Regular and Implicit
			//Regular continuous assignment
			wire out;
			assign out = in1 & in2;
			
			//Implicit continuous assignment
			wire out = in1 & in2;

	Delays
		Delay values control the time between the change in a right-hand-side operand and when the new value is assigned to the left-hand-side
		Three ways of specifying delays in continuous assignment statements	
			Regular assignment delay
			Implicit continuous assignment delay 
			Net declaration delay
			
		Regular Assignment Delay
			The delay value is specified after the keyword assign
			Any change in values of in1 or in2 will result in a delay of 10 time units before recomputation of the expression in in1 & in2. 
				The result will be assigned to out.
				
			Example: Delay in a continuous assign
				assign #10 out = in1 & in2;   //Where #10 is 10 time unit
			
				+-----------------------------------------------------------------+
				|                   ______________________              __        |
				| in1   ___________|                      |____________|  |_____  |
				|                                                                 |
				|                   ____________________________________________  |
				| in2   ___________|                                              |
				|                                                                 |
				|       ____              ______________________                  |
				| out   xxxx|____________|                      |_______________  |
				|                                                                 |
				| time      10    20    30    40    50    60    70    80  85      |
				+-----------------------------------------------------------------+
				Notice the time in 80-85 mark.
				This is called Inertial delay

		Implicit continuous assignment delay
			Specify both a delay and an assignment on the net
			
			Example: 
				wire #10 out = in1 & in2;

		Net Declaration Delay
			A delay can be specified on a net when it is declared without putting a continuous assignment on the net
			Example: Net Delays
				wire #10 out;
				assign out = in1 & in2;

	Examples
		Example 1: 4 bit Full Adder, Using Dataflow Operators
			module fulladd4 (sum, c_out, a,b,c_in);    //Defines a 4bit full adder by using dataflow statements
			
				//IO port declarations
				output [3:0] sum;
				output c_out;
				input [3:0] a,b;
				input c_in;
				
				//Specify the function of a full adder
				assign {c_out, sum} = a+b+c_in;
				
			endmodule

		Example 2: Dataflow description of 2 to 4 line decoder with enable input (E)
			module decoder_df (A,B,E,D);
				input A,B,E;
				output [3:0] D;
				assign D[3] =~(~A & ~B & ~E);
				assign D[2] =~(~A & B & ~E);
				assign D[1] =~( A & ~B & ~E);
				assign D[0] =~( A & B & ~E);
				
				Or assign D[3] =~(~A & ~B & ~E),
				D[2] =~(~A & B & ~E),
				D[1] =~( A &~B & ~E),
				D[0] =~( A & B & ~E);
			endmodule

//////////////////////////////////////////////////////////////////////////////////////////////////
13. Behavioral Modelling

	Structured procedures (initial and always block)
	Procedural Assignment (Blocking/Non-Blocking)
	Delays in Procedural Assignment
	Block Statement (begin-end/fork-join)
	Conditional and Multiway branching statements
	Looping Constructs (While, For, Repeat, Forever)
	Examples
	
	Structured procedures (initial and always block)
		Verilog supports two structured procedure statements
			Initial
			Always
		All behavioral statements are written inside these blocks
		These blocks run in parallel i.e concurrent in nature
		Their activity starts at 0 simulation time
		Blocks cannot be nested
		
		Initial Statement
			Executable once only
			Execution starts at 0 simulation time
			Execution stops when the last statement is executed
			Parallel execution in case of multiple initial blocks
			Multiple statements inside an initial block needs to be grouped with begin and end statements
			
			Example:
				module stimulus;
				
				reg x,y, a,b, m;
				
				initial
					m = 1'b0;      //single statement, does not need to be grouped
				
				initial
				begin	
					#5 a = 1'b1;   //multiple statements, need to be grouped with "begin" and "end"
					#25 b = 1'b0;
				end
				
				initial
				begin
					#10 x = 1'b0;
					#25 y = 1'b1;
				end
				
				initial
					#50 $finish;
				
				endmodule
				
			Simulation Result
				+------+--------------------+
				| time | Statement Executed |
				+------+--------------------+
				| 0    | m=1'b0;            |
				| 5    | a=1'b1;            |
				| 10   | x=1'b0;            |
				| 30   | b=1'b0;            |
				| 35   | y=1'b1;            |
				| 50   | $finish;           |
				+------+--------------------+
			
		Always Statement
			Repeats continuously throughout the duration of simulation time
			Concurrent in nature and starts at 0 simulation time
			Parallel execution in case of multiple always blocks
			A deadlock condition will be created if an always construct has no control for simulation time
			
			Example
				module clock_gen;
				
				reg clock;
				
				//Initialize clock at time 0
				initial
					clock = 1'b0;
					
				//Toggle clock every half-cycle (time period = 20)
				always
					#10 clock = ~clock;
					
				initial
					#1000 $finish;
					
				endmodule

	Procedural Assignment
		Procedural assignments update values of reg, integer, real, or time variables.
		The value placed on a variable will remain unchanged, 
			until another procedural assignment updates the variable with a different value.
		These are unlike continuous assignments
		
		2 types of procedural assignments
			Blocking Assignments
			Non-Blocking Assignments
			
		Blocking Assignments
			Represented with the sign "="
			Statements are executed sequentially
			Statements are executed in the order they are specified in a sequential block
			One statement blocks the execution of other statements until it is executed
			Delay values will be added
			Blocking assignments can be used in both procedural and contagious assignments
			
			Example
				reg x, y, z;
				reg [15:0] reg_a, reg_b;
				integer count;
				
				//All behavioral statements must be inside an initial or always block
				
				initial
				begin
				x=0; y=1; z=1;             //Scalar assignments
				count=0;                   //Assignment to integer variables
				reg_a=16'b0; reg_b=reg_a;  //Initialize vectors
				#15 reg_a[2]=1'b1;         //Bit select assignment with delay
				#10 reg_b[15:13]={x,y,z};  //Assign result of concatenation to
				count=count+1;             //Assignment to an integer (increment)
				end

		Non-Blocking Assignments
			Represented with the sign "<="
			Statements are executed concurrently
			Right-hand sides are evaluated first, subsequently the specified assignments are scheduled
			Non-blocking assignments can't be used in a continuous assignment statement or in a net declaration
			Order of the execution of distinct non-blocking assignments to a given variable shall be preserved
			
			Example
				reg x, y, z;
				reg [15:0] reg_a, reg_b;
				integer count;
				
				//All behavioral statements must be inside an initial or always block
				
				initial
				begin
				x=0; y=1; z=1;              //Scalar assignments
				count=0;                    //Assignment to integer variables
				reg_a=16'b0; reg_b=reg_a;   //Initialize vectors
				reg_a[2] <= #15 1'b1;       //Bit select assignment with delay
				reg_b[15:13] <= #10{x,y,z}; //Assign result of concatenation to
				count<=count+1;             //Assignment to an integer (increment)
				end

	Delays in Procedural Assignment
		Like timer delays in PLC systems.
			Regular Delay
			Intra-assignment delay

		Regular Delay				
			With a regular delay, the specified delay applies to the entire operation. 
			After the delay period, the RHS is evaluated, and the result is then assigned to the LHS.

			Example
				initial
				begin
					x=0;                    //no delay control
					#10 y=1;                //delay control with a number. Delay execution of y=1 by 10 units
					
					#latency z=0;           //Delay control with identifier
					#(latency+delta) p=1;   //Delay control with expression
					
					#y x = x+1;             //Delay control with identifier. Take value of y. 
											//"x+1" will be assigned to "x" after "y" delay
					
					#(4:5:6) q=0;           //Minimum, typical and maximum delay values
											//Discussed in gate-level modelling chapter
					end
			
		Intra Assignment Delay	
			RHS of the equation is evaluated at current time but the value is assigned to LHS after the delay time
			Can be applied to both blocking and nonblocking assignment
			
			Example
				initial
				begin 
					x=0; 
					z=0;
					y=#5 x+z;    //Evaluate x+z at time=0, wait 5 time units and assign to y
				
	Block Statements
		Two types of block statements 
			Sequence Block
			Parallel Block
			
		Sequence Block
			The "begin-end" is used to group multiple statements
			Statements are executed in the order they are mentioned
			Delay is treated relative to the simulation time and previous statement
			
			Example1: Sequential block without delay
				initial
				begin
					x=1'b0;
					y=1'b1;
					z={x,y};
					w={y,x};
				end
				
			Example2: Sequential blocks with delay
				reg x, y;
				reg [1:0] x, w;
				
				initial
				begin
					x = 1' b0;       //Completes at time 0
					#5 y = 1'b1;     //Completes at simulation time 5
					#10 z = {x, y};  //Completes at simulation time 15
					#20 w = {y, x};  //Completes at simulation time 35
				end
			
		Parallel Block
			The "fork-join" is used to group multiple statements
			Statements are executed are concurrently
			Delay is treated relative to the simulation time of entering the block
			
			Example
				reg x, y;
				reg [1:0] z, w;
				
				initial
				fork
					x = 1'b0;         //Completes at simulation time 0
					#5 y = 1'b1;      //Completes at simulation time 5
					#10 z = {x, y};   //Completes at simulation time 10
					#20 w = {y, x};   //Completes at simulation time 20
				join
				
				
	Conditional and Multiway branching statements
		IF-Else
			Multiple statements inside an if else statement is enclosed by begin-end block
			Nested if-else-if statements also come in conditional statement
		
			Syntax
				//Type 1 conditional statement. No else statement
				//Statement executes or does not executed
				if (<expression>) true_statement;
				
				//Type 2 conditional statement. One else statement
				//Either true_statement or false_statement is evaluated
				if (<expression>) true_statement;
				else false_statement;
					
				//Type 3 conditional statement. Nested if-else-if
				//Choice of multiple statements. Only one is executed
				if (<expression1>) true_statement1;
				else if (<expression2>) true_statement2;
				else if (<expression3>) true_statement3;
				else default_statement;
					
		Multiway Branching
			Keywords: case, endcase and default
			Multiple statements can be contained by begin-end block
			
			Syntax
				case (expression)
					alternative1: statement1;
					alternative2: statement2;
					alternative3: statement3;
					alternative4: statement4;
					...
					...
					...
					default: default_statement;
				endcase

	Looping Constructs (While, For, Repeat, Forever)
		While Loop
			Multiple statements are grouped in begin-end
			Example
				//Increment 0 to 127, exit at 128.
				integer count;
				
				initial
				begin
					count = 0;
					while (count<128)    //Execute loop to 127 and exit at 128
					begin
						$display("Count = %d", count);
						count = count + 1;
					end
				end

		For Loop
			Notice there is no "end to "begin-end"
			Example
				integer count;
				initial
					for(count=0; count<128; count=count+1)
						$display("Count = %d", count);

		Repeat Loop
			Iterates for fixed number of times
			No expression required
			Loop must contain a number
			
			Example
				initial
				begin
					count=0;
					repeat(128)
					begin
						$display("Count = %d", count);
						count=count+1;
					end
				end

		Forever Loop
			Executes forever until a disable statement or $finish is encountered
			No expression needed
			
			Example
				initial
				begin
					clock = 1'b0;
					forever #10 clock = ~clock;  //Clock with period of 20 units
				end


	Examples
		Example 1: 4X1 mux
			//4-to-1 multiplexer. Port list is taken exactly from the I/O diagram
			module mux4_to_1 (out, i0, i1, i2, i3, s1, s0);
			
			//Port declarations from the I/O diagram
			output out;
			input i0, i1, i2, i3;
			input s1, s0;
			
			//output declared as register
			reg out;
			
			//Recompute the signal out if any input signal changes.
			//All input signals that cause a recomputation of out to occur must go into "always @(..)" sensitivity list.
			always @(s1 or s0 or i0 or i1 or i2 or i3)
			begin
				case ({s1, s0})
				2'b00: out = i0;
				2'b01: out = i1;
				2'b10: out = i2;
				2'b11: out = i3;
				default: out = 1'bx;
				endcase
			end
			
			endmodule

		Example 2: 4-bit counter
			//4-bit Binary Counter
			module counter(Q, clock, clear);
			
			//I/O ports
			output [3:0] Q;
			input clock, clear;
			
			//Output defined as register
			reg [3:0] Q;
			
			always @(posedge clear or negedge clock)
			begin
				if (clear)
					Q = 4'd0;
				else
					Q = (Q+1) % 16;
			end
			
			endmodule



//////////////////////////////////////////////////////////////////////////////////////////////////
14. System Tasks and Compiler Directive

	System tasks
		Internal variable monitoring ST 
		Simulation control tasks
		Simulation time related tasks
	Compiler Directives

	System Tasks
		Used for generating input and output during simulation
		Syntax begins with "$"

		Internal variable monitoring ST 
			$display, $write, $strobe, $monitor	
				System tasks that extract data like $monitor need to be in an initial or always block
				$display and $strobe display once everytime they are executed 
				$monitor displays everytime one of the parameter changes
				$display automatically adds a new line character and $write does not add
				Difference between $display and $strobe is that $strobe displays the parameters at the very end of the current simulation time unit
				$display shows the parameters when it is being executed

				Syntax
					$display ("format_string", par_1, par_2);
					$strobe ("format_string", par_1, par_2);
					$monitor ("format_string", par_1, par_2);

				Example
					module example_display;
						reg new_reg;
						initial
							begin
							new_reg = 1'b1;
							$strobe ("Strobe value of new_reg = %b", new_reg);
							$display ("Display value of new_reg = %b", new_reg);
							new_reg = 1'b0;
							$monitor ("Monitor value of new_reg = %b", new_reg);
						end
					endmodule

					Result:
						Strobe value of new_reg = 0    //new_reg begins with 0
						Display value of new_reg = 1   //new_reg turns1 at 1'b1
						Monitor value of new_reg = 1   //Displays the changes from 1 to 0
						Monitor value of new_reg = 0

			$random
				Generates a random integer everytime it is called
				If a sequence is to be repeateable, the first time invokes a random numerical seed
				Otherwise the seed is derived from the computer clock
				
				Syntax:
					xyz = $random[(integer)];
					
		Simulation Control Tasks
			$reset, $stop, $finish
				$reset resets the simulation back to time 0
				$stop halts the simulator and puts it in an interactive mode where the user can enter commands (pause)
				$finish exits the simulator back to the operating system (terminate)
				
		Simulation Time Related Tasks		
			$time, $stime, $realtime
				$time returns the current simulation time as a 64bit integer
				$stime returns the current simulation time as a 32bit integer
				$realtime returns the current simulation time as a real number

				Example 1:
					'timescale 10ns/1ns
					
					module p_array;
						logic clk;
						logic a;
						
						initial
							clk=0;
							
						always begin
							#50 clk = ~clk;
						end
						
						initial begin
							#1.55 a=0;
							#1.55 a=1;
							#50 $stop;
						end
						
						initial
							$monitor("Time = %0t, clk = %0b, a = %0b ", $time, clk, a);
							
						initial begin
							$dumpfile("dump.vcd");
							$dumpvars(0, p_array);
						end
					endmodule
					
					Result
						//Time = 0, clk=0, a=x
						//Time = 20, clk=0, a=0
						//Time = 30, clk=0, a=1
						//Time = 500, clk=1, a=1

				Example 2:
					'timescale 10ns/1ns
					
					module p_array;
						logic clk;
						logic a;
						
						initial
							clk=0;
							
						always begin
							#50 clk = ~clk;
						end
						
						initial begin
							#1.55 a=0;
							#1.55 a=1;
							#50 $stop;
						end
						
						initial
							$monitor("Time = %0t, clk = %0b, a = %0b ", $realtime, clk, a);  //Notice $realtime is used here instead of $time in example1
							
						initial begin
							$dumpfile("dump.vcd");
							$dumpvars(0, p_array);
						end
					endmodule
					
					Result
						//Time = 0, clk=0, a=x
						//Time = 16, clk=0, a=0
						//Time = 32, clk=0, a=1
						//Time = 500, clk=1, a=1

	Compiler Directives
		'define, 'include, 'timescale
		A compiler directive may be used to control the compilation of a verilog description
		The accent mark(') denotes a compiler directive
		A directive is effective from the point at which it is declared to the point at which another directive overrides it, even across file boundaries
		
		'define
			Gives a name to a collection of characters.
			Once defined, that name can be used in lieu of the characters.
			This name is then referred to as macro
			
			Example:
				'define size 8
				electrical [0:'size-1] out;   //size will be 1 instead of 8

		'include
			Will be replaced by the contents of a file
			It takes the filename as an argument which can be specified with a relative or absolute path to the file
			The included files may include other files, etc
			
			Example
				'include "disciplines.vams"
		
		'timescale
			The 'timescale compiler directive defines the time unit and the time precision for the modules that follow it
			The time unit and time precision is specified using 1, 10, 100 followed by a measurement unit (s, ms, us, ns, ps, fs)
			
			Example:
				'timescale 10ns/1ns

//////////////////////////////////////////////////////////////////////////////////////////////////
15. Task and Functions

	Basically called a "subroutine" in other languages
	Like other languages, this can also be reused on other modules

	Tasks
		Are declared with the keywords "task" and "endtask"
		Tasks must be used if any one of the following conditions is true for the procedure
			There are delay, timing, or event control constructs in the procedure
			The procedure has zero or more than one output arguments
			The procedure has no input arguments

		Syntax
			task [name];
				input [port_list];
				inout [port_list];
				output [port_list];
				begin
					[statements]
				end
			endtask
			
		Example
			task sum;
				input [7:0] a, b;
				output [7:0] c;
				begin
					c=a+b;
				end
			endtask
			
			initial begin
				reg [7:0] x, y, z;
				sum (x; y, z);
			end

		Example - Simple Task
			module simple_task();
			
			task convert;
			input [7:0] temp_in;
			output [7:0] temp_out;
			begin
				temp_out = (9/5)*(temp_in+32);
			end
			endtask
			
			endmodule
			
		Example - Task using Global Variables
			module task_global();
			
			reg [7:0] temp_out;
			reg [7:0] temp_in;
			
			task convert;
			begin
				temp_out = (9/5)*(temp_in+32);
			end
			endtask
			
			endmodule

		Example - Calling a task
			module task_calling(temp_a, temp_b, temp_c, temp_d);
			input [7:0] temp_a, temp_c;
			output [7:0] temp_b, temp_d;
			reg [7:0] temp_b, temp_d;
			
			'include "mytask.v"
			
			always @ (temp_a)
			begin
				convert(temp_a, temp_b);  //temp_a will act as input and temp_b will act as output
			end
			
			always @ (temp_c)
			begin
				convert(temp_c, temp_d);
			end
			
			endmodule

	Function
		Declared with the keywords "function" and "endfunction"
		Being used when the following conditions are true for the procedure
			A function cannot advance simulation-time, using constructs like #, @, etc
			A function shall not have nonblocking assignments
			A function without a range defaults to a one bit reg for the return value
			It is illegal to declare another object with the same name as the function in the scope where the function is declared

		Syntax
			function [automatic] [return_type] name ([port_list]);
				[statements]
			endfunction
			
		Example
			function [7:0] sum;
				input [7:0] a, b;
				begin
					sum=a+b;
				end
			endfunction

		Example - Simple Function
			module simple_function();
			
			function myfunction;
			input a, b, c, d;
			begin
				myfunction = ((a+b)+(c+d));
			end
			endfunction
			
			endmodule
			
		Example - Calling a Function
			module function_calling(a, b, c, d, e, f);
				input a, b, c, d, e;
			output f;
			wire f;
			
			'include "myfunction.v"   //The file with written function
			
			assign f = (myfunction(a, b, c, d)) ? e:0;
			
			endmodule

	Difference between Tasks and Functions
		+---------------------------------------+--------------------------------------+
		|               Task                    |               Function               |
		+---------------------------------------+--------------------------------------+
		| Can contain time control statements   | Executes in zero simulation time     |
		| like @(posedge.), delay operator(#)   |                                      |
		+---------------------------------------+--------------------------------------+
		| Can call any number of function or    | Can call any number of function      |
		| tasks within itself                   | within itself                        |
		+---------------------------------------+--------------------------------------+
		| Cannot return any value when called;  | Returns a single value when called   |
		| instead, the task can have output     | In SystemVerilog, the return value   |
		| arguments                             | can be optionally voided             |
		+---------------------------------------+--------------------------------------+
		| For example, "gt_result" is an output | For example, "gt_result" is assigned |
		| of a task to calculate the result of  | with the return of a function call to|
		| the greater of two input arguments    | calculate the result of the greater  |
		| arg1 and arg2                         | of two input arguments arg1 and arg2 |
		|                                       |                                      |
		| greater_val(arg1, arg2, gt_result);   | gt_result=greater_val(arg1, arg2)    |
		+---------------------------------------+--------------------------------------+


	Automatic (Re-entrant) task and Static task
		+---------------------------------------+---------------------------------------+
		|         Re-entrant Task               |             Static Task               |
		+---------------------------------------+---------------------------------------+
		| Has the keyword "automatic" between   | Does not have the keyword "automatic" |
		| the "task" keyword and identifier     | between the "task" keyword and        |
		|                                       | identifier                            |
		+---------------------------------------+---------------------------------------+
		| Variables declared within the task    | Variable declarations within the task |
		| are allocated dynamically for each    | are allocated statically              |
		| concurrent task call                  |                                       |
		+---------------------------------------+---------------------------------------+
		| All variables will be replicated in   | Each concurrent call to the task will |
		| each concurrent call to store state   | OVERWRITE the statically allocated    |
		| specific to that invocation           | local variables of the task from all  |
		|                                       | other concurrent calls to the task    |
		+---------------------------------------+---------------------------------------+
		| Variables declared are de-allocated   | Variables retain their values between |
		| at the end of task invocation         | invocations                           |
		+---------------------------------------+---------------------------------------+
		| Task items cannot be accessed by      | Task items can be accessed by         |
		| hierarchical inferences               | hierarchical inferences               |
		+---------------------------------------+---------------------------------------+
		| Task items shall be allocated new     | Task items can be shared across all   |
		| across all uses of the task executing | uses of the task executing            |
		| concurrently                          | concurrently                          |
		+---------------------------------------+---------------------------------------+

//////////////////////////////////////////////////////////////////////////////////////////////////
16. Test Bench Writing

	Combinational design
	Sequential design
	Clock generation and input synchronization

	Combinational design
		Format:
			module test_bench;
				//input declaration
				//output declaration
				
				//DUT instantiation
				
				initial
				begin
					//initialization
				end
				
				initial
				begin
					//variation(fixed values/loops)
				end
				
				initial
				begin
					$monitor("",);
					$finish;
				end
			endmodule
			
	Sequential design
		Format:
			module test_bench;
				//input declaration
				//output declaration
				
				//DUT instantiation
				
				initial
				begin
					//clock_generation
				end

				initial
				begin
					//initialization
				end

				initial
				begin
					//variation(fixed values/loops)
				end
				
				initial
				begin
					$monitor("",);
					$finish;
				end
			endmodule

	Full Adder
		Format:
			module full_adder (sum, carry, a, b, cin);
				input a,b,cin;
				output sum,carry;
				
				assign sum = a^b^cin;
				assign carry = (a$b) | (b&cin) | (cin&a);
			endmodule
		
		
		Test-bench 1
			module test_bench();
				reg a, b, cin;
				wire sum, carry;
				
				full_adder FA (sum, carry, a, b, cin);
				
				initial
				begin
					a=0; b=0; cin=0;
				end
				
				intial
				begin
					#10 a=1; b=0; cin=0;
					#10 a=1; b=1; cin=0;
					#10 a=0; b=1; cin=1;
					#10 a=1; b=1; cin=1;
				end
				
				initial
				begin
					$monitor ($time, "a=%b, b=%b, cin=%b, sum=%b, carry=%b", a, b, cin, sum, carry);
					#60 $finish;
				end
			endmodule

		Test-bench 2
			module test_bench();
				reg a, b, cin;
				wire sum, carry;
				integer i;
				
				full_adder FA (sum, carry, a, b, cin);
				
				initial
				begin
					a=0; b=0; cin=0;
				end
				
				intial
				begin
					for(i=1; i<8; i=i+1)
						begin
						{a, b, cin} = i;
						#10;
					end
				end
				
				initial
				begin
					$monitor ($time, "a=%b, b=%b, cin=%b, sum=%b, carry=%b", a, b, cin, sum, carry);
					#60 $finish;
				end
			endmodule

	J-K flip-flop
		Format:
			module jk_ff(q, qb, j, k, clk);
			
			input j,k,clk;
			output reg q;
			output qb;
			
			parameter Hold = 2'b00,
					  ReSet = 2'b01,
					  Set = 2'b10,
					  Toggle = 2'b11;
					  
			assign qb = ~q;
			always@(posedge clk)
				begin
					case({j,k})
						Hold: q<=q;
						ReSet: q<=0;
						Set: q<=1;
						Toggle: q<=~q;
					endcase
				end
			endmodule

		Test-bench
			module jk_ff_tb();
				reg j,k,clk;
				wire q,qb;
				
				jk_ff DUT(q,qb,j,k,clk);
				
				initial
				begin
					clk = 1'b0;
					forever #5 clk = ~clk;
				end
				
				initial
				begin
					{j,k} = 2'b00; #10;
				end
				
				initial
				begin
					j=1'b0; k=1'b0; #10;
					j=1'b1; k=1'b0; #10;
					j=1'b0; k=1'b0; #10;
					j=1'b0; k=1'b1; #10;
					j=1'b0; k=1'b0;
				end
				
				initial
				begin
					$monitor("input j=%b, k=%b output q=%b, qb=%b", j, k, q, qb);
					#100 $finish;  //Total time "#100" must not be more than the sum of time stated above
				end
				
			endmodule

			#Terminal Output:
			#input j=0, k=0 ouput q=x, qb=x
			#input j=1, k=0 ouput q=x, qb=x
			#input j=1, k=0 ouput q=1, qb=0
			#input j=0, k=0 ouput q=1, qb=0
			#input j=0, k=1 ouput q=1, qb=0
			#input j=0, k=1 ouput q=0, qb=1
			#input j=0, k=0 ouput q=0, qb=1

	4 bit synchronous loadable binary up-down counter
		Format:
			module up_down_counter(clk,rst,load,din,up_down,count);
				input [3:0] din;
				input clk,rst,load,up_down;
				output reg [3:0] count;
				
				always@(posedge clk)
				begin
				if(rst)
					count <= 0;
				else if (load)
					count <= din;
				else if (up_down)
					count <= count + 4'd1;
				else
					count <= count - 4'd1;
				end
			endmodule
		
		Test bench:
			module up_down_counter_tb();
				reg [3:0] din;
				reg clk,rst,load,up_down;
				wire [3:0] count;
				up_down_counter DUT (clk,rst,load,din,up_down,count);
				
				initial
				begin
					clk = 1'b0;
					forever #5 clk = ~clk;
				end
				
				initial
				begin
					{rst,load,up_down} = 3'd0;
					din = 4'd0;
					#10;
				end
				
				initial
				begin
					{rst,load,up_down} = 3'b100; din=4'd3; #10;
					{rst,load,up_down} = 3'b010; din=4'd4; #10;
					{rst,load,up_down} = 3'b001; din=4'd0; #10;
					{rst,load,up_down} = 3'b001; din=4'd0; #10;
					{rst,load,up_down} = 3'b001; din=4'd0; #10;
					{rst,load,up_down} = 3'b001; din=4'd9; #10;
					{rst,load,up_down} = 3'b001; din=4'd9; #10;
					{rst,load,up_down} = 3'b001; din=4'd9; #10;
					{rst,load,up_down} = 3'b000; din=4'd9; #10;
					{rst,load,up_down} = 3'b000; din=4'd9; #10;
					{rst,load,up_down} = 3'b010; din=4'd1;
				end
				
				initial
				begin
					$monitor ("input din=%b, rst=%b, load=%b, up_down=%b output count=%b", din, rst, load, up_down, count);
					#150 $finish;
				end
			endmodule
				
			#Terminal Output:
			#input din=0011, rst=1, load=0, up_down=0 output count=xxxx
			#input din=0011, rst=1, load=0, up_down=0 output count=0000
			#input din=0100, rst=0, load=1, up_down=0 output count=0000
			#input din=0100, rst=0, load=1, up_down=0 output count=0100
			#input din=0000, rst=0, load=0, up_down=1 output count=0100
			#input din=0000, rst=0, load=0, up_down=1 output count=0101
			#input din=0000, rst=0, load=0, up_down=1 output count=0110
			#input din=0000, rst=0, load=0, up_down=1 output count=0111
			#input din=1001, rst=0, load=0, up_down=1 output count=0111
			#input din=1001, rst=0, load=0, up_down=1 output count=1000
			#input din=1001, rst=0, load=0, up_down=1 output count=1001
			#input din=1001, rst=0, load=0, up_down=1 output count=1010
			#input din=1001, rst=0, load=0, up_down=0 output count=1010
			#input din=1001, rst=0, load=0, up_down=0 output count=1001
			#input din=1001, rst=0, load=0, up_down=0 output count=1000
			#input din=0001, rst=0, load=1, up_down=0 output count=1000
			#input din=0001, rst=0, load=1, up_down=0 output count=0001

	D Flip-flop
		Format:
			module d_ff(d,clk,reset,q,qb);
				input d,clk,reset;
				output reg q;
				output qb;
				
				assign qb=~q;
				
				always@(posedge clk)
				begin
				if(reset)
					q <= 0;
				else
					q <= d;
				end
			endmodule
		
		Test bench:













.









