Verilog Basics
//////////////////////////////////////////////////////////////////////////////////////////////////
CONTENTS
	01. Introduction
	02. Level of Abstraction
	03. Modules and Instantiation
	04. Simulation, Synthesis and Design Methodology
	05. Data Types
	06. Reg Data Types
	07. Net Data Types
	08. Vectors, Arrays, Memories, Parameters and Strings
	09. Operators
	10. Examples
	11. Gate Level Modeling
	12. Behavioral Modeling
	14. Compiler Directive and System Tasks
	15. Task and Functions
	16. Test Bench Writing

//////////////////////////////////////////////////////////////////////////////////////////////////
01. Introduction
	
	Concurrency [Executed simultaneosly]
		Verilog and VHDL are concurrence languages
		C-Type languages are all sequential languages
		Python is not a C-Type Language, but is still is sequential
	Notion of Time
		HDLs includes notion of time
		Normal languages like C and Python do not have notion of time	
		
	C-Type Languages
		PHP, C, C++, Javascript, Dart, Swift, R
	Verilog
		Weakly Typed
		IEEE 1364-2001
		File Extension as *.v
		Describes the structure and behavior of electronic circuits
		Syntax is similar to C
		Case sensitive
		Simple Data-types
	VHDL
		Strongly typed and deterministic
			The code is longer compared to verilog
		File Extension as *.vhd
		Model the behavior and structure of digital systems at multiple abstraction levels
		Syntax based on Pascal and Ada
		Not case sensitive
		Complex data types


//////////////////////////////////////////////////////////////////////////////////////////////////
02. Level of Abstraction

	Four Levels of Abstraction
		Switch Level (Switching)
		Gate Level (Logic Gates Interconnection)
		Data Flow Level (Based on Equations)
		Behavioral Level (Based on Behavior of the Circuit)

	Switch Level
		Module Implemented in terms of switches
		Syntax: mos_name instance_name (output, data, control)
		Example:
			NMOS and PMOS are used as switches
			
			=======================
			module inverter(Q,A)
				input A;
				output Q;
				supply1 vdd;
				supplt0 vss;
				
				pmos p(Q,vdd,A);
				nmos n(Q,vss,A);
			endmodule
			=======================
			
			|  Vdd--------------+-----------
			|                   |
			|                |  |
			|              | +--+
			|         +---0| |      pmos
			|         |    | +--+
			|         |      |  |
			|  A -----+         +------ Q
			|         |      |  |
			|         |    | +--+
			|         +----| |      nmos
			|              | +--+
			|                |  |
			|                   |
			|  Vss--------------+-----------
			|
			| Notice the 2 MOSFETs
			
	Gate Level
		Syntax: Primitive_name instance_name(output, inputs)
		Example:
			
			=====================
			1. and G1(out, A, B);
			|           ____
			|    A-----|    \
			|          |     |----- out
			|    B-----|____/
			|
			=====================
			
			=====================
			2. nand G2(Y, A, B);
			|           ____
			|    A-----|    \
			|          |     |O---- Y
			|    B-----|____/
			|
			=====================

			=====================
			3. or G3(out, A, B);
			|           ___
			|    A-----\   \
			|           \   \----out 
			|           /   /
			|    B-----/___/
			|
			=====================

	Data Flow Level
		Register Transfer Level
		Module is designed by specifying data flow
		Signals are assigned by data manipulating equations
		Design is implemented using continuous assignments
		All assignments are concurent in nature
		
		Example:
			=====================
			"assign" keyword is used as variable for this example
			
			assign z = x & y;    //And
			assign p = q | r;    //Or
			assign z = ~y;       //Or
			
	Behavioral Level
		The highest level of abstraction provided by HDLs
		Describes the system by its behavior
		Elements like function, task and blocks can be used
		Two important constructs:
			Initial
			Always
		Example:
			=====================
			(2*1 mux)
			
			always@(i0, i1, sel)
			begin
				if(sel)
					out = i1;
				else
					out = i0;
			end
			=====================
		
//////////////////////////////////////////////////////////////////////////////////////////////////
03. Modules and Instantiation

	Modules
		Basic building block in Verilog
		Can be an element or a collection of lower level design blocks
		Provides required functionality to the higher level block through its port interface but hide internal implementation
		Provides flexibility to the designer to modify the module internals without affecting the rest of the design
		
		Verilog Framework
		=============================
		module module_name (x,y,z);
			input x,y;
			output z;
			statements;
			............;
			............;
		endmodule
		=============================
	
	Instantiation
		Allows the creation of hierarchy in Verilog description
		A process of creating object from a module template and the objects are called instances
		In Verilog, nesting is illegal
		One module definition cannot contain another module definition
		However, copies of other module can be incorporated by instantiating them


		Example: 4*1 mux using 2*1 mux
		=============================
		|
		|
		|               |\
		|      i0 ----> | \  2x1
		|               |  | mux
		|               |  |--------+
		|               |  |        |
		|      i1 ----> | /         |    |\
		|               |/ |     x1 +--->| \  2x1
		|                  |             |  | mux
		|                  |             |  |----> out
		|  +-------->------+     x2 +--->|  |
		|  |                        |    | /
		|  |            |\          |    |/ |
		|  |   i2 ----> | \  2x1    |       |
		|  |            |  | mux    |      /|\
		|  |            |  |--------+       |
		|  |            |  |                |
		|  |   i3 ----> | /                 |
		|  |            |/ |                |
		|  |               |                |
		|  +-------<-------+                |
		|                  |                |
		|                 /|\               |
		|                  |                |
		|                  |                |
		|                  s1               s0
		|
		|
		=============================
		
		Code
		=============================
		//2*1 mux
		module mux_2to1 (i0,i1,sel,out);
			input i0,i1,sel;
			output out;
			always@(i0,i1,sel)
			begin
				if(sel)
					out = i1;
				else
					out = i0;
			end
		endmodule
		
		//4*1 mux
		module mux_4to1 (i0, i1, i2, i3, s1, s0, out);
			input i0, i1, i2, i3, s1, s0;
			output out;
			wire x1, x2;
			
			mux_2to1 m1 (i0, i1, s1, x1);
			mux_2to1 m2 (i2, i3, s1, x2);
			mux_2to1 m3 (x1, x2, s0, out);
		endmodule
		=============================
			

	Verilog Keywords
		Case sensitive
		$, underscore, alphanumeric characters can be used
		
		Examples:
			Correct format:
				new_block
				new_block1
				new_block$
			Incorrect format:
				1new_block
				$new_block
				1_new_block

	Comments similar to C++
		Single line comments: --> //
		Multiple line comments --> /* example */



//////////////////////////////////////////////////////////////////////////////////////////////////
04. Simulation, Synthesis and Design Methodology

	Simulation
		Used for verifying the functionality of the digital design that is modeled using HDL like Verilog
		In simulation, apply different input stimulus to the design at different timing to check the RTL code behaves as intended.

		| 
		|          +-----------------+
		| Verilog  |                 |
		| Module ->|                 |
		|          |   Simulation    |--> Evaluation
		| Test     |                 |     Result
		| Bench -->|                 |
		|          +-----------------+
		|
		
	Synthesis
		A process where the design is modeled using HDL is translated into an implementation consisting of logic gates
		It makes an optimal design based on the working strategy
		It gives the consumption of resources as available
		
		| 
		|          +-----------------+
		|          |                 |
		| Verilog  |                 |--> ASIC
		| Module-->|    Synthesis    |
		|          |                 |--> FPGA
		|          |                 |
		|          +-----------------+
		|

	Design Methodologies
		Top Down
			Define the top level block and identify the sub blocks necessary to build the top level blocks
			Sub Blocks are further subdivided until it cannot be subdivided further (Leaf cells)
			Looks similar to organisation chart
		
		Bottom Up
			Identify the building blocks that are available (Leaf cells)
			Combine these building blocks to build the bigger blocks
			These cells are then used for higher level blocks
			Continue until top-level block is established
			Instead of starting from top level block, this method starts from leaf cells

//////////////////////////////////////////////////////////////////////////////////////////////////
05. Data Types

	Specifies which type of value can be assigned to a variable
	What type of mathematical operation can be applied to the data type
	2 types of data type:
		Registers
		Nets
		
	Register Data Type
		Represents data storage elements
		A variable that can hold a value
		Commonly declared by keyword "reg"
		Default value of register data type is "X"
		Register represents a class of data types such as reg, integer, real, time, etc
		
	Net Data Type
		Represents connections between hardware elements
		Must be continuously driven i.e cannot be used to store values
		Declared primarily with the keyword "wire"
		Default value of net is "Z"
		Represents a class of data types such as wire, wand, wor, tri, triand, trior, trireg
		
	Values and Signal Strength
		Verilog supports 4 value levels and 8 strength levels to model the functionality of real hardware
		
		+--------+-------------------------+
		| Value  | Condition in Hardware   |
		| Levels |       Circuits          |
		+--------+-------------------------+
		|   0    | Logic Zero, false cond  |
		|   1    | Logic One, true cond    |
		|   X    | Unknown Logic value     |
		|   Z    | High Impedance, Float   |
		+--------+-------------------------+

		+-----------+-----------+----------------+
		| Degree    | Strength  | Type           |
		|           | Level     |                |
		+-----------+-----------+----------------+
		| Strongest | supply    | Driving        |
		|    / \    | strong    | Driving        |
		|   /_|_\   | pull      | Driving        |
		|     |     | large     | Storage        |
		|     |     | weak      | Driving        |
		|     |     | medium    | Storage        |
		|     |     | small     | Storage        |
		|   Weak    | highz     | High Impedance |
		+-----------+-----------+----------------+
		
		+-----------------------------------------+
		| supply1 o--------+                      |
		|                  |-------o supply1      |
		| pull1   o--------+                      |
		+-----------------------------------------+
		If two signals of unequal strength are driven on a wire, the stronger signal prevails
		
		+-----------------------------------------+
		| strong1 o--------+                      |
		|                  |-------o X            |
		| strong0 o--------+                      |
		+-----------------------------------------+
		If two signals of equal strengths are driven on a wire, result will be unknown

	Port Assignments
		Input - internally net
		Output - internally reg or net, externally net
		Inout - only wire data type
	
		Input
		+---------------------------------------+
		|             +----------------+        |
		|             |     module     |        |
		|             |                |        |
		| reg or net  |  net           |        |
		|     ------->+---->           |        |
		|    input    |                |        |
		|             +----------------+        |
		+---------------------------------------+
		
		Output
		+---------------------------------------+
		|             +----------------+        |
		|             |     module     |        |
		|             |                |        |
		|             |     reg or net |  net   |       
		|             |         ------>+---->   |       
		|             |                | Output |       
		|             +----------------+        |
		+---------------------------------------+
		
		Inout
		+---------------------------------------+
		|             +----------------+        |
		|             |     module     |        |
		|             |                |        |
		|      net    |  net           |        |
		|     <------>+<--->           |        |
		|    inout    |                |        |
		|             +----------------+        |
		+---------------------------------------+

//////////////////////////////////////////////////////////////////////////////////////////////////
06. Register Data Types

	Represents data storage elements
	A variable that can hold a value
	Commonly declared by keyword "reg"
	Default value of register data type is "X"
	Register represents a class of data types such as reg, integer, real, time, etc
		reg: most widely used
		integer: used for loop counting
		real: used for storing float point numbers
		time: keeps track of simulation time
		
	Example:
		reg count;         //single bit register variable
		reg [7:0] bus;     //8 bit bus
		
		=================================
		reg reset;
		initial
		begin
		reset = 1'b0;         //reset to 0
		#10 reset = 1'b1;     //after 10 counts delay will be value of 1
		#10 reset = 1'b0;     //after 10 counts delay will be value of 0
		end
		=================================
	
	Integer Data Type
		A general purpose register data type
		Declared by the keyword "integer"
		Store the values as quantities eg. 0, 4, -17, -148, etc
		Used for counting
		Synthesizeable 
		Default value is "X"
		Default width is 32bits
		
		Example:
		=================================
		integer count, new_num;
		initial
		begin
		count = 4;
		new_num = -17;
		end
		=================================
		
	Real Data Type
		Declared as "real"
		Allows decimal and scientific notation eg. 0.3, 4.63, -17.5, -1.485, etc
		Not synthesizeable
		Default value is 0.0
		Rounded off to nearest integer when it is assigned to an integer
		
		Example1:
		=================================
		real count, new_num;   //2 variables
		initial 
		begin
		count = 4.76;          //assigns "4.76" to count
		new_num = -1.3;        //assigns "-1.3" to new_num
		end
		=================================
		
		Example2:
		=================================
		integer a;
		real b;
		initial
		begin
		b = -6.5;
		a = b;     //a will be assigned as -7
		end
	
	Time Data Type
		Used to store timer
		Declared as keyword "time"
		Time variables are unsigned
		Width is implementation specific but is at least 64 bits
		Not synthesizeable (Useful for testbench)
		Default value is "X"
		
		Example1:
		=================================
		time new_sim_time;
		initial
		begin
		new_sim_time = $time;  //saves the current simulation time
		end

//////////////////////////////////////////////////////////////////////////////////////////////////
07. Net Data Types

	Represents connections between hardware elements
	Must be continuously driven, and connot be used to store values
	Declared primarily with keyword "wire"
	Default value of net is "Z"
	Represents a class of data types such as wire, wand, wor, tri, triand, trior, trireg
	The term "wor" and "wand" are simpy "wire OR gate" and "wire AND gate"
	To model power supply connection, "supply0" and "supply1" will be used 
	Both "wire" and "tri" are equivalent. 
		when there are multiple drivers driving them, the terms wor, wand, trior, triand will be used
	
	Wire
		
		|
		|           ____  
		|  a ------|     \
		|          | and  |---- c
		|  b ------|____ /
		|
		|
		|          +---------+
		|          |         |
		|  a ----->| Half    |----> sum
		|          | Adder   |
		|  b ----->|         |----> carry
		|          |         |
		|          +---------+
		
		Code
		====================================
		module half_add (a, b, sum, carry);
			input a, b;
			output sum, carry;
			wire sum, carry;
			
			assign sum = a^b;
			assign carry = a&b;
		endmodule
		====================================
		
	Wire OR and AND (wor, wand)
	
		|
		|           ____  
		|  a ------|     \
		|          | and  |----|
		|  b ------|____ /     |
		|                      |  
		|                      +---- y
		|           ____       |
		|  a ------\     \     |
		|           \ or  \----+
		|           /     /
		|  b ------/____ /
		|
		|
		
		Code: Y=(A&B)&(C|D)
		====================================
		module use_of_wire (y,A,B,C,D);
			input A, B, C, D;
			output y;
			wand y;
			
			assign y = A&B;
			assign y = C|D;
		endmodule
		====================================

	Supply1 and Supply0
		====================================
		module using_wire_supply(Y,A,B,C,D);
			input A,B,C,D;
			output Y;
			
			supply1 vdd;
			supply0 gnd;
			
			or G1(x1,A,gnd);
			and G2(x2,B,vdd);
			xor G3 (Y,x1,x2);
		endmodule
		====================================

	Numbers
		Syntax: <size>'<base><number>
		
		1'b1       //logic-1(1-bit) where "b" is binary
		8'h21      //8 bit number 0010 0001 where "h" is hexadecimal, 2 is 0010 and 1 is 0001
		12'ha35    //12 bit number 1010 0011 0101 where "h" is hexadecimal, "a" is 1010 in binary, 3 is 0011 and 5 is 0101
		12'o42xx   //12 bit number 100 010 xxx xxx where "o" is octal, 4 is 100, 2 is 010, x is xxx
		4'd1       //4 bit number 0001 where "d" is decimal
		35         //signed number, in 32 bits(size not specified)

		Binary: b or B
		Octal: o or O
		Decimal: d or D
		Hexadecimal: h or H 
		
		Use of underscores to improve readability
			"32'h64_ab" can also be written as "32'b 0110_0100_1010_1011"
			
		Zero, X, Z extension/filler
			4'bX0   //XXX_0 where 0 is binary and XXX_ is just an extension/filler to make it 4 bits
			5'd1    //0000_1 where 1 is decimal and 0000_ is just an extension/filler to make it 5 bits
			16'hz6  //ZZZZ_ZZZZ_ZZZZ_0110 where 0110 is hexadecimal of 6 and ZZZZ_ZZZZ_ZZZZ_ is just an extension/filler to make it 16 bits


//////////////////////////////////////////////////////////////////////////////////////////////////
08. Vectors, Arrays, Memories, Parameters and Strings



